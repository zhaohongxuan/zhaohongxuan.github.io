<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎来到zhaohongxuan的代码空间!</title>
    <url>/2015/04/03/the-start-of-my-blog/</url>
    <content><![CDATA[<p>每一天都是崭新的，在阳光下用力呼吸</p>
<p>世界好大，知识无涯，愿我能够在有生之年，能在知识的海洋多撷几枚贝壳</p>
<p>黑夜纵会漫长，过后便是黎明</p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
  </entry>
  <entry>
    <title>【微信接口学习】基础接口</title>
    <url>/2015/04/04/wechat-base-interface/</url>
    <content><![CDATA[<h2 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a>获取access_token</h2><p>access_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。</p>
<pre><code>1. access_token的存储至少要保留512个字符空间。
2. access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。
3. 需要中控服务器定时获取和刷新access_token，而且还需要被动刷新access_token
</code></pre>
<p><strong>接口调用请求说明</strong></p>
<p>http请求方式: <code>GET</code><br>    <a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a></p>
<p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<pre><code>&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125;
</code></pre>
<span id="more"></span>
<h2 id="获取微信服务器的IP地址"><a href="#获取微信服务器的IP地址" class="headerlink" title="获取微信服务器的IP地址"></a>获取微信服务器的IP地址</h2><p><strong>接口调用请求说明</strong></p>
<p>http请求方式: <code>GET</code><br>    <a href="https://api.weixin.qq.com/cgi-bin/getcallbackip?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/getcallbackip?access_token=ACCESS_TOKEN</a></p>
<p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<pre><code>&#123;
    &quot;ip_list&quot;:[&quot;127.0.0.1&quot;,&quot;127.0.0.1&quot;]
&#125;
</code></pre>
<h2 id="上传和下载多媒体文件"><a href="#上传和下载多媒体文件" class="headerlink" title="上传和下载多媒体文件"></a>上传和下载多媒体文件</h2><pre><code>1. 对多媒体文件的操作是通过media_id来进行的
2. 每个多媒体文件在发送到服务器3天后自动删除
</code></pre>
<p><strong>上传多媒体文件接口<br> 调用请求说明</strong></p>
<p>http请求方式: <code>POST/FORM</code></p>
<pre><code>http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&amp;type=TYPE
调用示例（使用curl命令，用FORM表单方式上传一个多媒体文件）：
curl -F media=@test.jpg &quot;http://file.api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&amp;type=TYPE&quot;
</code></pre>
<p>正确情况下的返回JSON数据包结果如下：<br>    {“type”:”TYPE”,”media_id”:”MEDIA_ID”,”created_at”:123456789}<br><strong>下载多媒体文件接口<br>调用请求说明</strong></p>
<p>http请求方式: <code>GET</code></p>
<pre><code>http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID
请求示例（示例为通过curl命令获取多媒体文件）
curl -I -G &quot;http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID&quot;
</code></pre>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见命令!</title>
    <url>/2015/04/10/base-git-command/</url>
    <content><![CDATA[<h2 id="Git基本操作命令"><a href="#Git基本操作命令" class="headerlink" title="Git基本操作命令"></a>Git基本操作命令</h2><h3 id="创建Git版本仓库"><a href="#创建Git版本仓库" class="headerlink" title="创建Git版本仓库"></a>创建Git版本仓库</h3><p>在本地的任何一个空目录，通过<code>git init</code>把目录变成一个Git仓库</p>
<pre><code>git init
</code></pre>
<h3 id="添加文件到Git仓库"><a href="#添加文件到Git仓库" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h3><pre><code>git add &lt;file_name&gt;
</code></pre>
<h3 id="提交文件到Git仓库"><a href="#提交文件到Git仓库" class="headerlink" title="提交文件到Git仓库"></a>提交文件到Git仓库</h3><pre><code>git commit -m &quot;&lt;commit_message&gt;&quot;
</code></pre>
<h3 id="显示提交日志"><a href="#显示提交日志" class="headerlink" title="显示提交日志"></a>显示提交日志</h3><pre><code>git log [--pretty=oneline] 
</code></pre>
<p>可以加上<code>--pretty=oneline</code>参数来减少输出的信息,	<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="回退上一个版本"><a href="#回退上一个版本" class="headerlink" title="回退上一个版本"></a>回退上一个版本</h3><pre><code>git reset --hard HEAD
</code></pre>
<p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，如果版本号较多，可以写成<code>HEAD~100</code>。</p>
<h3 id="查看命令日志"><a href="#查看命令日志" class="headerlink" title="查看命令日志"></a>查看命令日志</h3><pre><code>git reflog
</code></pre>
<h3 id="查看Git仓库状态"><a href="#查看Git仓库状态" class="headerlink" title="查看Git仓库状态"></a>查看Git仓库状态</h3><pre><code>git status
</code></pre>
<h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><pre><code>git add
</code></pre>
<h3 id="将暂存区文件提交到当前分支"><a href="#将暂存区文件提交到当前分支" class="headerlink" title="将暂存区文件提交到当前分支"></a>将暂存区文件提交到当前分支</h3><pre><code>git commit
</code></pre>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><pre><code>git checkout --&lt;file_name&gt;
</code></pre>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><pre><code>git rm &lt;file_name&gt;
</code></pre>
<span id="more"></span>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>在本地的仓库下面运行</p>
<pre><code>$ git remote add origin git@github.com:zhaohongxuan/zhaohongxuan.github.io.git
</code></pre>
<p>将本地库内容推送到远程库上</p>
<pre><code>git push [-u] origin master
</code></pre>
<p>其中<code>-u</code>参数会把本地的master分支和远程的master分支关联起来。</p>
<h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><pre><code>$ git clone git@github.com:zhaohongxuan/zhaohongxuan.github.io.git
</code></pre>
<p>地址可使用SSH协议的git地址，也可以使用Https协议的地址</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h3><pre><code>git branch
</code></pre>
<h3 id="显示本地、服务器所有分支"><a href="#显示本地、服务器所有分支" class="headerlink" title="显示本地、服务器所有分支"></a>显示本地、服务器所有分支</h3><pre><code>git branch -a
</code></pre>
<h3 id="显示本地分支和服务器分支的映射关系"><a href="#显示本地分支和服务器分支的映射关系" class="headerlink" title="显示本地分支和服务器分支的映射关系"></a>显示本地分支和服务器分支的映射关系</h3><pre><code>git branch -vv
</code></pre>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre><code>git checkout &lt;branch_name&gt;
</code></pre>
<h3 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h3><pre><code>git checkout -b  &lt;branch_name&gt;
</code></pre>
<h3 id="提交本地分支代码到远端服务器"><a href="#提交本地分支代码到远端服务器" class="headerlink" title="提交本地分支代码到远端服务器"></a>提交本地分支代码到远端服务器</h3><pre><code>git push origin &lt;remote_branch_name&gt;
</code></pre>
<p>如果远端服务器没有该分支，将会自动创建</p>
<h3 id="更新远端分支代码到本地当前分支"><a href="#更新远端分支代码到本地当前分支" class="headerlink" title="更新远端分支代码到本地当前分支"></a>更新远端分支代码到本地当前分支</h3><pre><code>git pull origin master
</code></pre>
<h3 id="合并分支到当前分支"><a href="#合并分支到当前分支" class="headerlink" title="合并分支到当前分支"></a>合并分支到当前分支</h3><pre><code>git merge &lt;branch_name&gt;
</code></pre>
<h3 id="合并远程master分支到当前分支"><a href="#合并远程master分支到当前分支" class="headerlink" title="合并远程master分支到当前分支"></a>合并远程master分支到当前分支</h3><pre><code>git merge origin/master
</code></pre>
<h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><pre><code>git checkout &lt;another_branch&gt;
git branch -d &lt;branch_name&gt;
</code></pre>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><pre><code>git push origin --delete &lt;branch_name&gt;
</code></pre>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>首先切换到要创建标签的分支</p>
<pre><code>git tag &lt;tag_name&gt;
</code></pre>
<p>标签打在最新提交的commit上</p>
<h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><pre><code>git tag
</code></pre>
<h3 id="查看标签详情"><a href="#查看标签详情" class="headerlink" title="查看标签详情"></a>查看标签详情</h3><pre><code>git show tag &lt;tag_name&gt;
</code></pre>
<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><pre><code>git tag -d &lt;tag_name&gt;
</code></pre>
<h3 id="将标签推送至远程"><a href="#将标签推送至远程" class="headerlink" title="将标签推送至远程"></a>将标签推送至远程</h3><pre><code>git push origin &lt;tag_name&gt; 
</code></pre>
<p>使用<code>git push origin --tags</code> 推送所有标签到远程</p>
<h3 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h3><p>删除远程标签需要先删除本地的标签，然后输入下面命令</p>
<pre><code>git push origin :refs/tags/&lt;tagname&gt;
</code></pre>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Spring MVC 数据类型绑定</title>
    <url>/2015/04/14/springmvc-data-binding/</url>
    <content><![CDATA[<p>今天遇到一个问题，使用Spring MVC 从页面传递一个用户<code>List</code>到Controller，然后再后台解析List得到多个用户对象，在网上搜了很多答案感觉都不行,<br>后来调试代码发现，最<code>关键</code>在于:List需要绑定在对象(ActionForm),直接写在request-mapping函数的参数是不行的,更重要的一点是要创建对象(ArrayList)。</p>
<p>之前的<code>Jsp</code>代码是这么写的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;insertInsureUser.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>开始时间:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.startTime&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>产品代码:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.productCode&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>投保人信息<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>姓名:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[0].startTime&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>身份证号:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[0].idCard&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[0].sex&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>地址:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[0].address&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>邮箱:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[0].email&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>电话号码:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[0].phone&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>被保人信息<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>姓名:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[1].startTime&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>身份证号:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[1].idCard&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[1].sex&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>地址:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[1].address&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>邮箱:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[1].email&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>电话号码:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureObject.insureUser[1].phone&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>controller代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/insertInsureUser.do&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">queryAppUserGroup</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">			HttpServletResponse response, ModelMap model,</span></span><br><span class="line"><span class="params">			<span class="meta">@ModelAttribute(&quot;insureObject&quot;)</span> InsureUserQueryObject insureObject)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			logger.info(<span class="string">&quot;=======List类型数据绑定======&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(insureObject!=<span class="literal">null</span>&amp;&amp;insureObject.getInsureUsers.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span>(InsureUser insureUser:insureObject)&#123;</span><br><span class="line">					System.out.println(insureUser.getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>网上很多人都给不出答案,关键在于,List需要绑定在对象(ActionForm),直接写在request-mapping函数的参数是不行的,更重要的一点是要创建对象(ArrayList).<br>实体<code>InsureUserQueryObject</code>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsureUserQueryObject</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> String startTime;<span class="comment">//起始时间</span></span><br><span class="line">     <span class="keyword">private</span> String productCode;<span class="comment">//产品代码</span></span><br><span class="line">     <span class="keyword">private</span> List&lt;InsureUser&gt; insureUsers;<span class="comment">//投保人被保人</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getStartTime</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> startTime;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStartTime</span><span class="params">(String startTime)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.startTime = startTime;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getProductCode</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> productCode;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductCode</span><span class="params">(String productCode)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.productCode = productCode;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> List&lt;InsureUser&gt; <span class="title function_">getInsureUsers</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> insureUsers;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInsureUsers</span><span class="params">(List&lt;InsureUser&gt; insureUsers)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.insureUsers = insureUsers;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List中要用到的InsureUser代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsureUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String idCard;<span class="comment">//身份证号</span></span><br><span class="line">    <span class="keyword">private</span> String sex;<span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">private</span> String address;<span class="comment">//地址</span></span><br><span class="line">    <span class="keyword">private</span> String email;<span class="comment">//邮箱</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//电话号码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIdCard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIdCard</span><span class="params">(String idCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.idCard = idCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后来发现，控制台报属性不存在异常，查资料后发现，Spring MVC 数据绑定和struts是不一样的，o(╯□╰)o，表单前面不需要添加实体对象<br><code>insureObject</code>,把insureObject删除掉更改过后的jsp代码为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;insertInsureUser.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>开始时间:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;startTime&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>产品代码:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;productCode&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>投保人信息<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>姓名:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[0].startTime&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>身份证号:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[0].idCard&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[0].sex&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>地址:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[0].address&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>邮箱:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[0].email&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>电话号码:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[0].phone&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>被保人信息<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>姓名:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[1].startTime&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>身份证号:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[1].idCard&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[1].sex&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>地址:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[1].address&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>邮箱:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[1].email&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_left&quot;</span>&gt;</span>电话号码:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form_right&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;insureUser[1].phone&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是发现更改过后还是有异常，数组越界异常啊摔，原来是页面在向InsureUserQueryObject的对象写数据时发现List列表是空的，于是在<br>InsureUserQueryObject中给List赋一个<code>ArrayList</code>的初值，添加一个默认构造函数，在构造函数中向列表中添加一个两个InsureUser用来存储页面传过<br>来的InsureUser对象 大功告成！！修改过后的<code>InsureUserQueryObject</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsureUserQueryObject</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> String startTime;<span class="comment">//起始时间</span></span><br><span class="line">       <span class="keyword">private</span> String productCode;<span class="comment">//产品代码</span></span><br><span class="line">       <span class="keyword">private</span> List&lt;InsureUser&gt; insureUsers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;InsureUser&gt;();<span class="comment">//投保人被保人</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">InsureUserQueryObject</span><span class="params">()</span> &#123;</span><br><span class="line">InsureUser user1=<span class="keyword">new</span> <span class="title class_">InsureUser</span>();</span><br><span class="line">InsureUser user2=<span class="keyword">new</span> <span class="title class_">InsureUser</span>();</span><br><span class="line">insureUsers.add(user1);<span class="comment">//添加投保人</span></span><br><span class="line">insureUsers.add(user2);<span class="comment">//添加被保人</span></span><br><span class="line"> &#125;</span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">getStartTime</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> startTime;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStartTime</span><span class="params">(String startTime)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.startTime = startTime;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">getProductCode</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> productCode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProductCode</span><span class="params">(String productCode)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.productCode = productCode;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> List&lt;InsureUser&gt; <span class="title function_">getInsureUsers</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> insureUsers;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInsureUsers</span><span class="params">(List&lt;InsureUser&gt; insureUsers)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.insureUsers = insureUsers;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>java/spring</tag>
      </tags>
  </entry>
  <entry>
    <title>微信OAuth2.0鉴权获取用户信息</title>
    <url>/2015/04/22/wechat-get-userinfo/</url>
    <content><![CDATA[<p>在微信开发中经常需要在网页中获取用户的基本信息，和<code>UnionID机制</code>获取用户信息的方式不同,这种方式可以得到<code>未关注</code>本微信号的人的基本信息。</p>
<h3 id="首先第一步要在微信公众平台上配置回调域名，注意"><a href="#首先第一步要在微信公众平台上配置回调域名，注意" class="headerlink" title="首先第一步要在微信公众平台上配置回调域名，注意"></a>首先第一步要在微信公众平台上配置<code>回调域名</code>，注意</h3><pre><code>域名不是URL，不要包涵http://等协议头	
</code></pre>
<h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="1-用户同意授权，获取code"><a href="#1-用户同意授权，获取code" class="headerlink" title="1.用户同意授权，获取code"></a>1.用户同意授权，获取code</h3><p>在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），<br>引导关注者打开如下页面：</p>
<pre><code>https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect
</code></pre>
<p><strong>redirect_uri</strong>是授权后重定向的回调链接地址，请使用urlencode对链接进行处理<br><strong>response_type</strong>是返回类型，请填写code<br><strong>scope</strong>是应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且，即使在未关注的情况下，只要用户授权，也能获取其信息）<br><strong>state</strong>否重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节<br><strong>wechat_redirect</strong>无论直接打开还是做页面302重定向时候，必须带此参数</p>
<p><strong>用户同意授权后</strong><br>如果用户同意授权，页面将跳转至 <code>redirect_uri/?code=CODE&amp;state=STATE</code>。若用户禁止授权，则重定向后不会带上code参数，仅会带上state参数redirect_uri?state&#x3D;STATE</p>
<pre><code>code说明 ：
code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，`5分钟`未被使用自动过期。
</code></pre>
<p>拼接授权连接Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMenuOauthUrl</span><span class="params">(String appId,String url,String state)</span>&#123;</span><br><span class="line">	String authUrl=<span class="string">&quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot;</span>+appId+<span class="string">&quot;&amp;redirect_uri=&quot;</span>+url+<span class="string">&quot;&amp;response_type=code&amp;scope=snsapi_base&amp;state=&quot;</span>+state+<span class="string">&quot;#wechat_redirect&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> authUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>snsapi_base可以改为snsapi_userinfo可以得到用户所有的信息，否则只能获得openId</p>
<span id="more"></span>
<h3 id="2-通过code换取网页授权access-token"><a href="#2-通过code换取网页授权access-token" class="headerlink" title="2.通过code换取网页授权access_token"></a>2.通过code换取网页授权access_token</h3><p>首先请注意，这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。<br>公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，<br>snsapi_base式的网页授权流程即到此为止。</p>
<p>请求方法</p>
<p>获取code后，请求以下链接获取access_token： </p>
<pre><code>https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code
</code></pre>
<p><strong>code</strong>填写第一步获取的code参数<br><strong>grant_type</strong>填写为authorization_code<br>得到AccessToken代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title function_">getCodeAccessToken</span><span class="params">(String appid, String secret, String code)</span>&#123;</span><br><span class="line">       Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isBlank(appid) || StringUtils.isBlank(secret) || StringUtils.isBlank(code)) &#123;</span><br><span class="line">           <span class="keyword">return</span> map;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;</span>);</span><br><span class="line">       sb.append(<span class="string">&quot;?appid=&quot;</span>).append(appid).append(<span class="string">&quot;&amp;secret=&quot;</span>).append(secret);</span><br><span class="line">       sb.append(<span class="string">&quot;&amp;code=&quot;</span>+code).append(<span class="string">&quot;&amp;grant_type=authorization_code&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> HttpClientUtil.getRequest(sb.toString(), <span class="string">&quot;&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">       logger.info(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isNotEmpty(result)) &#123;</span><br><span class="line">           <span class="type">JSONObject</span> <span class="variable">jo</span> <span class="operator">=</span> JSON.parseObject(result);</span><br><span class="line">           <span class="type">String</span> <span class="variable">errcode</span> <span class="operator">=</span> jo.getString(<span class="string">&quot;errcode&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">errmsg</span> <span class="operator">=</span> jo.getString(<span class="string">&quot;errmsg&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isNotEmpty(errcode)) &#123;</span><br><span class="line">               <span class="comment">//出错了</span></span><br><span class="line">               logger.info(<span class="string">&quot;clll wx error,errcode=&quot;</span> + errcode + <span class="string">&quot;, errmsg=&quot;</span> + errmsg);</span><br><span class="line">               map.put(<span class="string">&quot;errcode&quot;</span>, errcode);</span><br><span class="line">               map.put(<span class="string">&quot;errmsg&quot;</span>,errmsg);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">access_token</span> <span class="operator">=</span> jo.getString(<span class="string">&quot;access_token&quot;</span>);<span class="comment">//访问凭证</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">expires_in</span> <span class="operator">=</span> jo.getString(<span class="string">&quot;expires_in&quot;</span>);<span class="comment">//凭证有效时间</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">refresh_token</span> <span class="operator">=</span> jo.getString(<span class="string">&quot;refresh_token&quot;</span>);<span class="comment">//用户刷新access_token</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> jo.getString(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">               <span class="type">String</span> <span class="variable">scope</span> <span class="operator">=</span> jo.getString(<span class="string">&quot;scope&quot;</span>); </span><br><span class="line">               map.put(<span class="string">&quot;access_token&quot;</span>,access_token);</span><br><span class="line">               map.put(<span class="string">&quot;expires_in&quot;</span>,expires_in);</span><br><span class="line">               map.put(<span class="string">&quot;refresh_token&quot;</span>,refresh_token);</span><br><span class="line">               map.put(<span class="string">&quot;openid&quot;</span>,openid);</span><br><span class="line">               map.put(<span class="string">&quot;scope&quot;</span>,scope);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果Scope为基本信息的话，那么本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取openId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getOpenId</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">appid</span> <span class="operator">=</span> PropertiesLoader.getPropertiesByName(<span class="string">&quot;appId&quot;</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">appSerect</span> <span class="operator">=</span> PropertiesLoader.getPropertiesByName(<span class="string">&quot;secret&quot;</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="built_in">this</span>.getParameter(request, <span class="string">&quot;code&quot;</span>);</span><br><span class="line">	Map&lt;String, String&gt; map = AccessTokenUtil.getCodeAccessToken(appid,</span><br><span class="line">			appSerect, code);</span><br><span class="line">	<span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> map.get(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> <span class="built_in">this</span>.getParameter(request, <span class="string">&quot;state&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> openid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-拉取用户信息-需scope为-snsapi-userinfo"><a href="#3-拉取用户信息-需scope为-snsapi-userinfo" class="headerlink" title="3.拉取用户信息(需scope为 snsapi_userinfo)"></a>3.拉取用户信息(需scope为 snsapi_userinfo)</h3><p>如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息<br>请求方法<br>http：GET（请使用https协议）</p>
<pre><code>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN
</code></pre>
<p>得到微信返回的报文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBaseUserInfoAPI</span><span class="params">(String accessToken, String openId)</span>&#123;</span><br><span class="line">		logger.info(<span class="string">&quot;进入获取用户信息(snsapi_base)API方法&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">reqUrl</span> <span class="operator">=</span> WeiXinUrlUtil.getBaseUserInfoUrl(accessToken, openId);</span><br><span class="line">		<span class="type">String</span> <span class="variable">resDoc</span> <span class="operator">=</span> HttpClientUtil.getRequestHandler(reqUrl, <span class="string">&quot;&quot;</span>, <span class="string">&quot;获取用户信息&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> resDoc;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>将报文转换为自己需要的Object即可</p>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>Xpath语法学习</title>
    <url>/2015/08/11/xml-xpath-learning/</url>
    <content><![CDATA[<p>最近写爬虫时，需要解析<code>html</code>，有好多种选择xml文档节点的方法，先熟悉一下使用<code>xpath</code>来选取节点、解析节点</p>
<p>下面是学习需要的<code>XML文档</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;eng&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h3><p><code>XPath</code>使用路径表达式在<code>XML</code>文档中选取节点。节点是通过沿着路径或者<code>step</code>来选取的。</p>
<p>最有用的路径表达式如下：</p>
<p><code>nodename</code>	选取此节点的所有子节点。<br><code>/</code>		从根节点选取。<br><code>//</code>		从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。<br><code>.</code>		选取当前节点。<br><code>..</code>		选取当前节点的父节点。<br><code>@</code>		选取属性。<br>####实例<br>    bookstore	选取 bookstore 元素的所有子节点。<br>    &#x2F;bookstore	选取根元素 bookstore。</p>
<p><strong>注意</strong>：假如路径起始于正斜杠( &#x2F; )，则此路径始终代表到某元素的<code>绝对路径</code>！</p>
<pre><code>bookstore/book	选取属于 bookstore 的子元素的所有 book 元素。
//book	选取所有 book 子元素，而不管它们在文档中的位置。
bookstore//book	选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。
//@lang	选取名为 lang 的所有属性。
</code></pre>
<span id="more"></span>
<h3 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a>谓语（Predicates）</h3><p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。<br>谓语被嵌在<code>方括号中</code>。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>/bookstore/book[1]	选取属于 bookstore 子元素的`第一个` book 元素。
/bookstore/book[last()]	选取属于 bookstore 子元素的`最后一个` book 元素。
/bookstore/book[last()-1]	选取属于 bookstore 子元素的`倒数第二个` book 元素。
/bookstore/book[position()&lt;3]	选取`最前面的两个`属于 bookstore 元素的子元素的 book 元素。
//title[@lang]	选取`所有`拥有名为`lang的属性`的 title 元素。
//title[@lang=&#39;eng&#39;]	选取`所有` title 元素，且这些元素拥有值为 eng 的 lang 属性。
/bookstore/book[price&gt;35.00]	选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须`大于` 35.00。
/bookstore/book[price&gt;35.00]/title	选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。
</code></pre>
<h3 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h3><p>XPath 通配符可用来选取未知的 XML 元素。<br><code>*</code>	匹配任何元素节点。<br><code>@*</code>	匹配任何属性节点。<br><code>node()</code>	匹配任何类型的节点。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>/bookstore/*	选取 bookstore 元素的所有`子元素`。
//*	选取文档中的`所有元素`。
//title[@*]	选取所有带有属性的`title`元素。
</code></pre>
<h3 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a>选取若干路径</h3><p>通过在路径表达式中使用&#96;|运算符，您可以选取若干个路径。</p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><pre><code>//book/title | //book/price	选取 book 元素的所有 title 和 price 元素。
//title | //price	选取文档中的所有 title 和 price 元素。
/bookstore/book/title | //price	选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。
</code></pre>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>根据WebMagic写的一个爬取煎蛋网的小爬虫</title>
    <url>/2015/08/12/webmagic-java-jandanspider/</url>
    <content><![CDATA[<p>之前研究jsoup，想用jsoup写一个小爬虫，爬煎蛋网的<code>无聊图</code>，我也是够无聊的 &#x3D;.&#x3D;,挖了个坑过了半个月还没填上，昨天上知乎的时候，<br>发现有更加好用的爬虫框架WebMagic（知乎，果然让人发现更大的世界），先用WebMagic实现一下我的小爬虫，好啦，填坑开始…</p>
<p>这里用到<code>webmagic</code>，就把webmagic介绍，使用方法都放出来，没用过的先熟悉一下。</p>
<p>这里是<a href="https://github.com/code4craft/webmagic/tree/master/zh_docs">WebMagic中文使用文档</a>，一点即达 @.@</p>
<p>介绍文档已经很详细了，下面开始，生产爬虫</p>
<span id="more"></span>
<h2 id="分析煎蛋网无聊图html源码"><a href="#分析煎蛋网无聊图html源码" class="headerlink" title="分析煎蛋网无聊图html源码"></a>分析煎蛋网无聊图html源码</h2><p>下面是煎蛋网<code>无聊图</code>页面的html源码片段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>无聊图<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- begin comments --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;comments&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear:both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">id</span>=<span class="string">&quot;comments&quot;</span>&gt;</span>TOTAL COMMENTS: 177,359<span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">class</span>=<span class="string">&quot;plusone&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#respond&quot;</span> <span class="attr">title</span>=<span class="string">&quot;来一发&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;break&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comments&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cp-pagenavi&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;current-comment-page&quot;</span>&gt;</span>[7095]<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://jandan.net/pic/page-7094#comments&quot;</span>&gt;</span>7094<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://jandan.net/pic/page-7093#comments&quot;</span>&gt;</span>7093<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;previous-comment-page&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://jandan.net/pic/page-7094#comments&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Older Comments&quot;</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;commentlist&quot;</span> <span class="attr">style</span>=<span class="string">&quot;list-style-type: none;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;comment-2894921&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span></span></span><br><span class="line"><span class="tag">                                        <span class="attr">title</span>=<span class="string">&quot;防伪码：8d6a6ef3b33b2280a7c0803dc5cb97977799cbd2&quot;</span>&gt;</span>不发表评论<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>                            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                                  </span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;righttext&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://jandan.net/pic/page-7095#comment-2894921&quot;</span>&gt;</span>177358<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://ww3.sinaimg.cn/mw600/a801236bjw1euyksy43o7j20f20qo40d.jpg&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                                   </span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;break&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		                           </span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;comment-2894895&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">title</span>=<span class="string">&quot;防伪码：10d69593001a14fc2189787eb1a0315113ff1714&quot;</span>&gt;</span>delectate<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>                            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">small</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#footer&quot;</span> <span class="attr">title</span>=<span class="string">&quot;@回复&quot;</span></span></span><br><span class="line"><span class="tag">                                      <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;comment&#x27;).value += <span class="symbol">&amp;#39;</span>@<span class="symbol">&amp;lt;</span>a href=<span class="symbol">&amp;quot;</span>http://jandan.net/pic/page-7095#comment-2894895<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span>delectate<span class="symbol">&amp;lt;</span>/a<span class="symbol">&amp;gt;</span>: <span class="symbol">&amp;#39;</span>&quot;</span>&gt;</span>@37 mins ago<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;righttext&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://jandan.net/pic/page-7095#comment-2894895&quot;</span>&gt;</span>177352<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>老规矩，坟请猛x，谢谢。<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://ww2.sinaimg.cn/thumbnail/0066UPGbjw1euyrnitpbzg30b404gx6p.gif&quot;</span> <span class="attr">org_src</span>=<span class="string">&quot;http://ww2.sinaimg.cn/mw1024/0066UPGbjw1euyrnitpbzg30b404gx6p.gif&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;add_img_loading_mask(this, load_sina_gif);&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;break&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">	              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comments&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cp-pagenavi&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;current-comment-page&quot;</span>&gt;</span>[7095]<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://jandan.net/pic/page-7094#comments&quot;</span>&gt;</span>7094<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://jandan.net/pic/page-7093#comments&quot;</span>&gt;</span>7093<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;previous-comment-page&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://jandan.net/pic/page-7094#comments&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Older Comments&quot;</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;respond&quot;</span>&gt;</span>发表评论<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- END wrapper --&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先理一下思路</p>
<h3 id="爬取无聊图首页图片"><a href="#爬取无聊图首页图片" class="headerlink" title="爬取无聊图首页图片"></a>爬取无聊图首页图片</h3><p>想要爬的图片路径在<br>div[id&#x3D;content]-&gt;div[id&#x3D;’comments’]-&gt;ol[class&#x3D;commentlist]-&gt;li[id&#x3D;’xxxx’]-&gt;div-&gt;div[class&#x3D;’row’]-&gt;…-&gt;img[src]<br>img的<code>src链接</code>就是静态图片的<code>url</code>，如果是动态图<code>gif</code>的话，那么<code>org_src</code>才是图片的真正<code>url</code>，<code>src</code>只是对应缩略图的<code>url</code><br>让爬虫选中列表项列表li，然后遍历每个li,然后取每个li的<code>图片url</code>和<code>title</code>,</p>
<h3 id="保存图片到本地"><a href="#保存图片到本地" class="headerlink" title="保存图片到本地"></a>保存图片到本地</h3><p>用httpclient根据<code>图片url</code>下载该图片保存在本地就行了</p>
<h3 id="爬取下一页图片"><a href="#爬取下一页图片" class="headerlink" title="爬取下一页图片"></a>爬取下一页图片</h3><p>找到本页的下一页标签，从上面的源码片段可以看到是<code>class=&quot;previous-comment-page&quot;</code>的a标签<br>当爬虫爬完首页时，接下来爬<code>上一页</code>，煎蛋网是倒序的…</p>
<h2 id="开始编写爬虫"><a href="#开始编写爬虫" class="headerlink" title="开始编写爬虫"></a>开始编写爬虫</h2><h3 id="首先，新建一个解析图片的Processor类"><a href="#首先，新建一个解析图片的Processor类" class="headerlink" title="首先，新建一个解析图片的Processor类"></a>首先，新建一个解析图片的Processor类</h3><p>新建一个<code>PicProcessor</code>类，继承自<code>PageProcessor</code>，并重写<code>process</code>方法</p>
<h3 id="第一步，先处理首页图片"><a href="#第一步，先处理首页图片" class="headerlink" title="第一步，先处理首页图片"></a>第一步，先处理首页图片</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理图片类</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processPicture</span><span class="params">(Page page)</span> &#123;</span><br><span class="line">   <span class="comment">//得到所有Gif的li标签</span></span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; gifLists = page.getHtml().xpath(<span class="string">&quot;//ol[@class=&#x27;commentlist&#x27;]/li[@id]&quot;</span>).all();</span><br><span class="line">       <span class="keyword">for</span> (String gif:gifLists)&#123;</span><br><span class="line">           <span class="comment">//得到标题</span></span><br><span class="line">           String title=xpath(<span class="string">&quot;//div[@class=&#x27;author&#x27;]/strong&quot;</span>).selectElement(gif).attr(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">           logger.info(<span class="string">&quot;title:&quot;</span>+title);</span><br><span class="line">           <span class="comment">//得到上传者</span></span><br><span class="line">           String author=xpath(<span class="string">&quot;//div[@class=&#x27;author&#x27;]/strong&quot;</span>).selectElement(gif).text();</span><br><span class="line">           <span class="comment">//将标题中的防伪码转换为：上传者名称</span></span><br><span class="line">           title=title.replace(<span class="string">&quot;防伪码&quot;</span>,author);</span><br><span class="line">           <span class="comment">//图片url</span></span><br><span class="line">           <span class="comment">//如果有org_src属性，则是gif图片</span></span><br><span class="line">           String url=xpath(<span class="string">&quot;//div[@class=&#x27;text&#x27;]/p/img&quot;</span>).selectElement(gif).attr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">           String gifUrl=xpath(<span class="string">&quot;//div[@class=&#x27;text&#x27;]/p/img&quot;</span>).selectElement(gif).attr(<span class="string">&quot;org_src&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(StringUtils.isNotEmpty(gifUrl))&#123;</span><br><span class="line">               logger.info(<span class="string">&quot;Gif图片...替换新链接...&quot;</span>);</span><br><span class="line">               url=gifUrl;<span class="comment">//如果是gif则用大图链接替换缩略图链接</span></span><br><span class="line">           &#125;</span><br><span class="line">           logger.info(<span class="string">&quot;图片url:&quot;</span> + url);</span><br><span class="line">           <span class="comment">//保存图片到本地</span></span><br><span class="line">           String filePath=downloadDir+ File.separator+author;</span><br><span class="line">           String picType=url.substring(url.length()-<span class="number">3</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               FileUtil.downloadFile(url,filePath,title, picType);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>保存图片的工具类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zeusjava.jandan.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LittleXuan on 2015/8/11.</span></span><br><span class="line"><span class="comment"> * 文件操作工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(FileUtil.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     *            文件http地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     *            目标文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     *            目标文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> picType</span></span><br><span class="line"><span class="comment">     *            文件类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.io.IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">downloadFile</span><span class="params">(String url,String filePath, String fileName,String picType)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;----------------------下载文件开始---------------------&quot;</span>);</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpclient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(url)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//目标目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">desPathFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!desPathFile.exists()) &#123;</span><br><span class="line">            desPathFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到文件绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fullPath</span> <span class="operator">=</span>filePath +File.separator+fileName+<span class="string">&quot;.&quot;</span>+picType;</span><br><span class="line">        logger.info(<span class="string">&quot;文件路径：&quot;</span>+filePath);</span><br><span class="line">        logger.info(<span class="string">&quot;文件名：&quot;</span>+fileName);</span><br><span class="line">        logger.info(<span class="string">&quot;源文件url：&quot;</span>+url);</span><br><span class="line">        <span class="comment">//从元网址下载图片</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(url);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpclient.execute(httpget);</span><br><span class="line">        <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> entity.getContent();</span><br><span class="line">        <span class="comment">//设置下载地址</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fullPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((l = in.read(tmp)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fout.write(tmp,<span class="number">0</span>,l);</span><br><span class="line">            &#125;</span><br><span class="line">            fout.flush();</span><br><span class="line">            fout.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;----------------------下载文件结束---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="爬取下一页"><a href="#爬取下一页" class="headerlink" title="爬取下一页"></a>爬取下一页</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Page page)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">       <span class="comment">//定义抽取信息，并保存信息</span></span><br><span class="line">       processPicture(page);</span><br><span class="line">       <span class="comment">//得到下一页链接</span></span><br><span class="line">       String comments=page.getHtml().xpath(<span class="string">&quot;//a[@class=&#x27;previous-comment-page&#x27;]&quot;</span>).toString();</span><br><span class="line">       logger.info(<span class="string">&quot;comments:&quot;</span>+comments);</span><br><span class="line">       <span class="type">String</span> <span class="variable">link</span> <span class="operator">=</span> xpath(<span class="string">&quot;a/@href&quot;</span>).select(comments);</span><br><span class="line">       logger.info(<span class="string">&quot;link:&quot;</span> + link);</span><br><span class="line">       <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(link);</span><br><span class="line">       page.addTargetRequest(request);</span><br><span class="line">       System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h3 id="网站信息配置"><a href="#网站信息配置" class="headerlink" title="网站信息配置"></a>网站信息配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到网站配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Site</span> <span class="variable">site</span> <span class="operator">=</span> Site.me().setDomain(<span class="string">&quot;jandan.net&quot;</span>).addHeader(<span class="string">&quot;Accept&quot;</span>,</span><br><span class="line">            <span class="string">&quot;application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */*&quot;</span>)</span><br><span class="line">            .addHeader(<span class="string">&quot;Referer&quot;</span>, <span class="string">&quot;http://jandan.net/pic&quot;</span>).setSleepTime(<span class="number">10000</span>).setUserAgent(<span class="string">&quot;zhaohongxuan&quot;</span>)</span><br><span class="line">            .addStartUrl(<span class="string">&quot;http://jandan.net/pic&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里注意的是，要设置<code>UserAgent</code>，之前没加代理，刚开始启动程序可以爬，后来，煎蛋网就给屏蔽了，HttpClient返回<code>HTTP/1.1 302 Moved Temporarily</code>，煎蛋网把请求给重定向了<br>设置<code>SleepTime</code>可以设置每次爬取之间的时间间隔，我写的是<code>10000ms</code>，即程序爬完一页之后休息<code>10s</code>继续爬下一页。</p>
<h3 id="编写程序入口"><a href="#编写程序入口" class="headerlink" title="编写程序入口"></a>编写程序入口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JanDanSpiderTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(JanDanSpiderTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PropertyConfigurator.configure(ClassLoader.getSystemResourceAsStream(<span class="string">&quot;log4j.properties&quot;</span>));</span><br><span class="line">        Spider.create(<span class="keyword">new</span> <span class="title class_">PicProcessor</span>()).scheduler(<span class="keyword">new</span> <span class="title class_">PriorityScheduler</span>()).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于<code>WebMagic</code>采用的是链式编程，可以很方便的进行配置，上面我默认用的是<code>PriorityScheduler</code>，当然也可以使用多线程，使用<code>thread()</code>括号里写上Thread的数量就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Spider.create(<span class="keyword">new</span> <span class="title class_">PicProcessor</span>()).scheduler(<span class="keyword">new</span> <span class="title class_">PriorityScheduler</span>()).thread(<span class="number">10</span>).run();</span><br></pre></td></tr></table></figure>
<p>本程序源代码请戳<a href="https://github.com/zhaohongxuan/JanDanSpider/">JanDanSpider</a>…</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中使用DES对称加解密</title>
    <url>/2015/09/07/java-des-encrypt/</url>
    <content><![CDATA[<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>DES(Data Encryption Standard),即数据加密算法。是IBM公司于1975年研究成功并公开发表的。DES算法的入口参数有三个:Key、Data、Mode。<br>其中Key为8个字节共64位,是DES算法的工作密钥;Data也为8个字节64位,是要被加密或被解密的数据;Mode为DES的工作方式,有两种:加密或解密。 </p>
<h3 id="安卓端对请求Web服务器请求字符串进行加密"><a href="#安卓端对请求Web服务器请求字符串进行加密" class="headerlink" title="安卓端对请求Web服务器请求字符串进行加密"></a>安卓端对请求Web服务器请求字符串进行加密</h3><p>加密公共方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sz.kcygl.common.DESUtil;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.AlgorithmParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKeyFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.DESKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DESUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ALGORITHM_DES</span> <span class="operator">=</span> <span class="string">&quot;DES/CBC/PKCS5Padding&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES算法，加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     *            待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     *            加密私钥，长度不能够小于8位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字节数组，一般结合Base64编码使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CryptException</span></span><br><span class="line"><span class="comment">     *             异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encode</span><span class="params">(String key, String data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> encode(key, data.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES算法，加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     *            待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     *            加密私钥，长度不能够小于8位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字节数组，一般结合Base64编码使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CryptException</span></span><br><span class="line"><span class="comment">     *             异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encode</span><span class="params">(String key, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DESKeySpec</span> <span class="variable">dks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(key.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">            <span class="comment">// key的长度不能够小于8位字节</span></span><br><span class="line">            <span class="type">Key</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(dks);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(ALGORITHM_DES);</span><br><span class="line">            <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="string">&quot;12345678&quot;</span>.getBytes());</span><br><span class="line">            <span class="type">AlgorithmParameterSpec</span> <span class="variable">paramSpec</span> <span class="operator">=</span> iv;</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, secretKey, paramSpec);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] bytes = cipher.doFinal(data);</span><br><span class="line">            <span class="keyword">return</span> Base64.encode(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES算法，解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     *            待解密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     *            解密私钥，长度不能够小于8位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     *             异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(String key, <span class="type">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">            <span class="type">DESKeySpec</span> <span class="variable">dks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(key.getBytes());</span><br><span class="line">            <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>);</span><br><span class="line">            <span class="comment">// key的长度不能够小于8位字节</span></span><br><span class="line">            <span class="type">Key</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(dks);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(ALGORITHM_DES);</span><br><span class="line">            <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="string">&quot;12345678&quot;</span>.getBytes());</span><br><span class="line">            <span class="type">AlgorithmParameterSpec</span> <span class="variable">paramSpec</span> <span class="operator">=</span> iv;</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, secretKey, paramSpec);</span><br><span class="line">            <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取编码后的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decodeValue</span><span class="params">(String key, String data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] datas;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        datas = decode(key, Base64.decode(data));</span><br><span class="line"></span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">String</span>(datas);</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="java后台服务器"><a href="#java后台服务器" class="headerlink" title="java后台服务器"></a>java后台服务器</h3><p>通过一个拦截器，拦截掉所有需要拦截的路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sz.kcygl.web.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by LittleXuan on 2015/8/31.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sz.kcygl.common.DESUtil.MD5;</span><br><span class="line"><span class="keyword">import</span> com.sz.kcygl.common.DESUtil.DESUtil;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 赵宏轩</span></span><br><span class="line"><span class="comment"> * 2015-08-31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(<span class="built_in">this</span>.getClass());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在业务处理器处理请求之前被调用</span></span><br><span class="line"><span class="comment">     * 如果返回false</span></span><br><span class="line"><span class="comment">     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链</span></span><br><span class="line"><span class="comment">     * 如果返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> requestUri.substring(contextPath.length());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;requestUri:&quot;</span> + requestUri);</span><br><span class="line">        log.info(<span class="string">&quot;contextPath:&quot;</span> + contextPath);</span><br><span class="line">        log.info(<span class="string">&quot;url:&quot;</span> + url);</span><br><span class="line"></span><br><span class="line">        StringBuffer requestData=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(request.getInputStream());</span><br><span class="line">        <span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> iRead;</span><br><span class="line">        <span class="keyword">while</span>((iRead=buf.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            requestData.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,iRead,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONObject.fromObject(requestData.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestDES</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;requestMessage&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">signvalue</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;sign&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;加密后的字符串：&quot;</span>+requestDES);</span><br><span class="line">        log.info(<span class="string">&quot;MD5签名：&quot;</span>+signvalue);</span><br><span class="line"></span><br><span class="line">        String afterDES=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotEmpty(requestDES))&#123;</span><br><span class="line">            afterDES = DESUtil.decodeValue(<span class="string">&quot;tiananapp&quot;</span>, requestDES);</span><br><span class="line">            log.info(<span class="string">&quot;解密后请求：&quot;</span>+afterDES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">MD5</span> <span class="variable">md5</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">MD5</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">localSign</span> <span class="operator">=</span> md5.getMD5ofStr(<span class="string">&quot;tiananapp&quot;</span>+afterDES);</span><br><span class="line">        log.info(<span class="string">&quot;本地MD5签名：&quot;</span>+localSign);</span><br><span class="line">        <span class="keyword">if</span>(signvalue!=<span class="literal">null</span>&amp;&amp;signvalue.equalsIgnoreCase(localSign))&#123;</span><br><span class="line">            request.setAttribute(<span class="string">&quot;requestMessage&quot;</span>,afterDES); <span class="comment">//将解密后的请求参数还原</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在Spring-MVC-配置文件添加拦截器配置"><a href="#在Spring-MVC-配置文件添加拦截器配置" class="headerlink" title="在Spring MVC 配置文件添加拦截器配置"></a>在Spring MVC 配置文件添加拦截器配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 匹配的是url路径， 如果不配置或/**,将拦截所有的Controller --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/front/**&quot;</span>/&gt;</span><span class="comment">&lt;!-- 匹配的是不需要拦截的url路径&gt;</span></span><br><span class="line"><span class="comment">			&lt;bean class=&quot;com.sz.kcygl.web.interceptor.SignInterceptor&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">		&lt;/mvc:interceptor&gt;</span></span><br><span class="line"><span class="comment">	&lt;/mvc:interceptors&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js学习笔记（一）</title>
    <url>/2015/09/09/learn-vue-js/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vue.js 是一个用于创建 web 交互界面的库。</p>
<p>从技术角度讲，<code>Vue.js</code>专注于<code>MVVM</code>模型的<code>ViewModel</code>层。它通过双向数据绑定把<code>View</code>层和 Model 层连接了起来。实际的<code>DOM</code>封装和输出格式都被抽象为了<code>Directives</code>和<code>Filters</code>。</p>
<p>从哲学角度讲，Vue 希望通过一个尽量简单的 API 来提供响应式的数据绑定和可组合、复用的视图组件。它不是一个大而全的框架——它只是一个简单灵活的视图层。您可以独立使用它快速开发原型、也可以混合别的库做更多的事情。它同时和诸如 Firebase 这一类的 BaaS 服务有着天然的契合度。</p>
<p>Vue.js 的 API 设计深受<code>AngularJS、KnockoutJS、Ractive.js</code> 和 <code>Rivets.js</code> 的影响。尽管有不少相似之处，但我们相信 Vue.js 能够在简约和功能之间的微妙平衡中体现出其独有的价值。</p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel在vue.js中同步Model和View的对象，在vue.js中，每个vue.js实例都是一个ViewModel它们是通过构造函数 <code>Vue</code>或者其子类被创建出来的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm =<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h3><p>View是被Vue实例管理的DOM节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.<span class="property">$el</span></span><br></pre></td></tr></table></figure>
<p>Vue.js 使用基于 DOM 的模板。每个 Vue 实例都关联着一个相应的 DOM 元素。当一个 Vue 实例被创建时，它会递归遍历根元素的所有子结点，同时完成必要的数据绑定。当这个视图被编译之后，它就会自动响应数据的变化。</p>
<p>当数据发生变化时，视图将会自动触发更新。这些更新的粒度精确到一个文字节点。同时为了更好的性能，这些更新是批量异步执行的。</p>
<span id="more"></span>

<h3 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型(Model)"></a>模型(Model)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.<span class="property">$data</span></span><br></pre></td></tr></table></figure>
<p>Vue.js中的模型就是普通的javascript对象。一旦某对象被作为 Vue 实例中的数据，它就成为一个 “响应式” 的对象了。你可以操作它们的属性，同时正在观察它的 Vue 实例也会收到提示。</p>
<h3 id="指令-Directives"><a href="#指令-Directives" class="headerlink" title="指令(Directives)"></a>指令(Directives)</h3><p>Vue.js的指令是带有特殊前缀<code>v-</code>的HTML特性，可以让Vue.js对DOM做各种处理。</p>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span> =<span class="string">&#x27;name&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的前缀是默认的 <code>v-</code>。指令的<code>ID</code> 是 <code>text</code>，表达式是 <code>name</code>。这个指令告诉 Vue.js， 当 Vue 实例的 <code>name</code> 属性改变时，更新该 <code>div</code> 元素的 <code>textContent</code>。<br>Directives 可以封装任何 DOM 操作。比如<code>v-attr</code> 会操作一个元素的特性；<code>v-repeat</code> 会基于数组来复制一个元素；<code>v-on</code> 会绑定事件等</p>
<h4 id="内联表达式"><a href="#内联表达式" class="headerlink" title="内联表达式"></a>内联表达式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">&quot;&#x27;hello &#x27; + user.firstName + &#x27; &#x27; + user.lastName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用了一个计算表达式 (computed expression)，而不仅仅是简单的属性名。Vue.js 会自动跟踪表达式中依赖的属性并在这些依赖发生变化的时候触发指令更新。<br>同时，因为有异步批处理更新机制，哪怕多个依赖同时变化，表达式也只会触发一次。<br>需要注意的是Vue.js 把内联表达式限制为一条语句。如果需要绑定更复杂的操作，可以使用<code>计算属性</code>。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on</span>=<span class="string">&quot;click : clickHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有些指令需要在路径或表达式前加一个参数。在这个例子中<code>click</code>参数代表了我们希望<code>v-on</code> 指令监听到点击事件之后调用该 <code>ViewModel</code> 实例的 <code>clickHandler</code> 方法。</p>
<h4 id="多重指令从句"><a href="#多重指令从句" class="headerlink" title="多重指令从句"></a>多重指令从句</h4><p>你可以在同一个特性里多次绑定同一个指令。这些绑定用逗号分隔，它们在底层被分解为多个指令实例进行绑定。</p>
<div v-on="
  click   : onClick,
  keyup   : onKeyup,
  keydown : onKeydown
">
</div>
#### 字面量指令

<p>有些指令不会创建数据绑定——它们的值只是一个字符串字面量。比如 v-ref 指令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-ref</span>=<span class="string">&quot;some-string-id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>some-string-id</code> 并不是一个响应式的表达式 — <code>Vue.js</code>不会尝试去观测组件中的对应数据。</p>
<p>在有些情况下，你也可以使用 <code>Mustache</code> 风格绑定来使得字面量指令 <code>反应化</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;showMsg&quot;</span> <span class="attr">v-transition</span>=<span class="string">&quot;&#123;&#123;dynamicTransitionId&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，请注意只有<code>v-transition</code> 指令具有此特性。<code>Mustache</code>表达式在其他字面量指令中，例如 <code>v-ref</code> 和 <code>v-el</code>，只会被计算一次。它们在编译完成后将不会再响应数据的变化。</p>
<h3 id="Mustache-风格绑定"><a href="#Mustache-风格绑定" class="headerlink" title="Mustache 风格绑定"></a>Mustache 风格绑定</h3><p>你也可以使用 mustache 风格的绑定，不管在文本中还是在属性中。它们在底层会被转换成 v-text 和 v-attr 的指令。比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;person-&#123;&#123;id&#125;&#125;&quot;</span>&gt;</span>Hello &#123;&#123;name&#125;&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤器-filter"><a href="#过滤器-filter" class="headerlink" title="过滤器(filter)"></a>过滤器(filter)</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>过滤器是用于在更新视图之前处理原始值的函数,它们通过一个“管道”在指令或绑定中进行处理：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;message | capitalize&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样在 div 的文本内容被更新之前，message 的值会先传给 capitalizie 函数处理。</p>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>一些过滤器是可以接受参数的。参数用空格分隔开：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;order | pluralize &#x27;st&#x27; &#x27;nd&#x27; &#x27;rd&#x27; &#x27;th&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on</span>=<span class="string">&quot;keyup: submitForm | key &#x27;enter&#x27;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>Coding/javascript/Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 整合Spring</title>
    <url>/2015/09/11/redis-java-spring/</url>
    <content><![CDATA[<p>Redis是一种性能非常高效的Key-Value数据库，在企业项目开发中应用广泛，因为一直用Spring，所以决定使用Spring支持的<code>spring-data-redis</code>,java中Redis有多种客户端，Spring推荐的是<br><code>Jedis</code>，这篇文章就是基于Jedis的。</p>
<h2 id="SDR-Spring-Data-Redis-简介"><a href="#SDR-Spring-Data-Redis-简介" class="headerlink" title="SDR(Spring Data Redis)简介"></a>SDR(Spring Data Redis)简介</h2><p>**SDR(Spring Data Redis)**支持低层次的通过连接器<code>connector</code>连接到<code>Redis</code>，支持高层次的友好的模板类<code>RedisTemplate</code>,RedisTemplate是建立在低级别的connection基础之上。<code>RedisConnection</code>接收或返回字节数组<br>需要自身处理连接，比如关闭连接，而RedisTemplate负责处理串行化和反串行化，并且管理对连接进行管理。<br><code>RedisTemplate</code>提供操作视图，比如(Bound)ValueOperations,(Bound)ListOperations,(Bound)SetOperations,(Bound)ZSetOperations,(Bound)HashOperations。RedisTemplate是线程安全的，能够用于多个实例中。<br><code>RedisTemplate</code>默认选择<code>java-based</code>串行化,也可以切换为其它的串行化方式，或者设置<code>enabledDefaultSerializer</code>为<code>false</code>或者设置串行化器为null，则<code>RedisTemplate</code>用<code>raw byte arrays</code>表示数据。<br>SDR连接到<code>redis</code>通过<code>RedisConnectionFactory</code>来获得有效的<code>RedisConnection</code>。<code>RedisConnection</code>负责建立和处理和redis后端通信。<code>RedisConnection</code>提供<code>getNativeconnection</code>返回用来通信的底层<code>connection</code>。</p>
<h2 id="Maven的pom-xml文件配置"><a href="#Maven的pom-xml文件配置" class="headerlink" title="Maven的pom.xml文件配置"></a>Maven的pom.xml文件配置</h2><p>在<code>dependencies</code>中添加两个依赖，分别是<code>spring-data-redis</code>和<code>jedis</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="Properties文件中配置Redis的基本参数"><a href="#Properties文件中配置Redis的基本参数" class="headerlink" title="Properties文件中配置Redis的基本参数"></a>Properties文件中配置Redis的基本参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Redis config</span><br><span class="line">redis.host=localhost</span><br><span class="line">redis.port=<span class="number">6379</span></span><br><span class="line">redis.password=</span><br><span class="line">redis.maxIdle=<span class="number">300</span></span><br><span class="line">redis.maxActive=<span class="number">600</span></span><br><span class="line">redis.maxWait=<span class="number">1000</span></span><br><span class="line">redis.testOnBorrow=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="配置applicationContext-xml"><a href="#配置applicationContext-xml" class="headerlink" title="配置applicationContext.xml"></a>配置<code>applicationContext.xml</code></h2><p>在<code>applicationContext.xml</code>S中配置<code>jedisConnFactory</code>和<code>jedisTemplate</code>，加载Properties的各个属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zeusjava.osf.model&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zeusjava.osf.dao.impl&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zeusjava.osf.service&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zeusjava.osf.util&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:spring/property.properties&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisConnFactory&quot;</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">p:usePool</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">p:hostName</span>=<span class="string">&quot;$&#123;redis.host&#125;&quot;</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">p:port</span>=<span class="string">&quot;$&#123;redis.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">p:password</span>=<span class="string">&quot;$&#123;redis.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- redis template definition --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;redisTemplate&quot;</span> </span></span><br><span class="line"><span class="tag">	    <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.core.RedisTemplate&quot;</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">p:connectionFactory-ref</span>=<span class="string">&quot;jedisConnFactory&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keySerializer&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hashKeySerializer&quot;</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span>	</span><br><span class="line">	 </span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">p:dataSource-ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="在java类中使用Redis进行增删改查"><a href="#在java类中使用Redis进行增删改查" class="headerlink" title="在java类中使用Redis进行增删改查"></a>在java类中使用Redis进行增删改查</h2><p>下面是一个简单的查询的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDAO</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier(&quot;redisTemplate&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate; </span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Resource(name=&quot;redisTemplate&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> HashOperations&lt;String, String, Object&gt; mapOps;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getUserByID</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:&quot;</span>+id;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> mapOps.get(<span class="string">&quot;user&quot;</span>,key);</span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) obj;</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.js学习笔记（二）</title>
    <url>/2015/09/22/learn-vue-js-2/</url>
    <content><![CDATA[<p>继续上一篇文章，中间耽误了一个多星期，去面试和复习以前的代码，继续愉快的的vue.js学习之旅 :)…</p>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>vue.js的<code>v-repeat</code>指令用来根据相对应的ViewModel的对象数组来渲染列表。</p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>html代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-repeat</span>=<span class="string">&quot;items&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item-&#123;&#123;$index&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;$index&#125;&#125; : &#123;&#123;parentMsg&#125;&#125; &#123;&#123;childMsg&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>js代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">parentMsg</span>: <span class="string">&#x27;你好&#x27;</span>,</span><br><span class="line">    <span class="attr">items</span>: [</span><br><span class="line">      &#123; <span class="attr">childMsg</span>: <span class="string">&#x27;赵&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">childMsg</span>: <span class="string">&#x27;宏轩&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这些子实例继承父实例的数据作用域，因此在重复的模板元素中你既可以访问子实例的属性，也可以访问父实例的属性。还可以通过<code>$index</code>属性来获取当前实例对应的数组索引。</p>
<span id="more"></span>

<h3 id="块级重复"><a href="#块级重复" class="headerlink" title="块级重复"></a>块级重复</h3><p><code>&lt;template&gt;</code>标签用来重复循环一个包含多个节点的块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-repeat</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="简单值数组"><a href="#简单值数组" class="headerlink" title="简单值数组"></a>简单值数组</h3><p>简单值 (primitive value) 是字符串、数字、boolean 等并非对象的值。<br>对于包含简单值的数组，可用<code>$value</code>直接访问值:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-repeat</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;$value&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;tags&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">   <span class="attr">tags</span>:[<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;sql&#x27;</span>,<span class="string">&#x27;c++&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>如果想要访问实例对象的属性，可以通过<code>in</code>关键字来获得<code>repeat</code>对象的单个对象，有点类似于java中的<code>for-each</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-repeat</span>=<span class="string">&quot;user in users&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.email&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#users&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">users</span>: [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;赵小轩&#x27;</span>, <span class="attr">email</span>: <span class="string">&#x27;hongxuanzhao@gmail.com&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;窦小娜&#x27;</span>, <span class="attr">email</span>: <span class="string">&#x27;xiaonadou@gmail.com&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><p>使用使用<code>v-repeat</code>遍历一个对象的所有属性，每个重复的实例会有一个特殊的属性<code>$key</code>。<br>对于简单值，你也可以象访问数组中的简单值那样使用<code>$value</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;repeat-object&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-repeat</span>=<span class="string">&quot;primitiveValues&quot;</span>&gt;</span>&#123;&#123;$key&#125;&#125; : &#123;&#123;$value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>===<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-repeat</span>=<span class="string">&quot;objectValues&quot;</span>&gt;</span>&#123;&#123;$key&#125;&#125; : &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#repeat-object&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">primitiveValues</span>: &#123;</span><br><span class="line">      <span class="title class_">FirstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">      <span class="title class_">LastName</span>: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">      <span class="title class_">Age</span>: <span class="number">30</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">objectValues</span>: &#123;</span><br><span class="line">      <span class="attr">one</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">two</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;Bye&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="迭代值域"><a href="#迭代值域" class="headerlink" title="迭代值域"></a>迭代值域</h3><p><code>v-repeat</code>可以接收一个整数，然后重复显示模版多次</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;range&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-repeat</span>=<span class="string">&quot;val&quot;</span>&gt;</span>Hi! &#123;&#123;$index&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#range&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="数组过滤器"><a href="#数组过滤器" class="headerlink" title="数组过滤器"></a>数组过滤器</h3><p>Vue有两个内置的过滤器来过滤或者排序数据，分别是：<code>filterBy</code>和<code>orderBy</code>。</p>
<h4 id="filterBy"><a href="#filterBy" class="headerlink" title="filterBy"></a>filterBy</h4><p>语法：</p>
<pre><code>filterBy searchKey [in dataKey...]
</code></pre>
<p>返回原数组过滤后的结果。<code>searchKey</code> 参数是当前<code>ViewModel</code> 的一个属性名，这个属性的值会被用作查找的目标。<br><code>in</code>关键字指定具体要在哪个属性中进行查找。<br>用法：</p>
<h5 id="1-不使用in关键字"><a href="#1-不使用in关键字" class="headerlink" title="1.不使用in关键字"></a>1.不使用<code>in</code>关键字</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-repeat</span>=<span class="string">&quot;users | filterBy searchText&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个过滤器会遍历整个users数组每个元素的<strong>每个</strong>属性值来匹配<code>searchText</code>的内容<br>比如如果一个元素为<code>&#123;name:&#39;赵宏轩&#39;,tel:&#39;021-111111&#39;&#125;</code>,<code>searchText</code>的值为<code>021</code>,那么这条数据就是合法的数据，不会被过滤器过滤掉。</p>
<h5 id="2-使用in关键字"><a href="#2-使用in关键字" class="headerlink" title="2.使用in关键字"></a>2.使用<code>in</code>关键字</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-repeat</span>=<span class="string">&quot;user in users | filterBy searchText in &#x27;name&#x27;&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和上一个例子数据一样，但是如果<code>searchText</code>的值还是<code>021</code>的话，那么这条数据就会被过滤掉。因为过滤的内容限定在 <code>name</code>属性中，如果<br><code>searchText</code>的值为<code>赵</code>的话，这个元素就不会被过滤掉。</p>
<h4 id="OrderBy"><a href="#OrderBy" class="headerlink" title="OrderBy"></a>OrderBy</h4><pre><code>语法： orderBy sortKey [reverseKey].
</code></pre>
<p><code>orderBy</code>用于返回原数组排序后的结果。<br><code>sortKey</code>参数是当前<code>ViewModel</code>的一个属性名。这个属性的值表示用来排序的键名.<br><code>reverseKey</code>参数也是当前<code>ViewModel</code>的一个属性名，如果这个属性值为真则数组会被倒序排列。<br>可以使用引号来表示字面量的排序键名。使用 -1 来表示字面量的 reverse 参数。</p>
<pre><code>语法： orderBy sortKey [reverseKey].
</code></pre>
<p>用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-repeat</span>=<span class="string">&quot;user in users | orderBy field reverse&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">field</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">reverse</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>Coding/javascript/Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK动态代理和cglib动态代理</title>
    <url>/2015/10/13/jdk-dynamic-agent-and-cglib/</url>
    <content><![CDATA[<p>一晃眼，国庆节已经过去了，时间到了10月中旬了，总是感觉时间不够用，想多看点书，多写点代码，在点滴中积淀属于自己的知识系统。</p>
<p>闲言少叙，先来说一下什么是代理模式，我们去一个新的地方总是要先找地方住，但是我们人生地不熟的掌握的资源不多，这时候一般会找中介，中介对房源很熟悉，很快就能为你找到合适的房子，这时候，<code>中介</code>就是一个<code>代理</code>,你就相当于是一个<code>委托</code>方。</p>
<p>下面是设计模式中的代理：</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是常用的java设计模式，他的特征是<code>代理类</code>与<code>委托类</code>有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息<code>转发</code>给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用<code>委托类</code>的对象的相关方法，来提供特定的服务。 </p>
<p>按照代理的创建时期，代理类可以分为两种：</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><pre><code>由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 
</code></pre>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><pre><code>在程序运行时，运用反射机制动态创建而成。 动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。java.lang.reflect 包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。 
</code></pre>
<p>动态代理有很多种，先看第一种，JDK动态代理</p>
<span id="more"></span>

<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>先来看下JDK源码中InvocationHandler中invoke()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>

<p>JDK源码中Proxy类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*     </span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass(loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; h &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><pre><code>ClassLoader loader：类加载器 
Class&lt;?&gt;[] interfaces：得到全部的接口 
InvocationHandler h：得到InvocationHandler接口的子类实例 
</code></pre>
<h4 id="PS-类加载器"><a href="#PS-类加载器" class="headerlink" title="PS:类加载器"></a>PS:类加载器</h4><p>在Proxy类中的newProxyInstance（）方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，<br>在Java中主要有一下三种类加载器:</p>
<pre><code>Booststrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的； 
Extendsion ClassLoader：用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类; 
AppClassLoader：(默认)加载classpath指定的类，是最常使用的是一种加载器。
</code></pre>
<h2 id="JDK动态代理实现步骤"><a href="#JDK动态代理实现步骤" class="headerlink" title="JDK动态代理实现步骤"></a>JDK动态代理实现步骤</h2><h3 id="实现InvocationHandler接口"><a href="#实现InvocationHandler接口" class="headerlink" title="实现InvocationHandler接口"></a>实现InvocationHandler接口</h3><h3 id="获得代理对象"><a href="#获得代理对象" class="headerlink" title="获得代理对象"></a>获得代理对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;jdk 动态代理 begin...&quot;</span>);</span><br><span class="line">    result = method.invoke(target,args);</span><br><span class="line">    System.out.println(<span class="string">&quot;jdk 动态代理 end...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK动态代理缺点：</p>
<pre><code>只能对实现了接口的类进行，没有实现接口的类不能使用JDK动态代理。
</code></pre>
<h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><p>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的<code>目标类</code>生成一个<code>子类</code>，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对<code>final修饰</code>的类进行代理。<br>cglib实现动态代理的方法和JDK动态代理类似</p>
<h3 id="实现MethodInterceptor接口"><a href="#实现MethodInterceptor接口" class="headerlink" title="实现MethodInterceptor接口"></a>实现MethodInterceptor接口</h3><h3 id="获得代理对象-1"><a href="#获得代理对象-1" class="headerlink" title="获得代理对象"></a>获得代理对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    enhancer.setSuperclass(<span class="built_in">this</span>.target.getClass());</span><br><span class="line">    <span class="comment">//设置回调方法</span></span><br><span class="line">    enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置回调方法"><a href="#设置回调方法" class="headerlink" title="设置回调方法"></a>设置回调方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;UserFacadeProxy.intercept begin&quot;</span>);</span><br><span class="line">    methodProxy.invokeSuper(o,objects);</span><br><span class="line">    System.out.println(<span class="string">&quot;UserFacadeProxy.intercept end&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h2><p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。<br>SpringAOP动态代理策略是：</p>
<pre><code>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 
3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>cglib</tag>
      </tags>
  </entry>
  <entry>
    <title>Executor任务执行框架的应用</title>
    <url>/2015/11/09/java-concurrent-executor-and-countdownlatch/</url>
    <content><![CDATA[<p>最近一段时间没有写东西了，看大名鼎鼎的<code>Brian Goetz</code>写的<code>Java Concurrency in Practice</code>时候，看到任务执行框架<code>Executor Framework</code><br>的时候，觉得纸上得来终觉浅，索性写点东西加深一下印象。</p>
<p>在JDK1.5中，Java平台中增加了一个并发包<code>java.util.concurrent</code>，这个包中包含了Executor Framework，而且还包含了很多并发包，比如并发<br>HashMap<code>ConcurrentHashMap</code>、阻塞队列<code>BlockQueue</code>、栅栏的实现<code>CyclicBarrier</code>、信号量<code>Semaphore</code>、异步任务<code>FutureTask</code>等等。<br>在处理多线程任务的时候，使用Executor和task要<code>优于</code>使用线程,这也不是我说的，是Effect Java的作者 <code>Joshua Bloach</code>说的，下面来阐述一下<br>为什么。</p>
<h2 id="并发任务执行"><a href="#并发任务执行" class="headerlink" title="并发任务执行"></a>并发任务执行</h2><p>当要执行一个并发任务的时候，通常有两种方式，一种是<code>串行</code>的处理方式，一种是<code>并行</code>的处理,显然，串行的方式只能一次处理一个任务，当程序在执行<br>当前的任务的时候，就说明接下来到来的任务请求都要等待当前的任务执行完毕才能获得CPU去执行任务，这种方式虽然不会犯错，但是效率太低。<br>那么，如果每一个任务到来都分配一个新的任务呢，这种方式貌似很好，<code>但是</code>：</p>
<p>如果任务请求量非常大的时候会出现一定的问题，因为它没有限制可以创建的线程的<code>数量</code>.</p>
<h3 id="线程生命周期的开销很高"><a href="#线程生命周期的开销很高" class="headerlink" title="线程生命周期的开销很高"></a>线程生命周期的开销很高</h3><p>  线程的创建和销毁不是没有代价的,根据平台的不同，开销不同，但是不要忘记，线程的创建是需要时间的。</p>
<h3 id="活跃的线程会消耗系统资源"><a href="#活跃的线程会消耗系统资源" class="headerlink" title="活跃的线程会消耗系统资源"></a>活跃的线程会消耗系统资源</h3><p>  活跃的线程很消耗系统资源，尤其是内存，如果可运行的线程数量多于处理器核心数，那么多余的线程将闲置，但是闲置的线程仍然是消耗系统资源的，尤其<br>  是内存，给GC回收垃圾带来压力，而且线程间在进行竞争的时候也会消耗大量的资源</p>
<h3 id="平台可创建的线程数量是有限的"><a href="#平台可创建的线程数量是有限的" class="headerlink" title="平台可创建的线程数量是有限的"></a>平台可创建的线程数量是有限的</h3><p>  也就是说，如果创建的线程超出了平台的限制那么，JVM就可能抛出<code>OutofMemoryError</code>的异常</p>
<span id="more"></span>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>和数据库连接池相似，线程池指的是一组<code>同构</code>工作线程的资源池，线程池与工作队列 Work Queue密切相关<br>线程池中的线程的任务很简单：从<code>工作队列</code>（Work Queue）中取出一个任务，执行任务，人后返回线程池，等待执行下一个任务</p>
<p>线程池比为每一个任务分配一个线程要有更多优势，通过<code>重用</code>现有线程而不是重新创建线程，可以处理多个任务请求的时候，分摊在线程创建和销毁的过程中产生的<br>巨大开销。<br>而且，当请求到达的时候，线程池中的线程也已经就绪，不需要在创建线程而延迟响应的时间，提高了响应性。通过调整线程池的大小，可以创建足够多的线程来让CPU<br>保持忙碌的状态。</p>
<p>创建线程池有很多种方式，</p>
<p>通过调用Executors的工厂方法可以创建线程池，<br>例如：<br><code>newFixThreadPool</code> 用来创建一个固定长度的线程池<br><code>newCacheThreadPool</code> 用来创建一个可缓存的线程池<br><code>newSingleThreadPool</code> 创建一个单线程的线程池</p>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>任务和线程不同，任务是一组<code>逻辑工作单元</code>，而线程是使任务<code>异步执行</code>的机制。<br>在Java类库中，任务执行的主要抽象不是Thread而是Executor</p>
<p>Executor接口定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &lt;tt&gt;Executor&lt;/tt&gt; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然Executor只是一个简单的接口，但是却为灵活而强大的异步任务执行框架提供了基础。其中Runnable表示可以执行的任务<br>Executor的实现还提供了对生命周期的支持。</p>
<p>Executor基于 生产者-消费者模式，提交任务到线程池相当于生产者，执行任务相当于消费者。</p>
<h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>闭锁是一种同步工具类，作用是延迟线程的进度直到其到达终止状态。<br>###举个栗子：<br>闭锁的作用相当于一扇门，当闭锁到达结束状态之前，这扇门一直是关闭的，并且没有<code>任何线程</code>能通过,当闭锁到达技术状态的时候，这扇门会打开而让<code>所有</code><br>线程通过。<br>当闭锁到达结束状态的时候，这扇门会<code>永远</code>保持<code>打开</code>状态。<br>闭锁的作用是，可以用来确保某些活动直到其他活动<code>都完成</code>后才执行。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>纸上得来终觉浅，写了代码就知道为什么了。</p>
<p>还比如上一次写的爬虫，如果单线程抓取的话，只能首先抓取首页，然后解析其中的图片链接，然后再下载图片，这样效率无疑是很低的，现在<br>我加上线程池。</p>
<h3 id="建立工作队列"><a href="#建立工作队列" class="headerlink" title="建立工作队列"></a>建立工作队列</h3><p>一个是抓取页面的阻塞队列<code>naviQueue</code>,一个是抓取页面上的图片url的阻塞队列<code>imgQueue</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 定义一个页面导航的队列</span></span><br><span class="line"><span class="keyword">final</span> BlockingQueue&lt;String&gt; naviQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 定义一个图片网址的队列</span></span><br><span class="line"><span class="keyword">final</span> BlockingQueue&lt;String&gt; imgQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;String&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>线程池的大小是下载图片线程和解析页面线程的数量之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">DOWNLOAD_THREAD</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_THREAD</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newFixedThreadPool((DOWNLOAD_THREAD + PAGE_THREAD));</span><br></pre></td></tr></table></figure>

<h3 id="定义闭锁"><a href="#定义闭锁" class="headerlink" title="定义闭锁"></a>定义闭锁</h3><p>定义一个开始倒数锁和一个结束倒数锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个开始的倒数锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 定义一个结束的倒数锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>((DOWNLOAD_THREAD + PAGE_THREAD));</span><br></pre></td></tr></table></figure>

<p>其中，开始倒数锁的作用是，等待<code>主线程</code>加载首页信息，加载完成后才能继续抓取<code>下一页</code>的URL，所以开始倒数锁的初始大小为1，等初始化线程一旦执行完毕之后，<br>立刻释放所有的线程，开始执行并行任务。</p>
<p>结束倒数锁的作用是，主线程能够等待所有的工作线程依次执行完成，而不是顺序的等待每个线程执行完毕。</p>
<h3 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolMananger</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt;= PAGE_THREAD; i++) &#123;</span><br><span class="line">		exec.submit(<span class="keyword">new</span> <span class="title class_">PageThread</span>(i, begin, end));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt;= (DOWNLOAD_THREAD + PAGE_THREAD); i++) &#123;</span><br><span class="line">		exec.submit(<span class="keyword">new</span> <span class="title class_">ImageThread</span>(i, <span class="string">&quot;D:\\pictures&quot;</span>, begin, end));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">HtmlParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HtmlParser</span>();</span><br><span class="line">	<span class="type">SimpleHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHttpClient</span>();</span><br><span class="line">	parser.setHtml(client.get(<span class="string">&quot;http://jandan.net/pic&quot;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;====开始抓取首页&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		naviQueue.put(parser.getPageNavi());</span><br><span class="line">		parser.handleImgs(imgQueue);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	client.close();</span><br><span class="line">	System.out.println(<span class="string">&quot;首页结束，开始执行多线程抓取&quot;</span>);</span><br><span class="line">	begin.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器中初始化了页面抓取线程和一些下载图片的线程到线程池中，然后开始执行首页的抓取，等待首页抓取完毕之后，begin.coutDown(),这时候<code>开始门</code><br>的大小为0，这时候会释放所有的工作线程，开始执行多线程的抓取工作。</p>
<h3 id="页面处理线程"><a href="#页面处理线程" class="headerlink" title="页面处理线程"></a>页面处理线程</h3><p>页面抓取线程在初始化主线程执行完毕之后开始执行，从页面URL队列<code>naviQueue</code>中取出队列头部的url，使用Jsoup进行解析，得到本页面所有的<code>图片url</code>并添加到待处理<br>的图片URL队列<code>imgQueue</code>中然后得到<code>下一页</code>的链接URL，加入<code>naviQueue</code>中，如果在解析的过程中发现，Jsoup解析的下一页为空，那么就说明已经解析完成了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PageThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch stopSignal;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">PageThread</span><span class="params">(<span class="type">int</span> index, CountDownLatch start, CountDownLatch end)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.startSignal = start;</span><br><span class="line">			<span class="built_in">this</span>.stopSignal = end;</span><br><span class="line">			<span class="built_in">this</span>.index = index;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				startSignal.await();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="type">HtmlParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HtmlParser</span>();</span><br><span class="line">			<span class="type">SimpleHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHttpClient</span>();</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					url = naviQueue.take();</span><br><span class="line">					left = naviQueue.size();</span><br><span class="line">					<span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(url)) &#123;</span><br><span class="line">						<span class="comment">// 把结束的标志放回去，其他的线程也要调用</span></span><br><span class="line">						naviQueue.put(<span class="string">&quot;&quot;</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					System.err.println(<span class="string">&quot;[&quot;</span> + index + <span class="string">&quot;]:&quot;</span> + e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;[&quot;</span> + index + <span class="string">&quot;][页面left:&quot;</span> + left</span><br><span class="line">						+ <span class="string">&quot;]线程抓取html--&gt;&quot;</span> + url);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					html = client.get(url);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">				parser.setHtml(html);</span><br><span class="line">				<span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> parser.getPageNavi();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">						naviQueue.put(<span class="string">&quot;&quot;</span>);</span><br><span class="line">						parser.handleImgs(imgQueue); <span class="comment">// 在图片队列的最后也放上一个&quot;&quot;作为结束的标志</span></span><br><span class="line">						imgQueue.put(<span class="string">&quot;&quot;</span>);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						naviQueue.put(next);</span><br><span class="line">						parser.handleImgs(imgQueue);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			client.close();</span><br><span class="line">			stopSignal.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图片下载线程"><a href="#图片下载线程" class="headerlink" title="图片下载线程"></a>图片下载线程</h3><p>图片线程的主要任务就是下载所有的图片并保存到本地。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImageThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch stopSignal;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> threadIdx;</span><br><span class="line">	<span class="keyword">private</span> String dest;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ImageThread</span><span class="params">(<span class="type">int</span> index, String dest, CountDownLatch start,</span></span><br><span class="line"><span class="params">			CountDownLatch end)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.threadIdx = index;</span><br><span class="line">		<span class="built_in">this</span>.dest = dest;</span><br><span class="line">		<span class="built_in">this</span>.startSignal = start;</span><br><span class="line">		<span class="built_in">this</span>.stopSignal = end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 等待初始的线程结束</span></span><br><span class="line">			startSignal.await();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;[&quot;</span> + threadIdx + <span class="string">&quot;]线程开始&quot;</span>);</span><br><span class="line">		<span class="type">SimpleHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHttpClient</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">picurl</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 这个线程不断的从图片队列里面取出图片的地址</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 取出一个图片地址</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				picurl = imgQueue.take();</span><br><span class="line">				left = imgQueue.size();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">				System.err</span><br><span class="line">						.println(<span class="string">&quot;[&quot;</span> + threadIdx + <span class="string">&quot;]:&quot;</span> + e1.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(picurl)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 结束标志，丢回去，其他的线程要根据这个判断结束</span></span><br><span class="line">					imgQueue.put(<span class="string">&quot;&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 如果说，取到图片地址为空而且页面的已经解析完毕，这个就应该要结束了。</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;[&quot;</span> + threadIdx + <span class="string">&quot;][图片left:&quot;</span> + left</span><br><span class="line">						+ <span class="string">&quot;]线程开始抓取image--&gt;&quot;</span> + picurl);</span><br><span class="line">				client.downloadFile(picurl, dest);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				System.err.println(<span class="string">&quot;[&quot;</span> + threadIdx + <span class="string">&quot;]:&quot;</span> + e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		client.close();</span><br><span class="line">		stopSignal.countDown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>跑在立冬边上</title>
    <url>/2015/11/09/running-like-an-animal/</url>
    <content><![CDATA[<p>村上春树说，</p>
<blockquote>
<p>今天不想去跑步，所以才去跑步，这才是长跑者的思维</p>
</blockquote>
<p>因为这句话，我专门买了村上君的《当我谈跑步的时，我谈些什么》，这本书让我对跑步有了更加深层次的认识。<br>今天是2015年立冬，跑步也进入到了一年中最艰难的时候，上海的立冬并没有那么的冷，前一阵子冷空气经过上海的时候，冷了那么几天，但是过后天气又变得温暖起来了，算起来，从7月20号开始跑步到现在也快4个月了，也跑了将近500公里了。<br><img src="http://i13.tietuku.com/e552310b139e785ft.jpg" alt="running"><br>从蝉鸣的夏季，到燥热的秋季，再到冷风习习的冬季，时光就在脚步的一抬一落间逝去了，从身体流走的汗水已经数不清到底有多少了，喜欢奔跑的感觉，喜欢超越昨天自己的感觉，汗水浸润每一个细胞，感觉自己是真的自己。</p>
<p>十月份的国庆节中间耽误了一周没有跑步，所以国庆节一过便迫不及待的跑了起来，连着两周跑了半程马拉松，成绩也都还不错，都在2个小时之内,都是线上跑的，自己在学校的时候也跑过全程马拉松，但是，那是白天，而且有好多人一起跑，和现在不同，现在是一个人跑，而且是晚上，还有的路段，没有路灯，<br>但是跑下来竟然没有感觉脚起泡，而且腿似乎也没有感觉特别酸痛，只是过了一天才感觉到。<br><img src="http://i13.tietuku.com/bdc5beab77ef5929.jpg" alt="半马"><br>跑步，让自己的内心平静了很多，不管有多么不开心的事情，去跑步了，淋漓大汗过后，就会发现，其实也不过如此，哪有什么天大的事。再次，跑步让我明白了一个非常非常浅的道理，那就是，just do it. 以前做事情的时候，总是在想别人看到会怎么样，会怎么说，其实，哪有那么多闲人在意你在做什么，你去跑步<br>根本没有人在意你，就算有人说你了，TA又和你没有半点交集怕什么，当你真正穿上跑鞋，在路上奔跑的时候，你会发现世界都是你的，每次跑完10公里，在栏杆上压腿的时候，感觉到自己的心跳和呼吸，但是心里却是很平静，我希望跑步能陪我很久很久。</p>
<p>这几天，上海的天气一点都不好，只要一出门跑步肯定是不会下雨的，但是等自己跑到一半的时候就开始下了，就这样连着三天，每天都被雨淋，但是感觉当雨水打在脸上的时候，会发现自己的脚步更加坚定了，因为觉得，老子连在雨里跑步都不怕，还会怕什么呢，哈哈。<br>经过了一年最热的日子，去迎接美好的冬天，用心去过好每一天，发现身边的美。</p>
<p>老罗说，</p>
<blockquote>
<p>失败只有一种，那便是半途而废.</p>
</blockquote>
<span id="more"></span>

<p>回想自己，从去年12月开始捡起英语，到今天<code>一天</code>都不曾间断过，这可能也算是一种坚持，感觉自己萌萌哒。</p>
<p><img src="http://i13.tietuku.com/176fcb2f941b7c91s.jpg" alt="英语"></p>
<p>不去跑永远不知道自己能跑多久，能跑多远，刚开始跑步的时候78公斤，现在76公斤，跑了4个月减了4公斤，其实没有瘦多少，其实当初跑步的时候，并不全是为了要减重，最重要的是想要更加健康的身体吧。<br>年轻的时候就是要多做三件事：</p>
<blockquote>
<p>1.多挣钱<br>2.多读书<br>3.多锻炼</p>
</blockquote>
<p>多挣钱，让物质生活更加自由，多读书让精神更加自由，多锻炼，让生活更加自由。<br><strong>继续奔跑吧，坚持做你认为正确的事情！</strong></p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Spring boot 创建RestFul服务</title>
    <url>/2015/11/29/spring-boot-restful/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.JDK8<br>2.Maven 3.0+</p>
<h2 id="程序要实现的简单功能"><a href="#程序要实现的简单功能" class="headerlink" title="程序要实现的简单功能"></a>程序要实现的简单功能</h2><p>当用户访问</p>
<pre><code>http://localhost:8080/greeting
</code></pre>
<p>返回一个默认的Json字符串</p>
<pre><code>&#123;&quot;id&quot;:1,&quot;content&quot;:&quot;Hello, World!&quot;&#125;
</code></pre>
<p>当用户访问</p>
<pre><code>http://localhost:8080/greeting?name=User
</code></pre>
<p>返回 name后面的参数在后台组成的字符串</p>
<pre><code>&#123;&quot;id&quot;:1,&quot;content&quot;:&quot;Hello, User!&quot;&#125;
</code></pre>
<h2 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h2><p>创建一个普通的maven项目，添加maven依赖如下：</p>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zeusjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringMVCRESTFul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>各个包之间的依赖关系如下图：</p>
<p><img src="http://i5.tietuku.com/a954ae925778b0cb.png" alt="包依赖关系"><br>##创建一个resource representation 类<br>To model the greeting representation, you create a resource representation class.<br>Provide a plain old java object with fields, constructors, and accessors for the id and content data:</p>
<p>创建一个User类，有id和name两个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zeusjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">long</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当用户访问URL的时候，程序后台会自动获得URL上附带的名为<code>name</code>的参数。</p>
<h2 id="创建一个resource-controller"><a href="#创建一个resource-controller" class="headerlink" title="创建一个resource controller"></a>创建一个resource controller</h2><p>在Spring4中新增了一个@RestController注解，相当于Spring3中的@Controller和@ResponseBody两个注解一起的效果<br>创建一个UserController来处理Request如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zeusjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> <span class="string">&quot;Hello, %s!&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">greeting</span><span class="params">(<span class="meta">@RequestParam(value=&quot;name&quot;, defaultValue=&quot;World&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(counter.incrementAndGet(),</span><br><span class="line">                            String.format(template, name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><p>main方法使用Spring Boot 的<code>SpringApplication.run()</code>来加载程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zeusjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>在Application的main方法中运行application，在地址栏输入</p>
<pre><code>http://localhost:8080/greeting
</code></pre>
<p>结果为：<br><img src="http://i5.tietuku.com/f7230af6479c1cc9.png" alt="默认"></p>
<p>再输入一次</p>
<pre><code>http://localhost:8080/greeting?name=Zhaohongxuan
</code></pre>
<p>结果为：</p>
<p><img src="http://i5.tietuku.com/53e94df57cb9f031.png" alt="非默认"></p>
<p>不用配置繁琐的xml，一个简单的Restful风格的程序就创建好了。</p>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>java/spring</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程语言Scala的学习（Hello Scala）</title>
    <url>/2015/12/20/learning-scala/</url>
    <content><![CDATA[<p>Scala吸收了收并继承了多种语言中的优秀特性，另一方面也没有抛弃Java这个强大的平台，它可以运行在 Java 虚拟机之上，能够轻松地与Java互联互通。与Java不同的是，<br>Scala既支持面向对象的特性，又支持函数式编程，被称为是Java的替代语言，是更好的Java，下面开始学习这一强大的语言。</p>
<h2 id="Scala和Java比较"><a href="#Scala和Java比较" class="headerlink" title="Scala和Java比较"></a>Scala和Java比较</h2><p>在Scala中</p>
<ol>
<li>所有类型都是对象</li>
<li>函数是对象</li>
<li>支持Domain specific language (DSL)领域特定语言 </li>
<li>特质(Trait)</li>
<li>闭包(Closure)，嵌套函数</li>
<li>Erlang支持的并发设计</li>
<li>类型推导</li>
</ol>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><pre><code>scala&gt; 1 + 1
res0: Int = 2
</code></pre>
<p><code>res0</code>是解释器自动创建的变量名称，指代表达式计算的结果，是Int类型的，值为2。在scala几乎一切都是表达式。</p>
<h3 id="变量和值"><a href="#变量和值" class="headerlink" title="变量和值"></a>变量和值</h3><p>可以将表达式赋给一个或者不变量（val）–值或者变量（var）</p>
<pre><code>scala&gt; val two = 1 + 1
two: Int = 2
</code></pre>
<p>如果需要以后修改这个名称和结果的绑定，需要使用var（变量），大部分的情况下用val的情况居多。</p>
<pre><code>scala&gt; var name = &quot;zhaohongxuan&quot;
name: java.lang.String = zhaohongxuan

scala&gt; name = &quot;zhaoxiaoxuan&quot;
name: java.lang.String = zhaoxiaoxuan
</code></pre>
<span id="more"></span>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>使用<code>def</code>关键字来创建函数</p>
<pre><code>scala&gt; def addOne(m: Int): Int = m + 1
addOne: (m: Int)Int
</code></pre>
<p>调用函数：</p>
<pre><code>scala&gt; val three = addOne(2)
three: Int = 3
</code></pre>
<p>在scala中，需要为函数参数制定类型的签名。但是，如果函数不带参数，括号可以省略。</p>
<pre><code>scala&gt; def three() = 1 + 2
three: ()Int

scala&gt; three()
res2: Int = 3

scala&gt; three
res3: Int = 3
</code></pre>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>创建匿名函数</p>
<pre><code>scala&gt; (x: Int) =&gt; x + 1
res2: (Int) =&gt; Int = &lt;function1&gt;
</code></pre>
<p>这个函数的作用是给名为x的变量加1.</p>
<pre><code>scala&gt; res2(1)
res3: Int = 2
</code></pre>
<p>也可以传递匿名函数</p>
<pre><code>scala&gt; val addOne = (x: Int) =&gt; x + 1
addOne: (Int) =&gt; Int = &lt;function1&gt;

scala&gt; addOne(1)
res4: Int = 2
</code></pre>
<p>如果函数中表达式很多，可以用花括号{}来格式化代码、</p>
<pre><code>scala&gt; &#123; i: Int =&gt;
    println(&quot;hello world&quot;)
    i * 2
&#125;
res0: (Int) =&gt; Int = &lt;function1&gt;
</code></pre>
<h4 id="部分应用（Partial-application）"><a href="#部分应用（Partial-application）" class="headerlink" title="部分应用（Partial application）"></a>部分应用（Partial application）</h4><p>可以使用下划线<code>_</code>部分应用一个函数，结果是得到另一个函数。</p>
<p>定义一个add函数</p>
<pre><code>scala&gt; def add(m: Int, n: Int) = m + n
add: (m: Int,n: Int)Int
</code></pre>
<p>将add函数部分应用得到一个新的匿名函数</p>
<pre><code>scala&gt; val add2 = add(2, _:Int)
add2: (Int) =&gt; Int = &lt;function1&gt;

scala&gt; add2(3)
res50: Int = 5
</code></pre>
<h4 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h4><p>这是一种特殊的语法，可以向方法传入任意多个同类型的参数。比如给传入的参数的首字母进行大写的操作。</p>
<pre><code>def capitalizeAll(args: String*) = &#123;
  args.map &#123; arg =&gt;
    arg.capitalize
  &#125;
&#125;

scala&gt; capitalizeAll(&quot;zhaoxiaoxuan&quot;, &quot;douxiaonna&quot;)
res2: Seq[String] = ArrayBuffer(Zhaoxiaoxuan, Douxiaonna)
</code></pre>
<h2 id="类、继承与特质"><a href="#类、继承与特质" class="headerlink" title="类、继承与特质"></a>类、继承与特质</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><pre><code>scala&gt; class Calculator &#123;
     |   val brand: String = &quot;HP&quot;
     |   def add(m: Int, n: Int): Int = m + n
     | &#125;
defined class Calculator

scala&gt; val calc = new Calculator
calc: Calculator = Calculator@e75a11

scala&gt; calc.add(1, 2)
res1: Int = 3

scala&gt; calc.brand
res2: String = &quot;HP&quot;
</code></pre>
<p>这个计算器类展示了在类中使用<code>def</code>定义方法，和使用val定义字段。其中<code>方法</code>就是可以可以访问类状态的<code>函数</code>。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数不是特殊的方法，他们是除了类的方法定义之外的代码。</p>
<pre><code>class Calculator(brand: String) &#123;
  //构造函数
  val color: String = if (brand == &quot;TI&quot;) &#123;
    &quot;blue&quot;
  &#125; else if (brand == &quot;HP&quot;) &#123;
    &quot;black&quot;
  &#125; else &#123;
    &quot;white&quot;
  &#125;
  // An instance method.
  def add(m: Int, n: Int): Int = m + n
&#125;
</code></pre>
<p>使用构造函数来构造一个实例：</p>
<pre><code>scala&gt; val calc = new Calculator(&quot;HP&quot;)
calc: Calculator = Calculator@1e64cc4d

scala&gt; calc.color
res0: String = black
</code></pre>
<p>在上面的例子中，颜色的值就是绑定在一个if&#x2F;else表达式上的。Scala是高度面向表达式的：大多数东西都是表达式而非指令。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">xc: <span class="type">Int</span>, yc: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">val</span> y: <span class="type">Int</span> = yc</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>): <span class="type">Point</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Point</span>(x + dx, y + dy)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span>(<span class="params">u: <span class="type">Int</span>, v: <span class="type">Int</span>, c: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Point</span>(<span class="params">u, v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> color: <span class="type">String</span> = c</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compareWith</span></span>(pt: <span class="type">ColorPoint</span>): <span class="type">Boolean</span> =</span><br><span class="line">    (pt.x == x) &amp;&amp; (pt.y == y) &amp;&amp; (pt.color == color)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>): <span class="type">ColorPoint</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ColorPoint</span>(x + dy, y + dy, color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ColorPoint</code>继承了<code>Point</code>中所有的成员，包括<code>x,y</code>包括<code>move</code>方法。</p>
<p>子类<code>ColorPoint</code>增加了一个新的方法<code>compareWith</code>。<br>Scala允许对成员定义进行覆盖（Override），在这个例子中，我们在子类中用move方法<code>覆盖</code>了的父类的<code>move</code>方法,当然在子类中可以使用<code>super</code>关键字来调用父类的<code>move</code>方法。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>定义一个抽象类，它定义了一些方法但没有实现它们。取而代之是由扩展抽象类的子类定义这些方法。抽象类不能创建实例。</p>
<pre><code>scala&gt; abstract class Shape &#123;
     |   def getArea():Int    // subclass should define this
     | &#125;
defined class Shape

scala&gt; class Circle(r: Int) extends Shape &#123;
     |   def getArea():Int = &#123; r * r * 3 &#125;
     | &#125;
defined class Circle

scala&gt; val s = new Shape
&lt;console&gt;:8: error: class Shape is abstract; cannot be instantiated
       val s = new Shape
           ^
scala&gt; val c = new Circle(2)
c: Circle = Circle@65c0035b
</code></pre>
<h3 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h3><p>特质是一些字段和行为的集合，可以扩展或者混入（Mixin）你的类中。</p>
<pre><code>trait Car &#123;
  val brand: String
&#125;

trait Shiny &#123;
  val shineRefraction: Int
&#125;
class BMW extends Car &#123;
  val brand = &quot;BMW&quot;
&#125;
</code></pre>
<p>通过<code>with</code>关键字，一个类可以扩展多个特质：</p>
<pre><code>class BMW extends Car with Shiny &#123;
  val brand = &quot;BMW&quot;
  val shineRefraction = 12
&#125;
</code></pre>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Scala实现快速排序</title>
    <url>/2015/12/25/quicksort-in-scala/</url>
    <content><![CDATA[<p>首先是一个用Scala写的简单的快速排序的栗子（非函数式）：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(xs: <span class="type">Array</span>[<span class="type">Int</span>]) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">swap</span></span>(i: <span class="type">Int</span>, j: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="keyword">val</span> t = xs(i); xs(i) = xs(j); xs(j) = t</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">sort1</span></span>(l: <span class="type">Int</span>, r: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="keyword">val</span> pivot = xs((l + r) / <span class="number">2</span>)</span><br><span class="line">     <span class="keyword">var</span> i = l; <span class="keyword">var</span> j = r</span><br><span class="line">     <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">       <span class="keyword">while</span> (xs(i) &lt; pivot) i += <span class="number">1</span></span><br><span class="line">       <span class="keyword">while</span> (xs(j) &gt; pivot) j -= <span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">         swap(i, j)</span><br><span class="line">         i += <span class="number">1</span></span><br><span class="line">         j -= <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (l &lt; j) sort1(l, j)</span><br><span class="line">     <span class="keyword">if</span> (j &lt; r) sort1(i, r)</span><br><span class="line">   &#125;</span><br><span class="line">   sort1(<span class="number">0</span>, xs.length - <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>和Java写的快速排序类似，使用操作符和控制语句来实现，只不过语法和Java有所不同。但是Scala的不同点就在于它的<code>函数式编程</code>，<br>函数式编程可以写出完全不同的程序，更加简单，更加优雅。<br>这次还是快速排序，这一次用函数式的风格来写：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span></span>(xs: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Array</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  <span class="keyword">if</span> (xs.length &lt;= <span class="number">1</span>) xs</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pivot = xs(xs.length / <span class="number">2</span>)</span><br><span class="line">    <span class="type">Array</span>.concat(</span><br><span class="line">      quicksort(xs filter (pivot &gt;)),</span><br><span class="line">      xs filter (pivot ==),</span><br><span class="line">      quicksort(xs filter (pivot &lt;)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式编程用一种简洁的方式抓住了快速排序的本质</p>
<ol>
<li>如果数组array是空的或者只有一个元素那么肯定是已经排好序的所以直接返回</li>
<li>如果数组array不是空的,选择数组中间的元素当做pivot。</li>
<li>将数组划分为三个子数组,分别包含笔pivot大、小、相等的元素。</li>
<li>对于大于和小于pivot的子元素的数组递归调用sort函数。</li>
<li>讲三个子数组组合在一起就是排序结果。</li>
</ol>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala中的模式匹配</title>
    <url>/2016/01/14/pattern-matching-in-scala/</url>
    <content><![CDATA[<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>scala有一套内建的模式匹配机制，这种机制允许在任何类型的数据上与第一个匹配策略匹配。模式匹配可以应用在很多场合，switch语句，类型检查以及提取对象中的<br>的复杂表达式。</p>
<p>下面是一个小例子，说明如何与一个整型值匹配：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchTest1</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Int</span>): <span class="type">String</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">&quot;two&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;many&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(matchTest(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这段带有<code>case</code>的代码块定义了一个从证书向字符串映射的函数<br>关键字<code>match</code>提供了一个便捷的方法来把一个函数<code>apply</code>给一个对象，比如上面的模式匹配函数<code>matchTest</code>。<br>下面是第二个例子匹配不同类型</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchTest2</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Any</span>): <span class="type">Any</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;two&quot;</span> =&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> y: <span class="type">Int</span> =&gt; <span class="string">&quot;scala.Int&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(matchTest(<span class="string">&quot;two&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个case匹配如果 x是integer类型的且值为1的情况<br>第二个case匹配如果 x是string类型的且值为two的情况<br>Scala的模式匹配语句在通过y样例类来匹配代数类型是最有用的。<br>Scala也允许定义独立自主的对类的匹配，在提取对象使用了预定义的<code>unapply</code>方法。</p>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的null引用</title>
    <url>/2016/01/21/null-reference-in-java/</url>
    <content><![CDATA[<p>空指针也许是java中最常见的异常，到处都埋藏着NullpointerException，最近就遇到一个NullPointException，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">lastMonthTotalScore</span> <span class="operator">=</span> integralOperationReadMapper.getSumByIntegralIdAndDate(integralId, lastMonthDate);</span><br></pre></td></tr></table></figure>

<p>一个很常见的情况，mybatis查询的一个列的和，此时Debug时 integralId、lastMonthDate 都不为空，自动注入的 <code>integralOperationReadMapper</code>也不为空<br>但是Console却实实在在的打出了这一行有一个NullPointerException，此时没有注意到Wrapper类自动转换<code>基本数据类型</code>的情形。</p>
<p><code>getSumByIntegralIdAndDate</code> 方法返回的是<code>NULL</code>，自动拆箱的时候的要将一个NULL转换为基本数据类型就出错了…o(╯□╰)o</p>
<p>现在总结几个NULL的经验。</p>
<p>1.不用null来返回方法的返回值<br>  不要用null来舒适化变量，方法不要返回null、这样会造成null的传播，在每一个调用的地方都需要检查null<br>  例如：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> findName(id);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这样如果findName如果返回为null，那么null就由findname游走到了doSomething。比如在findname中，如果没有找到对应的Id的姓名，就应该表明是<code>没找到</code>，而不是<code>出错了</code>。<br>  善于运用Java的异常。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException &#123;</span><br><span class="line"> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotFoundException</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>



<p>2.不把null放进容器内<br>  容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。<br>解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。<br>需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。</p>
<p>3.尽早对方法进行参数检查null<br> 应该尽早的对null进行检查，不试图对null进行容错，采用强硬的手段,如果为空则抛出异常，可以使用java.util包里Objects.requireNonNull()方法来给方法的作者回应，告诉方法作者不应该把null传进来。<br> Objects.requireNonNull()方法如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.使用Java8的Optional或者guava的Optional</p>
<p>Optional类型的设计原理，就是把<code>检查</code>和<code>访问</code>这两个操作合二为一，成为一个<code>原子操作</code>。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala中的特质</title>
    <url>/2016/02/23/trait-in-scala/</url>
    <content><![CDATA[<p>特质的构造顺序</p>
<pre><code>1. 超类的构造器
2. 特质由左至右构造
3. 每个特质中，父特质先被构造
4. 多个特质公用一个父特质，而那个特质已经被构造，则不会被再次构造
5. 所有特质构造完毕，子类被构造
</code></pre>
<p>eg： 其中 <code>FileLogger</code>和<code>ShortLogger</code>都继承<code>Logger</code>特质</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">calss <span class="type">SavingsAccount</span> <span class="keyword">extends</span> <span class="type">Account</span> <span class="keyword">with</span> <span class="type">FileLogger</span> <span class="keyword">with</span> <span class="type">ShortLogger</span></span><br></pre></td></tr></table></figure>

<p>构造顺序</p>
<pre><code>1.Account（超类）
2.Logger（第一个特质的父特质）
3.FileLogger（第一个特质）
4.ShortLogger（第一个特质）
5.SavingAccount（类）
</code></pre>
<span id="more"></span>

<p>JVM中的特质</p>
<p>由于scala在jvm中运行，所以scala需要将特质翻译为JVM的类与接口</p>
<p>只有抽象方法的特质被简单的翻译成一个Java接口</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被翻译为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果特质中有具体的方法，Scala会创建出一个伴生类，伴生类用<code>静态方法</code>存放特质的方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>)&#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被翻译成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Stirng msg)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以及一个和ConsoleLogger接口对应的伴生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLogger$class</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(ConsoleLogger self, String msg)</span>&#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Java的NIO</title>
    <url>/2016/02/28/learn-java-nio/</url>
    <content><![CDATA[<p>重要的概念</p>
<h2 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO?"></a>什么是NIO?</h2><p>NIO是从java 1.4 开始引入的一个新的 <code>IO API</code>。</p>
<p>Channel、Buffer、Selector是NIO的核心部分。</p>
<p>IO通过字节流和字符流操作数据，NIO基于通道(Channel)和缓冲区(Buffer)数据 </p>
<h3 id="Channel-amp-Buffer"><a href="#Channel-amp-Buffer" class="headerlink" title="Channel&amp;Buffer"></a>Channel&amp;Buffer</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>数据总是由通道到缓冲区（<code>Read</code>），或者由缓冲区到通道（<code>write</code>）</p>
<p>其中Channel的几个实现</p>
<pre><code>FileChannel
DatagramChannel
SocketChannel
ServerSocketChannel
</code></pre>
<p>分别对应文件IO&#x2F;UDP&#x2F;TCP网络IO.</p>
<p>下面是一个简单的例子实现，从本地文件系统读取数据到Buffer中。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Channel的使用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileChannelTest</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D:/nio.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">           <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> randomAccessFile.getChannel();</span><br><span class="line">           <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span>  ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> fileChannel.read(byteBuffer);</span><br><span class="line">           <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Read:&quot;</span>+bytesRead);</span><br><span class="line">               byteBuffer.flip();</span><br><span class="line">               <span class="keyword">while</span>(byteBuffer.hasRemaining())&#123;</span><br><span class="line">                   System.out.print((<span class="type">char</span>)byteBuffer.get());</span><br><span class="line">               &#125;</span><br><span class="line">               byteBuffer.clear();</span><br><span class="line">               bytesRead = fileChannel.read(byteBuffer);</span><br><span class="line">           &#125;</span><br><span class="line">           randomAccessFile.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer的几个重要实现<br>    ByteBuffer<br>    CharBuffer<br>    DoubleBuffer<br>    FloatBuffer<br>    IntBuffer<br>    LongBuffer<br>    ShortBuffer</p>
<p>可以通过这些Buffer向Channel数据，或者从Channel读取数据。</p>
<p>使用Buffer来读写数据的步骤</p>
<pre><code>写入数据到Buffer
调用flip()方法
从Buffer中读取数据  
调用clear()方法或者compact() 方法
</code></pre>
<p>clear()方法会清空整个缓冲区，而compact会清空已经读取过的数据。</p>
<p><img src="http://i12.tietuku.com/bfa5f260b1a477ff.png" alt="buffer属性"></p>
<p>Buffer的三个属性，position,limit,capacity</p>
<p>capacity 是缓冲区的大小<br>position</p>
<p>写数据时：position表示是当前位置，当前位置写入完毕，position移动到下一个可写的位置， 范围为0~capacity-1.<br>读数据时：position表示当前位置，当前位置读取完毕，position移动到下一个可读位置。</p>
<p>limit<br>limit表示的是最多能够读取的或者写入的数据的大小。<br>写模式：limit等于capacity<br>读模式：limit等于读模式的position</p>
<p>分配buffer<br>使用<code>allocate()</code>方法来分配Buffer.例如分配一个100字节长的ByteBuffer缓冲区:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>向Buffer中写入数据<br>1.从channel中读取到Buffer中</p>
<pre><code>int bytesRead = inChannel.read(buffer);
</code></pre>
<p>2.直接向buffer中put<br>    buffer.put(100);</p>
<p>从Buffer中读取数据</p>
<p>1.从Buffer中写数据到Channel<br>    int bytesRead &#x3D; inChannel.write(buffer);<br>2.使用get()方法从Buffer中读取数据<br>    int bytes &#x3D; buffer.get();</p>
<p>rewind()方法</p>
<p>rewind()方法将position设置为0</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p><img src="http://i4.tietuku.com/8793cae275479b76.png" alt="Selector"></p>
<p>Selector最重要的特点就是他允许<code>单线程</code>处理多个Channel.</p>
<p>1.创建Selector</p>
<p>使用Selector的open()方法创建一个Selector</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>
<p>2.注册Channel</p>
<p>将Channel绑定到一起，使用channel.register()来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">Selector</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector,Selectionkey.OP_READ);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>configureBlocking是设置Channel为非阻塞模式。FileChannel不能和Selector绑定，因为FileChannel没有阻塞模式。</p>
<p>3.SelectionKey</p>
<p>SelectorKey是一个抽象类 包含了</p>
<pre><code>interest集合
ready集合
Channel
Selector
</code></pre>
<p>1.interest集合<br>通过Selector监听Channel时对什么事件感兴趣，可以监听4中类型的事件，分别是<code>OP_CONNECT</code>,<code>OP_ACCEPT</code>,<code>OP_READ</code>,<code>OP_WRITE</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> selectionKey.interestOps();  </span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isInterestedInAccept</span>  <span class="operator">=</span> (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；  </span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInConnect</span> <span class="operator">=</span> interestSet &amp; SelectionKey.OP_CONNECT;  </span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInRead</span>    <span class="operator">=</span> interestSet &amp; SelectionKey.OP_READ;  </span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInWrite</span>   <span class="operator">=</span> interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<p>通过<code>&amp;</code>来和SelectorKey常量确定某个事件是在interest集合中。</p>
<p>2.ready集合<br>  ready集合是Channel已经准备就绪的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>

<p>3.通过Selector的select()方法选择Channel<br>使用selector的select()方法来返回已经就绪的通道。<br>select()方法会一直阻塞到至少有一个通道在事件上注册了。<br>select()方法返回的int值表示已经有多少个通道已经就绪了<br>4.调用过select()方法后，如果返回的int值大于1则表示已经有至少一个通道已经就绪了，这个时候可以调用Selector的selectedKeys()方法来选择已经就绪的Channel.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">selectKeys</span> <span class="operator">=</span> selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>遍历这个集合来访问就绪的通道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;ng</span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/nio</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合中的Fail-fast和Fail-Safe机制</title>
    <url>/2016/03/23/java-collection-failfast-failsafe/</url>
    <content><![CDATA[<h3 id="1-何为Fail-fast和Fail-Safe机制？"><a href="#1-何为Fail-fast和Fail-Safe机制？" class="headerlink" title="1.何为Fail-fast和Fail-Safe机制？"></a>1.何为Fail-fast和Fail-Safe机制？</h3><p>java.util包里的Iterator 抛出<code> ConcurrentModificationException</code>异常， 在集合迭代的时候被集合的<code>add</code>方法或者 <code>remove</code>方法调用。fail-fast 指java的集合的一种错误机制，当多个线程对集合修改操作的时候就可能抛出<code>ConcurrentModificationException</code>异常。</p>
<p><code>java.util.concurrent</code>包里的Iterator 通过迭代一个集合的<code>snapshot</code> 允许并发修改集合，但是在迭代器创建之后可能不反映Collection更新。fail-safe机制意味着多个线程在操作同一个集合的时候，不会出现<code>ConcurrentModificationException</code>异常,<br>但是需要复制集合获得集合的快照，所以性能上开销会比非同步的集合开销要大。</p>
<p>多线程环境下用<code>java.util.concurrent</code>包里的集合替代 <code>java.util</code>包里的集合，比如 CopyOnWriteList&#x3D;&gt;ArrayList,ConcurrentHashMap&#x3D;&gt;HashMap etc.</p>
<h3 id="2-JDK中的源码分析"><a href="#2-JDK中的源码分析" class="headerlink" title="2.JDK中的源码分析"></a>2.JDK中的源码分析</h3><p>下面代码是JDK1.7源码中ArrayList中的ListIterator，当Iterator创建时，当前的计数器<code>modCount</code> 赋值给Iterator对象,注意到<code>modCount</code>是一个 <code>transient</code>类型的成员变量，transient说明了计数器将不被序列化。</p>
<pre><code>protected transient int modCount = 0;
</code></pre>
<p>modCount用来记录List修改的次数的计数器，每修改一次(添加&#x2F;删除等操作)，将modCount+1，例如 add()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       checkForComodification();</span><br><span class="line">       l.add(index+offset, element);</span><br><span class="line">       <span class="built_in">this</span>.modCount = l.modCount;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>当Iterator执行相应操作的时候，会先检验两个计数器的值是否相等，如果不相等就抛出<code>ConcurrentModificationException</code> 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">       <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> cursor != size;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">           checkForComodification();</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">           Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">           cursor = i + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">               cursor = lastRet;</span><br><span class="line">               lastRet = -<span class="number">1</span>;</span><br><span class="line">               expectedModCount = modCount;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>CopyOnWriteArrayList的Iterator，可以看到COWIterator在构造函数初始化的时候把集合中的元素保存了一份快照，所有的操作都在快照上面进行的。CopyOnWriteArrayList的Iterator实现类中，checkForComodification()方法，也没有抛出ConcurrentModificationException异常！ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">COWIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException always; &lt;tt&gt;remove&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException always; &lt;tt&gt;set&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException always; &lt;tt&gt;add&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/collection</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC源码探究</title>
    <url>/2016/04/06/spring-mvc-source-code/</url>
    <content><![CDATA[<p>作为一名合格的java程序员，要多深入学习一些框架，理解框架的设计的方法，背后的原理，spring mvc框架中使用了很多设计模式，比如<code>策略模式</code>，Spring MVC中大量使用了策略模式，像HandlerMapping接口，HandlerAdapter接口,ViewResolver接口<br>都使用了策略模式，在执行<code>handler</code>和<code>Interceptor</code>拦截器的时候使用了<code>责任链模式</code>，在<code>执行handler</code>的时候会用到<code>适配器模式</code>等等，可以说沉淀了很多前辈的精华，想成为架构师的话，学习源码必不可少，下面就围绕着Spring MVC 的前端控制器<br><code>DispatcherServlet</code>一步一步的来学习Spring MVC的源码。</p>
<h3 id="1-web-xml中DispatcherServlet的配置"><a href="#1-web-xml中DispatcherServlet的配置" class="headerlink" title="1 web.xml中DispatcherServlet的配置"></a>1 web.xml中DispatcherServlet的配置</h3><p>web.xml中的Spring MVC的前端控制器DispatcherServlet的配置，所有后端Controller的请求都由这个<code>DispatcherServlet</code>分发。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MySpringServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MySpringServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4 id="DispatcherServlet-类等级视图"><a href="#DispatcherServlet-类等级视图" class="headerlink" title="DispatcherServlet 类等级视图"></a>DispatcherServlet 类等级视图</h4><p><img src="/../../../static/images/spring-mvc.png" alt="类等级视图"></p>
<h4 id="DispactcherServlet-中的doService-方法"><a href="#DispactcherServlet-中的doService-方法" class="headerlink" title="DispactcherServlet 中的doService()方法"></a>DispactcherServlet 中的doService()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exposes the DispatcherServlet-specific request attributes and delegates to &#123;<span class="doctag">@link</span> #doDispatch&#125;</span></span><br><span class="line"><span class="comment">	 * for the actual dispatching.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">resumed</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class="string">&quot; resumed&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">			logger.debug(<span class="string">&quot;DispatcherServlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span> + resumed +</span><br><span class="line">					<span class="string">&quot; processing &quot;</span> + request.getMethod() + <span class="string">&quot; request for [&quot;</span> + getRequestUri(request) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">		<span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">		Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">			attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">			Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">			<span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">&quot;org.springframework.web.servlet&quot;</span>)) &#123;</span><br><span class="line">					attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">		request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">		request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">		request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">		request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">		<span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">		<span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">			request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">		&#125;</span><br><span class="line">		request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">		request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">//执行dispatch方法</span></span><br><span class="line">			doDispatch(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">			<span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">				restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>doService方法实现了抽象类<code>FrameworkServlet</code>的<code>doService</code>方法，在doService方法中调用了doDispatcher()方法处理分发请求</p>
<h3 id="2-DipatcherServlet的doDispatcher-方法"><a href="#2-DipatcherServlet的doDispatcher-方法" class="headerlink" title="2.DipatcherServlet的doDispatcher()方法"></a>2.DipatcherServlet的doDispatcher()方法</h3><p>doService方法中将请求委托给doDispatch()方法由<code>doDispatch()</code>来分发相应的请求给各个Handler(Controller),我在每一个关键步骤上标注了注释，下面还有相应的源码解释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the actual dispatching to the handler.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The handler will be obtained by applying the servlet&#x27;s HandlerMappings in order.</span></span><br><span class="line"><span class="comment"> * The HandlerAdapter will be obtained by querying the servlet&#x27;s installed HandlerAdapters</span></span><br><span class="line"><span class="comment"> * to find the first that supports the handler class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All HTTP methods are handled by this method. It&#x27;s up to HandlerAdapters or handlers</span></span><br><span class="line"><span class="comment"> * themselves to decide which methods are acceptable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">	<span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">//1.检测是否是多媒体请求，比如文件上传，将HttpServletRequest包装为MultipartHttpServletRequest</span></span><br><span class="line">			processedRequest = checkMultipart(request);</span><br><span class="line">			multipartRequestParsed = processedRequest != request;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//2.遍历所有的HandlerMapper对象根据请求的URL获得相应的HandlerExecutionChain，其中HandlerMapping是一个</span></span><br><span class="line">			<span class="comment">//接口，Spring给出了一个默认的实现配置在DispatcherServlet.properties文件中，如果找不到对应的HandlerMap//per，spring会给出提示 No mapping found for HTTP request with URI...</span></span><br><span class="line">	</span><br><span class="line">			mappedHandler = getHandler(processedRequest);</span><br><span class="line">			<span class="keyword">if</span> (mappedHandler == <span class="literal">null</span> || mappedHandler.getHandler() == <span class="literal">null</span>) &#123;</span><br><span class="line">				noHandlerFound(processedRequest, response);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//3.根据当前的request遍历所有的Adapter选择第一个支持的adapter，这里使用了责任链模式</span></span><br><span class="line">			<span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">			<span class="comment">//4.处理 last-modified header 判断是否被handler支持</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">			<span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">				<span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Last-Modified value for [&quot;</span> + getRequestUri(request) + <span class="string">&quot;] is: &quot;</span> + lastModified);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">               <span class="comment">//5.执行handler的拦截器的preHandle方法</span></span><br><span class="line">			<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 6.调用真正的handler，处理业务代码</span></span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			applyDefaultViewName(request, mv);</span><br><span class="line">			<span class="comment">//7.执行handler的拦截器的postHandle方法</span></span><br><span class="line">			mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			dispatchException = ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//8.处理返回结果视图</span></span><br><span class="line">		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">		triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">			mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">		<span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">			cleanupMultipart(processedRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-根据request获得所有的HandlerMapping并匹配一个合适的Handler（Controller）"><a href="#1-根据request获得所有的HandlerMapping并匹配一个合适的Handler（Controller）" class="headerlink" title="1. 根据request获得所有的HandlerMapping并匹配一个合适的Handler（Controller）"></a>1. 根据request获得所有的HandlerMapping并匹配一个合适的Handler（Controller）</h4><p>AbstractHandlerMapping实现了HandlerMapping接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span>：遍历所有intercepter，取指定接口的拦截器bean</span><br><span class="line">    <span class="number">2</span>：根据url找到对应的hander</span><br><span class="line">    <span class="number">3</span>：封装成chain</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request);</span><br><span class="line">		<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">			handler = getDefaultHandler();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">		<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">			handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> getHandlerExecutionChain(handler, request);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</span></span><br><span class="line"><span class="comment">		HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?</span></span><br><span class="line"><span class="comment">				(HandlerExecutionChain) handler : new HandlerExecutionChain(handler));</span></span><br><span class="line"><span class="comment">		chain.addInterceptors(getAdaptedInterceptors());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);</span></span><br><span class="line"><span class="comment">		for (MappedInterceptor mappedInterceptor : this.mappedInterceptors) &#123;</span></span><br><span class="line"><span class="comment">			if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123;</span></span><br><span class="line"><span class="comment">				chain.addInterceptor(mappedInterceptor.getInterceptor());</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		return chain;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<p>AbstractUrlHandlerMapping继承了AbstractHandlerMapping重写了getHandlerInternal()抽象方法。这个方法给出了根据请求的URL获得handler的实现方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Look up a handler for the URL path of the given request.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the handler instance, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">		<span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> lookupHandler(lookupPath, request);</span><br><span class="line">		<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line">			<span class="comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">rawHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(lookupPath)) &#123;</span><br><span class="line">				rawHandler = getRootHandler();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rawHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">				rawHandler = getDefaultHandler();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rawHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">				<span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">					<span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) rawHandler;</span><br><span class="line">					rawHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">				&#125;</span><br><span class="line">				validateHandler(rawHandler, request);</span><br><span class="line">				handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="literal">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (handler != <span class="literal">null</span> &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Mapping [&quot;</span> + lookupPath + <span class="string">&quot;] to &quot;</span> + handler);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (handler == <span class="literal">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No handler mapping found for [&quot;</span> + lookupPath + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> handler;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-获得HandlerExecutionChain"><a href="#2-获得HandlerExecutionChain" class="headerlink" title="2.获得HandlerExecutionChain"></a>2.获得HandlerExecutionChain</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the HandlerExecutionChain for this request.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Tries all handler mappings in order.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the HandlerExecutionChain, or &#123;<span class="doctag">@code</span> null&#125; if no handler could be found</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">for</span> (HandlerMapping hm : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(</span><br><span class="line">						<span class="string">&quot;Testing handler map [&quot;</span> + hm + <span class="string">&quot;] in DispatcherServlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> hm.getHandler(request);</span><br><span class="line">			<span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerExecutionChain是由一系列的Handler和HandlerInterceptor组成的责任链，下面是HandlerExecutionChain中的成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">interceptorIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<h4 id="3-根据相应的handler去获得合适的HandlerAdapter"><a href="#3-根据相应的handler去获得合适的HandlerAdapter" class="headerlink" title="3.根据相应的handler去获得合适的HandlerAdapter"></a>3.根据相应的handler去获得合适的HandlerAdapter</h4><p>HandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HandlerAdapter的实现类HttpRequestHandlerAdapter，在<code>DispatcherServlet.properties</code>文件配置的默认实现的其中之一，在HandlerAdapter中执行Handler（Controller）的方法，并且给前端控制器<code>DispatcherServlet</code>返回一个<code>ModelAndView</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2012 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.servlet.mvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.HttpRequestHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adapter to use the plain &#123;<span class="doctag">@link</span> org.springframework.web.HttpRequestHandler&#125;</span></span><br><span class="line"><span class="comment"> * interface with the generic &#123;<span class="doctag">@link</span> org.springframework.web.servlet.DispatcherServlet&#125;.</span></span><br><span class="line"><span class="comment"> * Supports handlers that implement the &#123;<span class="doctag">@link</span> LastModified&#125; interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否适配当前adapter</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">		((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) &#123;</span><br><span class="line">			<span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HttpRequestHandler接口的实现类ResourceHttpRequestHandler,handleRequest()方法用来处理请求返回结果，数据转化，数据校验，格式化等操作都是在这一步进行。比如自动将Json数据转换为对应的实体等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Processes a resource request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Checks for the existence of the requested resource in the configured list of locations.</span></span><br><span class="line"><span class="comment"> * If the resource does not exist, a &#123;<span class="doctag">@code</span> 404&#125; response will be returned to the client.</span></span><br><span class="line"><span class="comment"> * If the resource exists, the request will be checked for the presence of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Last-Modified&#125; header, and its value will be compared against the last-modified</span></span><br><span class="line"><span class="comment"> * timestamp of the given resource, returning a &#123;<span class="doctag">@code</span> 304&#125; status code if the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Last-Modified&#125; value  is greater. If the resource is newer than the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Last-Modified&#125; value, or the header is not present, the content resource</span></span><br><span class="line"><span class="comment"> * of the resource will be written to the response with caching headers</span></span><br><span class="line"><span class="comment"> * set to expire one year in the future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">	checkAndPrepare(request, response, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check whether a matching resource exists</span></span><br><span class="line">	<span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> getResource(request);</span><br><span class="line">	<span class="keyword">if</span> (resource == <span class="literal">null</span>) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;No matching resource found - returning 404&quot;</span>);</span><br><span class="line">		response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check the resource&#x27;s media type</span></span><br><span class="line">	<span class="type">MediaType</span> <span class="variable">mediaType</span> <span class="operator">=</span> getMediaType(resource);</span><br><span class="line">	<span class="keyword">if</span> (mediaType != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Determined media type &#x27;&quot;</span> + mediaType + <span class="string">&quot;&#x27; for &quot;</span> + resource);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;No media type found for &quot;</span> + resource + <span class="string">&quot; - not sending a content-type header&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// header phase</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(resource.lastModified())) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Resource not modified - returning 304&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	setHeaders(response, resource, mediaType);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// content phase</span></span><br><span class="line">	<span class="keyword">if</span> (METHOD_HEAD.equals(request.getMethod())) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;HEAD request - skipping content&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	writeContent(response, resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-处理返回结果视图"><a href="#4-处理返回结果视图" class="headerlink" title="4.处理返回结果视图"></a>4.处理返回结果视图</h4><p>处理异常视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle the result of handler selection and handler invocation, which is</span></span><br><span class="line"><span class="comment">	 * either a ModelAndView or an Exception to be resolved to a ModelAndView.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">			HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">				mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">				<span class="comment">//处理异常视图</span></span><br><span class="line">				mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">				errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">		<span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">			render(mv, request, response);</span><br><span class="line">			<span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">				WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Null ModelAndView returned to DispatcherServlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">						<span class="string">&quot;&#x27;: assuming HandlerAdapter completed request handling&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			<span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">			mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>渲染指定的 ModelAndView</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Render the given ModelAndView.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is the last stage in handling a request. It may involve resolving the view by name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mv the ModelAndView to render</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP servlet request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP servlet response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if view is missing or cannot be resolved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if there&#x27;s a problem rendering the view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// Determine locale for request and apply it to the response.</span></span><br><span class="line">	<span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> <span class="built_in">this</span>.localeResolver.resolveLocale(request);</span><br><span class="line">	response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">	View view;</span><br><span class="line">	<span class="keyword">if</span> (mv.isReference()) &#123;</span><br><span class="line">		<span class="comment">// We need to resolve the view name.</span></span><br><span class="line">		view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</span><br><span class="line">		<span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Could not resolve view with name &#x27;&quot;</span> + mv.getViewName() +</span><br><span class="line">					<span class="string">&quot;&#x27; in servlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">		view = mv.getView();</span><br><span class="line">		<span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;ModelAndView [&quot;</span> + mv + <span class="string">&quot;] neither contains a view name nor a &quot;</span> +</span><br><span class="line">					<span class="string">&quot;View object in servlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delegate to the View object for rendering.</span></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Rendering view [&quot;</span> + view + <span class="string">&quot;] in DispatcherServlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		view.render(mv.getModelInternal(), request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Error rendering view [&quot;</span> + view + <span class="string">&quot;] in DispatcherServlet with name &#x27;&quot;</span> +</span><br><span class="line">					getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-DispatcherServlet-properties"><a href="#3-DispatcherServlet-properties" class="headerlink" title="3.DispatcherServlet.properties"></a>3.DispatcherServlet.properties</h3><p>DispatcherServlet.properties中配置的一些DispatcherServlet的一些策略模式接口的实现，包括HandlerMapping，HandlerAdapter，ViewResolver等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Default implementation classes <span class="keyword">for</span> DispatcherServlet<span class="string">&#x27;s strategy interfaces.</span></span><br><span class="line"><span class="string"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span></span><br><span class="line"><span class="string"># Not meant to be customized by application developers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span></span><br><span class="line"><span class="string">	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span></span><br></pre></td></tr></table></figure>


<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>下图是Spring MVC 工作流程的时序图</p>
<p><img src="/../../../static/images/1365825551_8302.png" alt="Spring MVC 工作流程的时序图"></p>
<pre><code>1. 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；
2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；
3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法）
4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：
      HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息
      数据转换：对请求消息进行数据转换。如String转换成Integer、Double等
      数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等
      数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中
5.  Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；
6.  根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；
7.  ViewResolver 结合Model和View，来渲染视图
8.  将渲染结果返回给客户端。
</code></pre>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>java/spring</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL命令的使用</title>
    <url>/2016/05/08/how-use-curl/</url>
    <content><![CDATA[<p>Linux curl命令的使用</p>
<p>参考官方文档</p>
<blockquote>
<p><a href="https://curl.haxx.se/docs/manpage.html">https://curl.haxx.se/docs/manpage.html</a></p>
</blockquote>
<h1 id="一、什么是cURL"><a href="#一、什么是cURL" class="headerlink" title="一、什么是cURL"></a>一、什么是cURL</h1><p>  wikipedia中的解释如下：</p>
<blockquote>
<p>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。<br>  cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。</p>
</blockquote>
<p> 简单的说，cURL就是把发出请求然后得到响应并把响应数据显示到标准输出上的一个<code>命令行工具</code>。<br>  语法：<br>  curl [option] [URL]</p>
<h1 id="二、cURL的用法"><a href="#二、cURL的用法" class="headerlink" title="二、cURL的用法"></a>二、cURL的用法</h1><h3 id="1-保存curl的结果到文件"><a href="#1-保存curl的结果到文件" class="headerlink" title="1. 保存curl的结果到文件"></a>1. 保存curl的结果到文件</h3><pre><code>curl -o [filename] [URL]
</code></pre>
<p>比如要保存 <code>http://zeusjava.com</code> 到blog.html中，可以使用</p>
<pre><code>curl -o blog.html http://zeusjava.com
</code></pre>
<p>当然，也可以直接用</p>
<pre><code>curl http://zeusjava.com &gt;blog.html
</code></pre>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -o blog.html http://zeusjava.com</span><br></pre></td></tr></table></figure>

<p>使用 <code>-o</code> 也可以用于下载文件</p>
<pre><code>curl -o android-studio-2.0.exe https://dl.google.com/dl/android/studio/install/2.0.0.20/android-studio-bundle-143.2739321-windows.exe
</code></pre>
<p>使用 <code>-O</code>可以将下载的文件名自动命名为服务器端文件的名字</p>
<pre><code>curl -O https://dl.google.com/dl/android/studio/install/2.0.0.20/android-studio-bundle-143.2739321-windows.exe
</code></pre>
<span id="more"></span>
<h3 id="2-显示http-response的Header信息"><a href="#2-显示http-response的Header信息" class="headerlink" title="2.显示http response的Header信息"></a>2.显示http response的Header信息</h3><pre><code>curl -i [URL]
</code></pre>
<p>比如 <code>curl -i http://zeusjava.com</code> 服务器返回的Header信息如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: GitHub.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Last-Modified: Thu, 14 Apr 2016 05:39:44 GMT</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Expires: Mon, 02 May 2016 22:38:46 GMT</span><br><span class="line">Cache-Control: max-age=600</span><br><span class="line">X-GitHub-Request-Id: 17EB2B23:6096:A5D8C82:5727D49C</span><br><span class="line">Content-Length: 16009</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Sat, 07 May 2016 10:25:24 GMT</span><br><span class="line">Via: 1.1 varnish</span><br><span class="line">Age: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">X-Served-By: cache-ams4129-AMS</span><br><span class="line">X-Cache: HIT</span><br><span class="line">X-Cache-Hits: 1</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Fastly-Request-ID: cd84d46856e9a80b4a283db2225e8caeb0d439b0</span><br></pre></td></tr></table></figure>

<p>由于使用过的是Github Pages 所以Server是Github.com</p>
<h3 id="3-显示Http-request和-response的Header信息"><a href="#3-显示Http-request和-response的Header信息" class="headerlink" title="3.显示Http request和 response的Header信息"></a>3.显示Http request和 response的Header信息</h3><pre><code>curl -v [URL]
</code></pre>
<p><code>-v</code>选项可以向标准输出中打印和Server的通信过程的信息，包括 http request和http response的信息<br>下面是和zeusjava.com的通信过程的头部信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Rebuilt URL to: http://www.zhihu.com/</span><br><span class="line">*   Trying 58.216.25.33...</span><br><span class="line">* Connected to www.zhihu.com (58.216.25.33) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: www.zhihu.com</span><br><span class="line">&gt; User-Agent: curl/7.48.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Server: ZWS</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Date: Mon, 13 Jun 2016 06:28:32 GMT</span><br><span class="line">&lt; Cache-Control: no-store</span><br><span class="line">&lt; Content-Type: text/html; charset=UTF-8</span><br><span class="line">&lt; Content-Length: 8440</span><br><span class="line">&lt; X-Za-Response-Id: 1be55a9577484a62ae8289e23216dfdb</span><br><span class="line">&lt; Content-Security-Policy: default-src *; img-src * data:; frame-src &#x27;self&#x27; *.zhihu.com getpocket.com note.youdao.com; script-src &#x27;self&#x27; *.zhihu.com *.google-analytics.com zhstatic.zhihu.com res.wx.qq.com &#x27;unsafe-eval&#x27;; style-src &#x27;self&#x27; *.zhihu.com &#x27;unsafe-inline&#x27;</span><br><span class="line">&lt; Set-Cookie: q_c1=3af89a60e8454cad977358c33bff9823|1465799312000|1465799312000; Domain=zhihu.com; expires=Thu, 13 Jun 2019 06:28:32 GMT; Path=/</span><br><span class="line">&lt; Set-Cookie: _xsrf=ed72c7326f8de881578826312673cebe; Path=/</span><br><span class="line">&lt; Set-Cookie: l_cap_id=&quot;OTlmZjM4OGQ4YzEyNDkwNmJjMzQxM2NiZThlOGY3MDI=|1465799312|380fb662f09187c07ae84e38dc694197feae1f09&quot;; Domain=zhihu.com; expires=Wed, 13 Jul 2016 06:28:32 GMT; Path=/</span><br><span class="line">&lt; Set-Cookie: cap_id=&quot;NDZhN2I5ZmM0ZjZlNGQxOWI4MDhkZTg0ZTZlMTU1ZDA=|1465799312|fc2935c8732a53b5216bbffebbceed1cf179f5ab&quot;; Domain=zhihu.com; expires=Wed, 13 Jul 2016 06:28:32 GMT; Path=/</span><br><span class="line">&lt; Set-Cookie: n_c=1; Domain=zhihu.com; Path=/</span><br><span class="line">&lt; Pragma: no-cache</span><br><span class="line">&lt; X-Frame-Options: DENY</span><br><span class="line">&lt; X-Req-ID: 43CAD096575E5290</span><br><span class="line">&lt; Vary: Accept-Encoding</span><br><span class="line">&lt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="4-HTTP动词"><a href="#4-HTTP动词" class="headerlink" title="4. HTTP动词"></a>4. HTTP动词</h3><p>Http的动词有，GET,POST,PUT,DELETE等<br>    curl -X [动词] [URL]</p>
<p>curl默认的动作为 <code>GET</code></p>
<h4 id="3-1-FORM-GET请求"><a href="#3-1-FORM-GET请求" class="headerlink" title="3.1 FORM GET请求"></a>3.1 FORM GET请求</h4><pre><code>curl [-X GET] zeusjava.com/articles?article_id=1
</code></pre>
<h4 id="3-2-FORM-POST请求"><a href="#3-2-FORM-POST请求" class="headerlink" title="3.2 FORM POST请求"></a>3.2 FORM POST请求</h4><pre><code>curl -X POST --data[-urlencode] &quot;article_id=1&quot; zeusjava.com
</code></pre>
<p>如果需要对表单参数进行编码的话，在–data后再加上-urlencode选项</p>
<h3 id="5-使用Cookies"><a href="#5-使用Cookies" class="headerlink" title="5. 使用Cookies"></a>5. 使用Cookies</h3><pre><code>curl --cookie &quot;key=value&quot; [URL]
</code></pre>
<p>cookie是客户端保存的服务端的一些信息,形式为key-value键值对，可以从Server的response的<code>Set-Cookie</code>中获得</p>
<p>使用 <code>-c</code> 选项，可以保存服务器的cookie到本地的文件中</p>
<pre><code>curl -c [cookies file] [URL]
</code></pre>
<p>比如我保存 知乎的cookie到本地的cookies中</p>
<pre><code>curl -c cookies.txt http://www.zhihu.com
</code></pre>
<p>得到的cookies.txt如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Netscape HTTP Cookie File</span><br><span class="line"># http://curl.haxx.se/docs/http-cookies.html</span><br><span class="line"># This file was generated by libcurl! Edit at your own risk.</span><br><span class="line"></span><br><span class="line">.zhihu.com	TRUE	/	FALSE	0	l_n_c	1</span><br><span class="line">.zhihu.com	TRUE	/	FALSE	1557273691	q_c1	5130907cc98041298bb4a42fafa2fe5d|1462665691000|1462665691000</span><br><span class="line">www.zhihu.com	FALSE	/	FALSE	0	_xsrf	f3e5105c5196dffc93c5eefcbb1d2b55</span><br><span class="line">.zhihu.com	TRUE	/	FALSE	1465257691	cap_id	&quot;ZWQ2ZDIyNmQ2NjZjNDNjYzg1Y2QyZjE3ZjU5ZGM1YWY=|1462665691|258e372f45b5610e483a25bfa3dde1debd56ca08&quot;</span><br><span class="line">.zhihu.com	TRUE	/	FALSE	1465257691	l_cap_id	&quot;NjMxYTliZGVkOWZlNDBmZDhjY2M2M2VjY2Y1MDQ0YTI=|1462665691|878a16bb3c5376f14a0d837c19db994c66b6b668&quot;</span><br><span class="line">.zhihu.com	TRUE	/	FALSE	0	n_c	1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>-b</code>选项，将本地的cookies文件发送至服务器端</p>
<pre><code>curl -b cookies.txt http://www.zhihu.com
</code></pre>
<h3 id="6-使用User-Agent"><a href="#6-使用User-Agent" class="headerlink" title="6.使用User-Agent"></a>6.使用User-Agent</h3><blockquote>
<p>User Agent：字面意思就是用户代理，可以简单理解为访问设备的一种标识（这个标识指所代表的平台（黑莓、iPhone、Windows等）、浏览器（Chrome、IE、Safari等）、以及浏览器的版本等等），其实它包含的信息是比较多的。</p>
</blockquote>
<p>下面是一个User-Agent的例子:</p>
<pre><code>Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36
</code></pre>
<p>Mozilla声明了一个基于Mozilla的浏览器User-Agent，比如firefox,netscape等,Windows NT 10.0表示操作系统为 <code>Windows 10</code>等</p>
<pre><code>curl -A [User-Agent] [URL]
curl --user-agent &quot;[User-Agent]&quot; [URL]
</code></pre>
<p>很多网站都会根据浏览器的User-Agent来响应不同的页面风格，叫做响应式设计，比如ipad请求 <code>www.zhihu.com</code>浏览器就会根据ipad的页面尺寸来适配ipad的屏幕大小。</p>
<h3 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7.文件上传"></a>7.文件上传</h3><p>使用curl来模拟表单的文件上传</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&#x27;multipart/form-data&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;upload.do&quot;</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">&quot;headimage&quot;</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span> =<span class="string">&quot;click&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击上传&quot;</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>　　$ curl –form headimage&#x3D;@localfile –form click&#x3D;点击上传 [URL]
　　</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>当然curl的命令不止这么多，用到哪些在做补充 &#x3D;&#x3D;</p>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>linux/curl</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型【译】</title>
    <url>/2016/05/17/java-memory-model/</url>
    <content><![CDATA[<p>本文翻译自 <a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">Java Memory Model</a>旨在加深自己对Java Memory Model (JMM)的理解。</p>
<blockquote>
<p>The Java memory model specifies how the Java virtual machine works with the computer’s memory (RAM).<br>The Java virtual machine is a model of a whole computer so this model naturally includes a memory model - AKA the Java memory model.<br>It is very important to understand the Java memory model if you want to design correctly behaving concurrent programs.<br>The Java memory model specifies how and when different threads can see values written to shared variables by other threads, and how to synchronize access to shared variables when necessary.<br>The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5. This version of the Java memory model is still in use in Java 8.</p>
</blockquote>
<p>Java内存模型详述了java虚拟机如何与物理机的RAM的一起工作的，<br>java虚拟机是整个计算机的模型，所以这个模型自然包括内存模型，这个模型卡就是Java内存模型。<br>如果你想正确的设计并发程序，知道Java内存模型是非常重要的<br>java内存模型详解了多个不同的线程是何时而又如何写入一个共享的变量的，还有如何同步的访问一个共享变量。<br>原来的Java内存模型是不足的，所以Java内存模型在java 5中重新修订了，这个版本的java内存模型一直在Java8中还在使用。</p>
<h2 id="内部的java内存模型"><a href="#内部的java内存模型" class="headerlink" title="内部的java内存模型"></a>内部的java内存模型</h2><blockquote>
<p>The Java memory model used internally in the JVM divides memory between thread stacks and the heap. This diagram illustrates the Java memory model from a logic perspective:</p>
</blockquote>
<span id="more"></span>


<p>Java内存模型将JVM的内存按照线程栈和堆进行分割，下面的图表从逻辑的视图展示了Java内存模型：<br>![enter description here][<a href="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png]">http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png]</a>  </p>
<blockquote>
<p>Each thread running in the Java virtual machine has its own thread stack.<br>The thread stack contains information about what methods the thread has called to reach the current point of execution. I will refer to this as the “call stack”. As the thread executes its code, the call stack changes.<br>The thread stack also contains all local variables for each method being executed (all methods on the call stack). A thread can only access it’s own thread stack.<br>Local variables created by a thread are invisible to all other threads than the thread who created it. Even if two threads are executing the exact same code,<br>the two threads will still create the local variables of that code in each their own thread stack. Thus, each thread has its own version of each local variable.<br>All local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads.<br>One thread may pass a copy of a pritimive variable to another thread, but it cannot share the primitive local variable itself.<br>The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.).<br>It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap.</p>
</blockquote>
<p>每一个运行在JVM上的线程都有自己的线程栈，<br>线程栈中包含了线程当前执行点的方法的详细信息，我想这个称之为<code>调用栈</code>,当线程执行了代码，调用栈就发生了变化。<br>线程栈中也包含了所有的正在执行方法（所有在在调用栈中的方法）的局部变量，一个线程只能访问<code>自己的线程栈</code>。<br>被线程创建的本地变量对于其他的线程来说是<code>不可见</code>的,即使两个线程执行同样的代码，这两个线程仍然会在自己的线程栈上创本地变量。<br>所有的原始类型（ boolean, byte, short, char, int, long, float, double）的本地变量全部存储在自己的线程栈中对其他线程不可见，一个线程可以传递一个原始类型的变量给其他线程，但是不能和其他线程共享原始类型的变量。<br>堆中包含了你的java程序中的所有的对象，不管是由哪个线程创建的对象，其中包含了原始类型对应的Wrapper类（Byte, Integer, Long etc），<br>不管一个对象是被分配给一个局部变量还是成员变量，这个对象都仍旧保存在<code>堆</code>上。</p>
<blockquote>
<p>Here is a diagram illustrating the call stack and local variables stored on the thread stacks, and objects stored on the heap:</p>
</blockquote>
<p>下面是一个图表说明了在线程栈中保存的调用栈，局部变量和在堆中保存的所有对象。<br>![enter description here]<a href="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png]">http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png]</a></p>
<blockquote>
<p>A local variable may be of a primitive type, in which case it is totally kept on the thread stack.<br>A local variable may also be a reference to an object. In that case the reference (the local variable) is stored on the thread stack, but the object itself if stored on the heap.<br>An object may contain methods and these methods may contain local variables. These local variables are also stored on the thread stack, even if the object the method belongs to is stored on the heap.<br>An object’s member variables are stored on the heap along with the object itself. That is true both when the member variable is of a primitive type, and if it is a reference to an object.<br>Static class variables are also stored on the heap along with the class definition.<br>Objects on the heap can be accessed by all threads that have a reference to the object. When a thread has access to an object, it can also get access to that object’s member variables.<br>If two threads call a method on the same object at the same time, they will both have access to the object’s member variables, but each thread will have its own copy of the local variables.</p>
</blockquote>
<p>一个局部变量可能是原始类型的，这种情况下，它将完全保存在线程栈上<br>一个局部变量也可能引用一个对象，这个中情况下引用（该局部变量）将会被存储在<code>线程栈</code>中，而<code>被引用的对象</code>将会被存储在<code>堆</code>上。<br>一个对象可能包含多个方法，而这些方法也可能包含局部变量，这些局部变量也将会保存在<code>线程栈</code>上，即使该方法所属的对象是存在<code>堆</code>上的。<br>一个对象的成员变量和对象本身一起被存放在<code>堆</code>上，<code>不管</code>成员变量是<code>基本数据类型</code>的还是<code>引用数据类型</code>的。<br>静态成员变量将会和类定义一起被保存在<code>堆</code>上。<br>在堆上保存的对象可以被所有和这个对象有引用关系的线程访问，当一个线程有权访问一个对象，那么这个线程也能够访问这个对象的成员变量。<br>当两个线程<code>同时</code>调用同一个对象的某个方法，他们将<code>同时拥有</code>该对对象的<code>成员变量</code>的访问权，但是每个线程将会有一份<code>局部变量</code>的<code>副本</code>。</p>
<blockquote>
<p>Here is a diagram illustrating the points above:</p>
</blockquote>
<p>下图说明上述观点：<br>![enter description here][<a href="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png]">http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png]</a></p>
<blockquote>
<p>Two threads have a set of local variables. One of the local variables (Local Variable 2) point to a shared object on the heap (Object 3).<br>The two threads each have a different reference to the same object.<br>Their references are local variables and are thus stored in each<br>thread’s thread stack (on each). The two different references point to the same object on the heap, though.<br>Notice how the shared object (Object 3) has a reference to Object 2 and Object 4 as member variables (illustrated by the arrows from Object 3 to Object 2 and Object 4).<br>Via these member variable references in Object 3 the two threads can access Object 2 and Object 4.<br>The diagram also shows a local variable which point to two different objects on the heap. In this case the references point to two different objects (Object 1 and Object 5), not the same object.<br>In theory both threads could access both Object 1 and Object 5, 但是上图中的两个线程都只有两个对象中的一个的引用。<br>if both threads had references to both objects. But in the diagram above each thread only has a reference to one of the two objects.</p>
</blockquote>
<p>两个线程都各自一个局部变量的集合，其中的一个局部变量（Local Variable 2）只想了堆上的一个共享对象（Object 3），<br>两个线程对同一个对象有不同的引用。<br>他们的引用都是局部变量并且都被存在自己的<code>线程栈</code>上，尽管两个引用只想堆上的同一个对象。<br>注意到共享对象（<code>Object 3</code>）对 <code>Object 2</code> 和 <code>Object 4</code> 有作为成员变量的引用关系（Object 3指向Object 2和Object 4的箭头）。<br>通过在Object 3 中引用成员变量，这两个线程可以访问<code>Object 2</code>和<code>Object 4</code></p>
<p>上图也展示了一个指向堆上不同对象的局部变量，这种情况下引用指向了对上的不同对象（Object 1 和Object 5）而不是同一个对象，<br>理论上讲，如果两个各对象都有两个对象的引用的话是可以访问Object 1和Object 5</p>
<blockquote>
<p>So, what kind of Java code could lead to the above memory graph? Well, code as simple as the code below:</p>
</blockquote>
<p>所以，什么样的Java 代码可以解释上面的内存图，代码简单如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        methodOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">localVariable1</span> <span class="operator">=</span> <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">MySharedObject</span> <span class="variable">localVariable2</span> <span class="operator">=</span></span><br><span class="line">            MySharedObject.sharedInstance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... do more with local variables.</span></span><br><span class="line"></span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">localVariable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... do more with local variable.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySharedObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static variable pointing to instance of MySharedObject</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MySharedObject</span> <span class="variable">sharedInstance</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MySharedObject</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//member variables pointing to two objects on the heap</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Integer</span> <span class="variable">object2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">22</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Integer</span> <span class="variable">object4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="variable">member1</span> <span class="operator">=</span> <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="variable">member1</span> <span class="operator">=</span> <span class="number">67890</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If two threads were executing the run() method then the diagram shown earlier would be the outcome. The run() method calls methodOne() and methodOne() calls methodTwo().<br>methodOne() declares a primitive local variable (localVariable1 of type int) and an local variable which is an object reference (localVariable2).<br>Each thread executing methodOne() will create its own copy of localVariable1 and localVariable2 on their respective thread stacks.<br>The localVariable1 variables will be completely separated from each other, only living on each thread’s thread stack.<br>One thread cannot see what changes another thread makes to its copy of localVariable1.</p>
</blockquote>
<p>如果两个方法同时执行 <code>run()</code>方法，run()方法调用<code>methodOne()</code>然后 <code>methodOne()</code>调用 <code>methodTwo()</code><br><code>methodOne()</code> 声明了一个基本数据类型的局部变量（int类型 localVariable1）和一个引用数据类型的局部变量（localVariable2）<br>每一个线程在执行<code>methodOne()</code>时将会创建 <code>localVariable1</code> 和<code>localVariable2</code>的副本在各自的线程栈。<br>局部变量 <code>localVariable1</code> 将会和其他的变量分割开来，仅仅存活在自己线程的线程栈中。<br>线程不能够看到其他线程对<code>localVariable1</code>变量副本做出的改变。</p>
<blockquote>
<p>Each thread executing methodOne() will also create their own copy of localVariable2.<br>However, the two different copies of localVariable2 both end up pointing to the same object on the heap.<br>The code sets localVariable2 to point to an object referenced by a static variable.<br>There is only one copy of a static variable and this copy is stored on the heap.<br>Thus, both of the two copies of localVariable2 end up pointing to the same instance of MySharedObject which the static variable points to.<br>The MySharedObject instance is also stored on the heap. It corresponds to Object 3 in the diagram above.<br>Notice how the MySharedObject class contains two member variables too. The member variables themselves are stored on the heap along with the object.<br>The two member variables point to two other Integer objects. These Integer objects correspond to Object 2 and Object 4 in the diagram above.<br>Notice also how methodTwo() creates a local variable named localVariable1. This local variable is an object reference to an Integer object.<br>The localVariable1 reference will be stored in one copy per thread executing methodTwo().<br>The method sets the localVariable1 reference to point to a new Integer instance.<br>The two Integer objects instantiated will be stored on the heap, but since the method creates a new Integer object every time the method is executed, two threads executing this method will create separate Integer instances.<br>The Integer objects created inside methodTwo() correspond to Object 1 and Object 5 in the diagram above.<br>Notice also the two member variables in the class MySharedObject of type long which is a primitive type.<br>Since these variables are member variables, they are still stored on the heap along with the object. Only local variables are stored on the thread stack.</p>
</blockquote>
<p>每个线程执行<code>methodOne()</code>时也将会创建它们各自的localVariable2拷贝。<br>然而，两个<code>localVariable2</code>的不同拷贝都指向堆上的同一个对象。<br> 代码中通过一个静态变量设置<code>localVariable2</code>指向一个对象引用。<br> 仅存在一个静态变量的一份拷贝，这份拷贝存放在堆上。<br> 因此，<code>localVariable2</code>的两份拷贝都指向由<code>MySharedObject</code>指向的静态变量的同一个实例。<br> <code>MySharedObject</code>实例也存放在堆上。它对应于上图中的<code>Object3</code>。<br>注意，<code>MySharedObject</code>类也包含两个成员变量，这些成员变量随着这个对象存放在堆上。<br>这两个成员变量指向另外两个<code>Integer</code>对象。这些Integer对象对应于上图中的<code>Object2</code>和<code>Object4</code>.<br>注意，<code>methodTwo()</code>创建一个名为localVariable的本地变量。这个成员变量是一个指向一个Integer对象的对象引用。<br>这个方法设置localVariable1引用指向一个新的Integer实例。<br>在执行<code>methodTwo</code>方法时，<code>localVariable1</code>引用将会在每个线程中存放一份拷贝。<br>这两个Integer对象实例化将会被存储堆上，但是每次执行这个方法时，这个方法都会创建一个新的Integer对象，两个线程执行这个方法将会创建两个不同的Integer实例。<br><code>methodTwo()</code>方法创建的Integer对象对应于上图中的<code>Object1</code>和<code>Object5</code>。<br>注意，MySharedObject类中的两个<code>long</code>类型的成员变量是<code>原始类型</code>的。<br>因为，这些变量是成员变量，所以它们任然随着该对象存放在堆上，仅有本地变量存放在线程栈上。</p>
<h2 id="硬件的内存架构（TODO）"><a href="#硬件的内存架构（TODO）" class="headerlink" title="硬件的内存架构（TODO）"></a>硬件的内存架构（TODO）</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java工程师（后端）技能树</title>
    <url>/2016/06/02/java-skill-tree/</url>
    <content><![CDATA[<p>我的Java技能树点亮之路</p>
<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><p>脱离于语言之上的一些不变的知识</p>
<ol>
<li>设计模式，重构，Clean Code ，代码大全，Unix编程艺术</li>
<li>算法导论什么的就算了，但是至少得学会实现《数据结构》上的集中最基本的数据结构，java实现</li>
<li>理解 SOA面向服务架构</li>
</ol>
<h2 id="工具加成"><a href="#工具加成" class="headerlink" title="工具加成"></a>工具加成</h2><p>让自己的开发工具从小刀变成</p>
<ol>
<li>Linux &amp;shell &amp;vim</li>
<li>Ngix</li>
<li>工具类 google guava, apache-commons</li>
<li>构建工具maven,gradle</li>
<li>Web容器 tomcat</li>
<li>版本控制git</li>
<li>java8新特性</li>
<li>mysql&amp;mariadb 数据库进阶，慢查询，数据库引擎，索引</li>
<li>熟悉Http，《图解HTTP》</li>
<li>了解使用noSql，mongodb<span id="more"></span></li>
</ol>
<h2 id="Java进阶"><a href="#Java进阶" class="headerlink" title="Java进阶"></a>Java进阶</h2><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><ol>
<li>熟悉NIO&amp;OIO</li>
<li>熟悉一个NIO框架，我选Netty</li>
<li>熟悉JDK java.util.concurrent包的类，BlockQueue,CocurrentHashMap,Semaphore等</li>
<li>再读一遍《Java并发编程》</li>
<li>深入理解Java内存模型</li>
</ol>
<h3 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h3><ol>
<li>熟悉GC的原理</li>
<li>JVM相关工具使用以及调优</li>
<li>读完《深入Java虚拟机》,并实践</li>
<li>ClassLoader相关深入理解</li>
<li>动态代理，Cglib使用</li>
</ol>
<h3 id="一些框架"><a href="#一些框架" class="headerlink" title="一些框架"></a>一些框架</h3><ol>
<li>分布式缓存memcached</li>
<li>消息队列ActiveMq实现原理以及使用&amp;JMS的使用</li>
<li>深入Spring相关，Spring Boot等</li>
<li>RPC框架Dubbo</li>
<li>深入Mybatis,实现原理，缓存使用等</li>
</ol>
<h3 id="云相关"><a href="#云相关" class="headerlink" title="云相关"></a>云相关</h3><ol>
<li>Zookeeper，在linux上部署</li>
<li>Hadoop</li>
<li>Hive</li>
</ol>
<h2 id="Java之外"><a href="#Java之外" class="headerlink" title="Java之外"></a>Java之外</h2><ol>
<li>学习一门动态语言：Ruby,体会Ruby元编程</li>
<li>使用Rails实现自己的项目</li>
<li>作为Java开发者，Scala自然不能少</li>
<li>学习开源项目 Apache旗下的， Thrift，Tomcat、Mina等</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/skill_tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO创建步骤</title>
    <url>/2016/07/18/java-nio-start/</url>
    <content><![CDATA[<p>NIO创建过程<br>一、打开ServerSocketChannel,用于监听客户端的连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">acceptSvr</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
<p>二、绑定监听端口，设置连接为非阻塞模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">acceptSvr.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(InetAddress.getByName(<span class="string">&quot;IP&quot;</span>),port));</span><br><span class="line">accptSvr.configureBlocking(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>三、创建Reactor线程，创建多路复用器并启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReactorTask</span>()).start();</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>四、将ServerSocketChannel 注册到Reactor线程的多路多路复用器Selector上，监听ACCEPT事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> acceptorSvr.register(selector,SelectionKey.OP_ACCEPT,ioHandler);</span><br></pre></td></tr></table></figure>

<p>五、多路复用器在线程run方法中无限循环体内轮询准备就绪的Key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> seletor.select();</span><br><span class="line"><span class="type">Set</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.selectedKeys();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> (SelectionKey)it.next();</span><br><span class="line">    <span class="comment">//处理IO事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>六、多路复用器监听到新的客户端接入，处理新的接入请求，完成TCP三次握手，简历物理链路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> svrChannel.accpet();</span><br></pre></td></tr></table></figure>

<p>七、设置客户端链路为非阻塞模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(flase);</span><br><span class="line">channel.socket().setReuseAddress(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>八、将新接入的客户端连接注册到Reactor线程的多路复用器上，监听读操作，用来读取客户端发送的网络消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> soccketChannel.register(selector,SelectionKey.OP_READ,ioHandler);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>九、异步读取客户端请求消息到缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readNumber</span> <span class="operator">=</span> channel.read(reaceivedBuffer);</span><br></pre></td></tr></table></figure>
<p>十、对ByteBuffer进行编解码，如果有半包消息指针reset，继续读取后续保温，将解码成功的消息封装成task，投递到业务线程池中，进行业务逻辑编排。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemain())&#123;</span><br><span class="line">    byteBuffer.mark();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">message</span> <span class="operator">=</span> decode(byteBuffer);</span><br><span class="line">    <span class="keyword">if</span>(message == <span class="literal">null</span>)&#123;</span><br><span class="line">        byteBuffer.reset();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    messageList.add(message);</span><br><span class="line">    <span class="keyword">if</span>(!byteBuffer.hasRemain())&#123;</span><br><span class="line">        byteBuffer,clear();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        byteBuffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(messageList != <span class="literal">null</span> &amp; !messageList.isEmpty)&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object messageE:messageList)&#123;</span><br><span class="line">            handlerTask(messageE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>十一、将POJO对象encode 成ByteBuffer ,调用SocketChannel的异步write接口，将消息异步发送给客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">socketChannel.write(buffer);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/nio</tag>
      </tags>
  </entry>
  <entry>
    <title>Java List实现group by</title>
    <url>/2016/08/22/list-group-by-guava/</url>
    <content><![CDATA[<p>一般情况下我们可能很熟悉在数据库中使用group by来分组一些数据，但是如果数据来源不是数据库的话可能就需要通过在代码中实现group by了</p>
<p>例子：比如有一组书Book的集合,我们要按照书的类型(type)分组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增加几本书到list</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List &lt;Book&gt; bookList =Arrays.asList(</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;java programming&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">123.1D</span>),</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;java in concurrency&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">123.2D</span>),</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;c++ primary&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="number">123.3D</span>),</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;groovy in action&quot;</span>,<span class="string">&quot;groovy&quot;</span>,<span class="number">123.4D</span>),</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;effective java&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">123.5D</span>),</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;jvm in practice&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="number">123.6D</span>),</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;scala in action&quot;</span>,<span class="string">&quot;scala&quot;</span>,<span class="number">123.7D</span>)</span><br><span class="line">         );</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="使用传统的java来实现group-by"><a href="#使用传统的java来实现group-by" class="headerlink" title="使用传统的java来实现group by"></a>使用传统的java来实现group by</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,List&lt;Book&gt;&gt; bookMapOld = Maps.newLinkedHashMap();</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;Book&gt; iterator = bookList.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> book.getType();</span><br><span class="line">    <span class="keyword">if</span>(bookMapOld.containsKey(type))&#123;</span><br><span class="line">        bookMapOld.get(type).add(book);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        List&lt;Book&gt; bookList2 = Lists.newLinkedList();</span><br><span class="line">        bookList1.add(book);</span><br><span class="line">        bookMapOld.put(type,bookList1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用guava来的multiMap来实现group-by"><a href="#使用guava来的multiMap来实现group-by" class="headerlink" title="使用guava来的multiMap来实现group by"></a>使用guava来的multiMap来实现group by</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multimaps.asMap(Multimaps.index(bookList, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Book, String&gt;() &#123;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Book input)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> input.getType();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用java-8来实现group-by"><a href="#使用java-8来实现group-by" class="headerlink" title="使用java 8来实现group by"></a>使用java 8来实现group by</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,List&lt;Book&gt;&gt;bookMap =  bookList1.stream().collect(Collectors.groupingBy(b-&gt;b.getType(),Collectors.mapping((Book b)-&gt;b,Collectors.toList())));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用groovy来实现group-by"><a href="#使用groovy来实现group-by" class="headerlink" title="使用groovy来实现group by"></a>使用groovy来实现group by</h2><p>groovy 使用closure来实现groovy by</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Map bookMap = bookList1.groupBy&#123;it.getType()&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/guava</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Btrace来跟踪调试代码</title>
    <url>/2016/09/10/use-btrace-to-trace-java-program/</url>
    <content><![CDATA[<p>有的时候在写程序的时候可能有些地方的日志没有照顾到，产生了bug，如果到了线上环境，有时候不得不停掉服务重新来加入日志来查看产生bug的地方，这个时候Btrace就派的上用场了，在VisualVM中可以很方便的调试目标程序，而对原有项目没有影响，当然也可以不用VisualVM而使用命令行来实现这个功能。<br>Btrace是一个开源项目，项目托管在github上</p>
<p>使用VisualVM的Btrace插件最为方便，下面就写个小例子来熟悉一下</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.在<a href="https://visualvm.java.net/download.html">visualvm官网</a>下载visualVM可视化工具<br>2.依次点击visualVM菜单栏的<code>Tool-&gt;plugins</code>打开插件窗口，选择  <code>Btrace workBench</code> 然后一路 next安装</p>
<h3 id="目标程序"><a href="#目标程序" class="headerlink" title="目标程序"></a>目标程序</h3><p>  准备了一个简单的小程序：从键盘接收两个数字然后计算两个数字之和，主要目的是方便下一步用Btrace来调试打印出方法的参数的值，以及堆栈信息</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xuan.trace;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xuan on 2016/9/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTraceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        BTraceTest traceTest= <span class="keyword">new</span> <span class="title class_">BTraceTest</span>();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            reader.readLine();</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span>  <span class="operator">=</span> (<span class="type">int</span>)Math.round(Math.random()*<span class="number">1000</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span>  <span class="operator">=</span> (<span class="type">int</span>)Math.round(Math.random()*<span class="number">1000</span>);</span><br><span class="line">            System.out.println(traceTest.add(a,b));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="跟踪程序"><a href="#跟踪程序" class="headerlink" title="跟踪程序"></a>跟踪程序</h3><p>运行第二步中的小程序，在VisualVM中选中这个虚拟机进程，然后右键<code>Trace application</code>进入到Btrace选项卡<br>在文本框中输入调试的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* BTrace Script Template */</span></span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TracingScript</span> &#123;</span><br><span class="line">	  <span class="meta">@OnMethod(clazz=&quot;org.xuan.trace.BTraceTest&quot;,method=&quot;add&quot;,location=@Location(Kind.RETURN))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="meta">@Self</span> org.xuan.trace.BTraceTest instance,<span class="type">int</span> a,<span class="type">int</span> b,<span class="meta">@Return</span> <span class="type">int</span> result)</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;打印堆栈:&quot;</span>);</span><br><span class="line">        jstack();</span><br><span class="line">        println(strcat(<span class="string">&quot;方法参数A：&quot;</span>,str(a)));</span><br><span class="line">        println(strcat(<span class="string">&quot;方法参数B：&quot;</span>,str(b)));   </span><br><span class="line">        println(strcat(<span class="string">&quot;方法返回C：&quot;</span>,str(result)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击<code>run</code>按钮，如果调试代码没错的话,控制台会输出编译通过的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* Starting BTrace task</span><br><span class="line">** Compiling the BTrace script ...</span><br><span class="line">*** Compiled</span><br><span class="line">** Instrumenting 1 classes ...</span><br><span class="line">*** Done</span><br><span class="line">** BTrace up&amp;running</span><br></pre></td></tr></table></figure>

<p>然后在程序的控制台输入一个字符，程序会给出两个参数以及方法的返回值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">打印堆栈:</span><br><span class="line">org.xuan.trace.BTraceTest.add(BTraceTest.java:12)</span><br><span class="line">org.xuan.trace.BTraceTest.main(Unknown Source)</span><br><span class="line">方法参数A：628</span><br><span class="line">方法参数B：461</span><br><span class="line">方法参数C：1089</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的互斥锁和读写锁</title>
    <url>/2016/11/26/lock-in-java/</url>
    <content><![CDATA[<p>在JDK5之前，访问共享对象的时候使用的机制只有<code>synchronized</code>和<code>volatile</code> ，JDK5的并发包里提供了一种新的更加高级的机制：互斥锁ReentrantLock，显式锁是为了弥补内置锁的方法而开发的，两者是互补的关系，显式锁并不能代替内置锁。<br>ReentrantLock实现了一种标准的互斥锁，亦即每次最多有一个线程能够持有ReentrantLock</p>
<h2 id="Lock接口-amp-ReentrantLock简介"><a href="#Lock接口-amp-ReentrantLock简介" class="headerlink" title="Lock接口&amp;ReentrantLock简介"></a>Lock接口&amp;ReentrantLock简介</h2><p>concurrent包中的Lock类定义了一组抽象的加锁操作，如下代码所示，与synchronized不同的是，Lock提供了一种<code>无条件</code>、<code>可轮询</code>、<code>定时</code>、<code>可中断</code>的锁获取操作，所有的加锁和解锁操作都是显示的<br>ReentrantLock实现了Lock接口，提供了与synchronized相同的互斥性以及内存可见性。与synchronized一样，ReentrantLock提供了可重入（即可以被单个线程多次获取）的加锁语义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ReentrantLock的使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">...</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用显示锁的时候一定要在finally块中释放锁，否则如果代码中一旦出现异常，那么可能这个锁永远都无法释放就会造成某个对象的状态不一致，如果是账户余额或者别的重要的信息可能就会出现很严重的事故。</p>
<span id="more"></span>
<h2 id="与内置锁的区别"><a href="#与内置锁的区别" class="headerlink" title="与内置锁的区别"></a>与内置锁的区别</h2><h3 id="可轮询及定时的锁"><a href="#可轮询及定时的锁" class="headerlink" title="可轮询及定时的锁"></a>可轮询及定时的锁</h3><p>在内置锁中，一旦出现死锁，唯一的办法就是重启服务，ReentrantLock使用tryLock()方法来实现可轮询的或者定时的锁，如果一次不能获得全部的锁，那么通过可定时或者轮询的锁可以重新获得控制权，它会释放已经获得的锁然后重新获取所有的锁，如果在指定的时间内没有获取到所有的锁，那么就返回失败。<br>如下例子，通过tryLock()来避免锁顺序死锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferMoney</span><span class="params">(Account fromAcc,Account toAcc,Amount amount,<span class="type">long</span> timeout,TimeUnit timeUnit)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="variable">fixeDelay</span> <span class="operator">=</span> getFixDelayNanos(timeout,timeUnit); <span class="comment">//固定的时间</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">ranMod</span> <span class="operator">=</span> getRandomDelayNanos(timeout,timeUnit); <span class="comment">//随机的时间</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">stopTime</span> <span class="operator">=</span> System.nanoTime() + timeUnit.toNanos(timeout);</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fromAcc.lock.tryLock())&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(toAcc.lock.tryLock())&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fromAcc.getBalance().compareTo(amount)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              fromAcc.debit(amount);</span><br><span class="line">              to.credit(amount);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            toAcc.lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fromAcc.lock.unklock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(System.nanoTime()&lt;stopTime)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    NANOSECONDS.sleep(fixeDelay+rnd.nextLong()%ranMod)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用定时锁，如果在指定的时间内无法获取到锁的话那么将操作失败</p>
<h3 id="可中断的锁获取操作"><a href="#可中断的锁获取操作" class="headerlink" title="可中断的锁获取操作"></a>可中断的锁获取操作</h3><p>使用Lock接口中的lockInterruptibly方法能够在获得锁的同时保持对中断的响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendSharedLine</span><span class="params">(String message)</span> <span class="keyword">throw</span> InterruptedException&#123;</span><br><span class="line">  lock.lockInterruptibly();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cancellableSendOnSharedLine(message);</span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cancellableSendOnSharedLine</span><span class="params">(String message)</span> <span class="keyword">throw</span> InterruptedException&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非块结构的加锁"><a href="#非块结构的加锁" class="headerlink" title="非块结构的加锁"></a>非块结构的加锁</h3><p>synchronized锁的获取和释放的操作都是基于代码块的，虽然这样能够简化代码的编写，降低编码错误的可能性，但是有的时候可能需要更加灵活的加锁规则。<br>降低锁的力度可以提高代码的<code>伸缩性</code>, 在某些情况下，可以将锁分解成对<code>一组独立对象</code>上的锁的的分解，这种技术被称为<code>锁分段</code>，在ConcurrentHashMap中使用了一个包含<code>16</code>个锁的数组，每个锁保护所有散列桶的<code>1/16</code>，  一种第N个散列桶由第<code>N mod 16</code>个锁来保护。如果散列函数合理分布，这样锁的请求就减少到了原来的1&#x2F;16。正是由于锁分段技术，ConcurrentHashMap能够支持多大16个并发的写入器，当然如果并发量足够大的话可以将默认的锁分段数量超过默认的16个。<br>下面的代码块就是ConcurrentHashMap的<code>锁分段</code>的代码，其中能看到Segment是继承与ReentrantLock的，本质上是一把互斥锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2249069246763182397L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">    Segment(<span class="type">float</span> lf) &#123; <span class="built_in">this</span>.loadFactor = lf; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>ReentrantLock的构造函数如下，提供了两种公平性的锁，一种是公平锁，一种是非公平的锁（默认）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在公平锁上，线程按照<code>发出请求</code>的顺序来获得锁，而当线程请求非公平锁时，如果刚好该锁的状态变为可用的话那么久允许这个线程先于队列其他线程获得锁。</p>
<p>公平锁与非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sync object for fair locks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">           acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">        * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由代码可以看到公平锁和非公平都是继承于Sync的而Sync是继承与抽象的AQS（AbstractQueuedSynchronizer）的，AQS是java中锁的抽象类，包含了锁的许多公共方法，是互斥锁(例如，ReentrantLock)和共享锁(例如，Semaphore)的公共父类。<br>可以看到公平锁和非公平锁的不同点在于<code>tryAcquire()</code>方法即获取锁的方式不同。</p>
<p>在大多数情况下，非公平锁的性能要高于公平锁的性能。主要原因是在恢复一个被挂起的线程与线程真正运行之间有很大的延迟。假如现在线程A持有一个锁，线程B请求这个锁，由于A持有这个锁，所以B挂起，当A释放锁的时候B被唤醒，再次尝试获取这个锁，如果在同时有C也请求这个锁，那么有很大可能C会在B<code>完全唤醒前</code>获取这个锁使用以及使用这个锁，当B获得锁的时候，C已经使用完毕并释放锁了，所以吞吐量会有所提高。但是当请求锁的平均时间较长的时候应该使用<code>公平锁</code>。</p>
<h2 id="读写锁-ReadWriteLock-TODO"><a href="#读写锁-ReadWriteLock-TODO" class="headerlink" title="读写锁 ReadWriteLock TODO"></a>读写锁 ReadWriteLock TODO</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/thread</tag>
      </tags>
  </entry>
  <entry>
    <title>清醒思考的艺术</title>
    <url>/2017/01/11/art-of-thinking-clearly/</url>
    <content><![CDATA[<p>大学的时候读过的一本书，当年排行德国非小说类的第一名，现在又抽空读了一遍，感觉获益颇多，每一篇都很简短，用很小的生活中的例子来解释看似很平常的一些思维谬误，<br>这本书有个很好玩的副标题<strong>你最好让别人去犯的52个思维错误</strong>，能感受到作者的诙谐和幽默。作者在前言里就说了，生活中的思维错误是不可能避免的，能够意识到并且尽量在生活中少犯就好了，让我说<br>其实更像是程序的<strong>bug</strong>,是无法避免的，在编程（思考）的时候多加注意就好了。</p>
<h2 id="一、幸存偏误"><a href="#一、幸存偏误" class="headerlink" title="一、幸存偏误"></a>一、幸存偏误</h2><p>幸存偏误指的是，在生活中更容易看到成功，看不到失败，所以会过高的估计自己成功的希望。最常见的例子</p>
<blockquote>
<p>每个成功的人都很努力，所以努力的人都能成功。</p>
</blockquote>
<p>这种就是典型的只看到了成功的人而忽视了那些失败的人。所以作者在文章中提醒我们要<strong>常常逛逛墓地</strong>，看看那些失败者的案例，能够让我们能加清醒的思考。<br><img src="http://ww1.sinaimg.cn/large/787edccfgw1fbn46w05irj20dw0l5abl.jpg"></p>
<h2 id="二、游泳运动员错觉"><a href="#二、游泳运动员错觉" class="headerlink" title="二、游泳运动员错觉"></a>二、游泳运动员错觉</h2><span id="more"></span>

<h2 id="三、纠缠沉默成本"><a href="#三、纠缠沉默成本" class="headerlink" title="三、纠缠沉默成本"></a>三、纠缠沉默成本</h2>]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka入门</title>
    <url>/2017/01/19/simple-kafka-example/</url>
    <content><![CDATA[<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h2><p>kafka依赖zookeeper来调度，以及选举leader，因此需要先安装zookeeper</p>
<h3 id="1-1-安装zookeeper"><a href="#1-1-安装zookeeper" class="headerlink" title="1.1 安装zookeeper"></a>1.1 安装zookeeper</h3><p>点击<a href="http://zookeeper.apache.org/releases.html">下载zookeeper</a>下载合适版本的zookeeper，当前最新的稳定版本是<code>3.4.9</code>创建好数据目录,命名为data，下一步配置用到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> opt/ &amp;&amp; tar -zxf zookeeper-3.4.6.tar.gz  &amp;&amp; <span class="built_in">cd</span> zookeeper-3.4.6</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> data</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-配置zookeeper"><a href="#1-2-配置zookeeper" class="headerlink" title="1.2 配置zookeeper"></a>1.2 配置zookeeper</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi conf/zoo.cfg</span></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/path/to/zookeeper/data</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br></pre></td></tr></table></figure>
<h4 id="1-3-启动zookeeper"><a href="#1-3-启动zookeeper" class="headerlink" title="1.3 启动zookeeper"></a>1.3 启动zookeeper</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/zkServer.sh start</span></span><br></pre></td></tr></table></figure>
<p>相应的停止zookeeper的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/zkServer.sh stop</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-启动zookeeper-CLI"><a href="#1-4-启动zookeeper-CLI" class="headerlink" title="1.4 启动zookeeper CLI"></a>1.4 启动zookeeper CLI</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/zkCli.sh</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="1-2-安装kafka"><a href="#1-2-安装kafka" class="headerlink" title="1.2 安装kafka"></a>1.2 安装kafka</h2><h3 id="1-2-1-下载并解压"><a href="#1-2-1-下载并解压" class="headerlink" title="1.2.1 下载并解压"></a>1.2.1 下载并解压</h3><p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/0.10.1.0/kafka_2.11-0.10.1.0.tgz">点击下载</a>kafka的压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> opt/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxf kafka_2.11-0.10.1.0.tgz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> kafka_2.11-0.10.1.0</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-1-启动和关闭Kafka"><a href="#1-3-1-启动和关闭Kafka" class="headerlink" title="1.3.1 启动和关闭Kafka"></a>1.3.1 启动和关闭Kafka</h3><p>启动kafka</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/kafka-server-start.sh config/server.properties</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关闭kafka</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bin/kafka-server-stop.sh config/server.properties</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-测试单broker"><a href="#2-测试单broker" class="headerlink" title="2.测试单broker"></a>2.测试单broker</h2><p>我的kafka服务创建在Linux虚拟机上，IP地址为：192.168.61.131（按需替换成自己的IP地址），在这里需要配置<code>server.properties</code>文件，将advertised.host.name设置为虚拟机的IP地址 <code>advertised.host.name=192.168.61.131</code>，否则在宿主机上无法访问虚拟机上面的服务</p>
<p>###2.1 使用Shell命令测试topic</p>
<h4 id="2-1-1-创建topic"><a href="#2-1-1-创建topic" class="headerlink" title="2.1.1 创建topic"></a>2.1.1 创建topic</h4><p>在命令行界面kafka目录，输入下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic page_visits</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-测试发布者"><a href="#2-1-2-测试发布者" class="headerlink" title="2.1.2 测试发布者"></a>2.1.2 测试发布者</h4><p>输入以下命令，打开发布消息CLI</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic page_visits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在CLI界面输入，两行测试消息</p>
<pre><code>Hello kafka
你好吗？
</code></pre>
<h4 id="2-1-3-测试订阅者"><a href="#2-1-3-测试订阅者" class="headerlink" title="2.1.3 测试订阅者"></a>2.1.3 测试订阅者</h4><p>输入一下命令打开订阅者CLI</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --zookeeper localhost:2181 --from-beginning --topic page_visits</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果执行正确，会显示刚才发布者发送的两行消息</p>
<p>###2.2 使用Java代码创建Client来发布订阅消息</p>
<p>需要先在pom中添加kafka依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.9.2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmxri<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jmx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.jms<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmxtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jdmk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-创建发布者发布消息"><a href="#2-2-1-创建发布者发布消息" class="headerlink" title="2.2.1 创建发布者发布消息"></a>2.2.1 创建发布者发布消息</h4><p>下面一段代码，会每隔3秒中发布一个测试消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;page_visits&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">events</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;metadata.broker.list&quot;</span>, <span class="string">&quot;192.168.61.131:9092&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;serializer.class&quot;</span>, <span class="string">&quot;kafka.serializer.StringEncoder&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ProducerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProducerConfig</span>(properties);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">Producer</span>&lt;String, String&gt;(config);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">nEvent</span> <span class="operator">=</span> <span class="number">0</span>; nEvent&lt; events; nEvent++)&#123;</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">            KeyedMessage&lt;String,String&gt; data = <span class="keyword">new</span> <span class="title class_">KeyedMessage</span>&lt;String, String&gt;(TOPIC,String.valueOf(nEvent),<span class="string">&quot;Test message from java program &quot;</span> + sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            producer.send(data);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-创建订阅者订阅消息"><a href="#2-2-2-创建订阅者订阅消息" class="headerlink" title="2.2.2 创建订阅者订阅消息"></a>2.2.2 创建订阅者订阅消息</h4><p>下面的代码会绑定到虚拟机长的kafka服务，当发布者发布消息时，订阅者会不断地打印发布者发布的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;page_visits&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>,<span class="string">&quot;192.168.61.131:9092&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;session.timeout.ms&quot;</span>, <span class="string">&quot;30000&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.put(<span class="string">&quot;value.deserializer&quot;</span>,<span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String,String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(properties);</span><br><span class="line">        consumer.subscribe(Arrays.asList(TOPIC));</span><br><span class="line">        System.out.println(<span class="string">&quot;Subscribe to topic &quot;</span>+TOPIC);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            ConsumerRecords&lt;String,String&gt; consumerRecords = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span>(ConsumerRecord&lt;String,String&gt; record: consumerRecords)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d,key = %s,value = %s\n&quot;</span>,record.offset(),record.key(),record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ooo.0o0.ooo/2017/01/19/58807b900a087.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>java/kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>2017阅读计划</title>
    <url>/2017/02/02/reading-in-2017/</url>
    <content><![CDATA[<p>总是等到过完农历的新年才会觉得新的一年才真正的开始，元旦仿佛没有什么卵用，回首过去的一年，有很多收获，同时也有不少遗憾，京东做活动的时候买的书还有好多没有读完，新的一年，新的开始，书要一步一步的读，代码要一字一字得码，希望2017年能够更上一层楼。<br>下面的只是个大概的提纲，没有具体的每天读几页，多少天读完等很严格的规划，因为生活中有很多突发事件会影响自己，公司加班、生病发烧，聚餐啊，跳槽等等…无法预测，用尽一切时间去学：<strong>在地铁上看，在饭后看，睡觉前少看会儿手机多读一会儿书，让心流的时间加长，高效专注的完成之后再休息。</strong></p>
<h2 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h2><p>首先，肯定是要去库存，去年京东做活动买的没读完的书争取在上半年读完。<br><strong>No.1《Redis设计与实现》</strong><br>Redis不仅是一个缓存工具，而且还是一个nosql的实现，性能极其强大，目前<br><strong>No.2《编程珠玑》</strong><br>编程方面的属于元老级别的书吧，修炼自己的内功必备，想吃透这本书我觉得一年都不一定行。<br><strong>No.3《Spring实战》</strong><br>原本是买来给女朋友入门Spring的…我先撸一遍吧，里面的例子还是很清晰的，适合初学者，我更倾向于看<strong>《Spring揭密》</strong>。<br><strong>No.4《Linux命令行与shell脚本编程大全（第3版）》</strong><br>作为一个Java行业从业者，Linux自然是必不可少的，提高自己的Linux姿势水平势在必行。<br><strong>No.5《利用Python进行数据分析》</strong><br>去年读完了《Python基础教程》，还是应该投入实际的用途，学学用Python进行数据分析吧。<br><strong>No.6《高性能Mysql》</strong><br>这个板砖书，还是看电子版的好了，放在ipad里也极其方便，不一定全部看完，但是重要章节一定得看完，而且得熟练，互联网公司必备。<br><strong>No.7《敏捷软件开发原则、模式与实践》</strong><br>再重新读一遍此神书，了解如何编写优雅的代码。</p>
<span id="more"></span>
<h2 id="其他方面"><a href="#其他方面" class="headerlink" title="其他方面"></a>其他方面</h2><p><strong>No.1《设计中的设计》</strong><br>培养自己的审美水平，无印良品总设计师操刀的书，值得一看。<br><strong>No.2《人类简史》</strong><br>仰慕已久的书，历史佳作。<br><strong>No.3《梦的解析》</strong><br>很古老的一本书，心理学著作，希望自己能看的进去。<br><strong>No.4《国富论下》</strong><br>上册看完了，下册岂有不看之理<br><strong>No.5《三体》</strong><br>宏大的科幻奇书，互联网行业必看的，打算在地铁上刷完。<br><strong>No.6《世界简史》</strong><br>就是对历史有所偏爱，看完《人类简史》看世界简史，读史使人明智，称为更好的自己。<br><strong>No.7《必然》</strong><br>看完KK的《失控》，《必然》势在必看。</p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>读书计划</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中将JSON反序列化为泛型对象</title>
    <url>/2017/02/24/json-to-map-include-list/</url>
    <content><![CDATA[<p>将嵌套List的Map转换为Json应该都没什么问题，使用Gson和Jackson都能实现，在Gson中使用<code>new Gson().toJson()</code>方法，在Jackson中使用<code>new ObjectMapper().writeValueAsString()</code>即可。<br>将json转换为形如Map&lt;String,List<Long>&gt;的时候遇到了一点问题，虽然返回类型是<code>Map&lt;String,List&lt;Long&gt;&gt;</code>但是，Map的value的值却并不是<code>List&lt;Long&gt;</code>,而是<code>Integer</code>类型的，这里面显然是有问题的，查看Jackson的源码和Gson的源码发现<br>将json反序列化为对象确实有两个方法，一种适用于泛型对象，一种适用于非泛型的一般对象。</p>
<h3 id="使用Gson"><a href="#使用Gson" class="headerlink" title="使用Gson"></a>使用Gson</h3><p>在gson中将json字符串转反序列化为对象有两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * This method deserializes the specified Json into an object of the specified class. It is not</span></span><br><span class="line"><span class="comment">  * suitable to use if the specified class is a generic type since it will not have the generic</span></span><br><span class="line"><span class="comment">  * type information because of the Type Erasure feature of Java. Therefore, this method should not</span></span><br><span class="line"><span class="comment">  * be used if the desired type is a generic type. Note that this method works fine if the any of</span></span><br><span class="line"><span class="comment">  * the fields of the specified object are generics, just the object itself should not be a</span></span><br><span class="line"><span class="comment">  * generic type. For the cases when the object is of generic type, invoke</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #fromJson(String, Type)&#125;. If you have the Json in a &#123;<span class="doctag">@link</span> Reader&#125; instead of</span></span><br><span class="line"><span class="comment">  * a String, use &#123;<span class="doctag">@link</span> #fromJson(Reader, Class)&#125; instead.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> &lt;T&gt; the type of the desired object</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> json the string from which the object is to be deserialized</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> classOfT the class of T</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> an object of type T from the string. Returns &#123;<span class="doctag">@code</span> null&#125; if &#123;<span class="doctag">@code</span> json&#125; is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> JsonSyntaxException if json is not a valid representation for an object of type</span></span><br><span class="line"><span class="comment">  * classOfT</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fromJson</span><span class="params">(String json, Class&lt;T&gt; classOfT)</span> <span class="keyword">throws</span> JsonSyntaxException &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> fromJson(json, (Type) classOfT);</span><br><span class="line">   <span class="keyword">return</span> Primitives.wrap(classOfT).cast(object);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * This method deserializes the specified Json into an object of the specified type. This method</span></span><br><span class="line"><span class="comment">  * is useful if the specified object is a generic type. For non-generic objects, use</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #fromJson(String, Class)&#125; instead. If you have the Json in a &#123;<span class="doctag">@link</span> Reader&#125; instead of</span></span><br><span class="line"><span class="comment">  * a String, use &#123;<span class="doctag">@link</span> #fromJson(Reader, Type)&#125; instead.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> &lt;T&gt; the type of the desired object</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> json the string from which the object is to be deserialized</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> typeOfT The specific genericized type of src. You can obtain this type by using the</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> com.google.gson.reflect.TypeToken&#125; class. For example, to get the type for</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@code</span> Collection&lt;Foo&gt;&#125;, you should use:</span></span><br><span class="line"><span class="comment">  * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">  * Type typeOfT = new TypeToken&amp;lt;Collection&amp;lt;Foo&amp;gt;&amp;gt;()&#123;&#125;.getType();</span></span><br><span class="line"><span class="comment">  * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> an object of type T from the string. Returns &#123;<span class="doctag">@code</span> null&#125; if &#123;<span class="doctag">@code</span> json&#125; is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> JsonParseException if json is not a valid representation for an object of type typeOfT</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> JsonSyntaxException if json is not a valid representation for an object of type</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fromJson</span><span class="params">(String json, Type typeOfT)</span> <span class="keyword">throws</span> JsonSyntaxException &#123;</span><br><span class="line">   <span class="keyword">if</span> (json == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">StringReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(json);</span><br><span class="line">   <span class="type">T</span> <span class="variable">target</span> <span class="operator">=</span> (T) fromJson(reader, typeOfT);</span><br><span class="line">   <span class="keyword">return</span> target;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>观察<code>fromJson(String json, Class&lt;T&gt; classOfT)</code>的注释：</p>
<blockquote>
<p>It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java</p>
</blockquote>
<p>也就是说，由于Java泛型的擦除机制，这个方法不适用于传入泛型的类，比如<code>Map&lt;String,Long&gt;</code>,<code>List&lt;String&gt;</code>等，这个时候可以用<code>T fromJson(String json, Type typeOfT)</code>替代。</p>
<p>下面还有一段话：</p>
<blockquote>
<p>Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type</p>
</blockquote>
<p>** 注意：** 如果对象不是泛型的，只是字段是泛型的话这个方法是可以使用的</p>
<p>刚开始不太理解这句话，后来想通了，也就是<code>类定义</code>上不能带有泛型比如 <code>public interface Map&lt;K,V&gt;</code> 这样的就不行，但是如果是下面这样的只有域上带有的泛型是可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JsonDemo</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> List&lt;Long&gt; list;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;Long&gt; list)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.list = list;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>下面的<code>fromJson(String json, Type typeOfT)</code>就是专门提供给泛型类的对象使用的，如果你自己反序列化的对象带有泛型的话需要用这个方法。</p>
<h3 id="使用Jackson"><a href="#使用Jackson" class="headerlink" title="使用Jackson"></a>使用Jackson</h3><p>和gson一样，jackson也提供了两个方法，一个适用于普通的类，一个适用于泛型类，只不过jackson源码的注释没有Gson的丰富，从注释上看不出来，功能和Gson的一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Method to deserialize JSON content from given JSON content String.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException if a low-level I/O problem (unexpected end-of-input,</span></span><br><span class="line"><span class="comment">   *   network error) occurs (passed through as-is without additional wrapping -- note</span></span><br><span class="line"><span class="comment">   *   that this is one case where &#123;<span class="doctag">@link</span> DeserializationFeature#WRAP_EXCEPTIONS&#125;</span></span><br><span class="line"><span class="comment">   *   does NOT result in wrapping of exception even if enabled)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> JsonParseException if underlying input contains invalid content</span></span><br><span class="line"><span class="comment">   *    of type &#123;<span class="doctag">@link</span> JsonParser&#125; supports (JSON for default case)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> JsonMappingException if the input JSON structure does not match structure</span></span><br><span class="line"><span class="comment">   *   expected for result type (or has other mismatch issues)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(String content, Class&lt;T&gt; valueType)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, JsonParseException, JsonMappingException</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Method to deserialize JSON content from given JSON content String.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException if a low-level I/O problem (unexpected end-of-input,</span></span><br><span class="line"><span class="comment">   *   network error) occurs (passed through as-is without additional wrapping -- note</span></span><br><span class="line"><span class="comment">   *   that this is one case where &#123;<span class="doctag">@link</span> DeserializationFeature#WRAP_EXCEPTIONS&#125;</span></span><br><span class="line"><span class="comment">   *   does NOT result in wrapping of exception even if enabled)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> JsonParseException if underlying input contains invalid content</span></span><br><span class="line"><span class="comment">   *    of type &#123;<span class="doctag">@link</span> JsonParser&#125; supports (JSON for default case)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> JsonMappingException if the input JSON structure does not match structure</span></span><br><span class="line"><span class="comment">   *   expected for result type (or has other mismatch issues)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(String content, TypeReference valueTypeRef)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, JsonParseException, JsonMappingException</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>
<h3 id="简单实验"><a href="#简单实验" class="headerlink" title="简单实验"></a>简单实验</h3><p>使用两种方式反序列一个json，使用Class来反序列化泛型类型的对象，在<code>printType</code>的时候会出现<code>ClassCastException</code>类型转换异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.type.TypeReference;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> com.google.common.reflect.TypeToken;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhaohongxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonTest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		Map&lt;String, List&lt;Long&gt;&gt; map = Maps.newHashMap();</span><br><span class="line">		map.put(<span class="string">&quot;one&quot;</span>, Arrays.asList(<span class="number">10001L</span>, <span class="number">10002L</span>, <span class="number">10003L</span>, <span class="number">10004L</span>));</span><br><span class="line">		map.put(<span class="string">&quot;two&quot;</span>, Arrays.asList(<span class="number">20001L</span>, <span class="number">20002L</span>, <span class="number">20003L</span>, <span class="number">20004L</span>));</span><br><span class="line">		map.put(<span class="string">&quot;three&quot;</span>, Arrays.asList(<span class="number">30001L</span>, <span class="number">30002L</span>, <span class="number">30003L</span>, <span class="number">30004L</span>));</span><br><span class="line">		map.put(<span class="string">&quot;four&quot;</span>, Arrays.asList(<span class="number">40001L</span>, <span class="number">40002L</span>, <span class="number">40003L</span>, <span class="number">40004L</span>));</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(map);</span><br><span class="line">		System.err.println(<span class="string">&quot;=======================错误示范=====================&quot;</span>);</span><br><span class="line">		<span class="comment">//Gson</span></span><br><span class="line">		Map&lt;String, List&lt;Long&gt;&gt; mapResult  = gson.fromJson(json,Map.class);</span><br><span class="line">		System.out.println(<span class="string">&quot;通过Gson转换...&quot;</span>);</span><br><span class="line"><span class="comment">//		printType(mapResult);</span></span><br><span class="line">		System.out.println(mapResult);</span><br><span class="line">		<span class="comment">//Json</span></span><br><span class="line">		Map&lt;String, List&lt;Long&gt;&gt; jsonMapResult = mapper.readValue(json,Map.class);</span><br><span class="line">		System.out.println(<span class="string">&quot;通过Jackson转换...&quot;</span>);</span><br><span class="line"><span class="comment">//		printType(jsonMapResult);</span></span><br><span class="line"></span><br><span class="line">		System.out.println(jsonMapResult);</span><br><span class="line">		System.out.println(<span class="string">&quot;=======================正确做法=====================&quot;</span>);</span><br><span class="line">		<span class="comment">//Gson</span></span><br><span class="line">		Map&lt;String, List&lt;Long&gt;&gt; mapResult1  = gson.fromJson(json,<span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;Map&lt;String, List&lt;Long&gt;&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">		System.out.println(<span class="string">&quot;通过Gson转换...&quot;</span>);</span><br><span class="line">		printType(mapResult1);</span><br><span class="line">		System.out.println(mapResult1);</span><br><span class="line">		<span class="comment">//Json</span></span><br><span class="line">		<span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">		Map&lt;String, List&lt;Long&gt;&gt; jsonMapResult1 = mapper.readValue(json,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt; Map&lt;String,List&lt;Long&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line">		System.out.println(<span class="string">&quot;通过Jackson转换...&quot;</span>);</span><br><span class="line">		printType(jsonMapResult1);</span><br><span class="line"></span><br><span class="line">		System.out.println(jsonMapResult1);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printType</span><span class="params">(Map&lt;String, List&lt;Long&gt;&gt; map)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Long&gt;&gt; entry: map.entrySet())&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;key 类型:&quot;</span>+entry.getKey().getClass()+<span class="string">&quot;, value类型:&quot;</span></span><br><span class="line">			+entry.getValue().getClass()+<span class="string">&quot;, List中元素类型&quot;</span>+entry.getValue().get(<span class="number">0</span>).getClass());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h3><p>在Gson中：<br>如果使用<code>fromJson(String json, Class&lt;T&gt; classOfT)</code>来反序列化Map的话，不会造成编译错误，返回的类型就会变化，Long类型变成了Double类型,使用的时候就会出现异常，例如在遍历Map的entrySet的时候就会出现异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Long</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>因此：</p>
<ol>
<li>反序列化<code>泛型对象</code>如Map&lt;K,V&gt;等需要使用 <code>fromJson(String json, Type typeOfT)</code></li>
<li>一般对象使用<code>fromJson(String json, Class&lt;T&gt; classOfT)</code><br>在Jackson中：<br>如果使用<code>T readValue(String content, Class&lt;T&gt; valueType)</code>来反序列化Map的话，返回的类型就会由Long类型变成了Integer类型。</li>
<li>反序列化<code>泛型对象</code>如Map&lt;K,V&gt;等需要使用 <code>T readValue(String content, TypeReference valueTypeRef)</code></li>
<li>一般对象使用<code>T readValue(String content, Class&lt;T&gt; valueType)</code></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/serialization</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中final关键字总结</title>
    <url>/2017/04/17/final-in-java/</url>
    <content><![CDATA[<p>final在java中的用法有很多，可以修饰field，可以修饰Method，可以修饰Class，而且final在多线程环境中保证了对象状态的不变性，下面就系统的总结一下Java中final关键字的用法</p>
<h3 id="修饰Variable-x2F-field"><a href="#修饰Variable-x2F-field" class="headerlink" title="修饰Variable&#x2F;field"></a>修饰Variable&#x2F;field</h3><ol>
<li><p>修饰primitive变量，变量一旦赋值就不再可变。</p>
</li>
<li><p>final修饰<code>基本数据类型变量</code>和<code>String类型</code>时，类似于C++的const</p>
</li>
<li><p>3种变量会被隐式的定义为final：<br>3.1. 接口中的field是final的<br>3.2. Java7中出现的try with resource语句中的变量是隐式的final类型,如下面的代码，inputStream虽然未被声明为final，但是如果试图在try块里面重新对inputStream赋值的话，就会产生编译异常，不能给final变量赋值</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;text.txt&quot;</span>))&#123;</span><br><span class="line">inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰引用实例类型变量，变量被赋值后，变量指向的引用的值可以变，但是不能重新指向新的引用，即final只关心引用本身，而不关心final引用的内容。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xuan1&quot;</span>,<span class="number">23</span>);</span><br><span class="line">   System.out.println(user.getAge()); <span class="comment">//输出23</span></span><br><span class="line">   user.setAge(<span class="number">24</span>);</span><br><span class="line">   System.out.println(user.getAge()); <span class="comment">//输出24</span></span><br><span class="line">   user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xuan2&quot;</span>,<span class="number">25</span>); <span class="comment">//编译错误，提示不能赋值给final变量</span></span><br><span class="line">   System.out.println(user.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修饰实例成员变量时，必须在定义的时候初始化：直接赋值，构造器初始化，或代码块中初始化，或的意思是这三种方式只能选择一种，否则编译报错。</p>
</li>
<li><p>修饰静态成员变量时，必须在变量定义的时候初始化：直接赋值，静态代码块中赋值<br> Tips: 有一种特殊情况：<code>System.in,System.out,System.err</code> 是静态域但是没有在定义的时候或者静态代码块中初始化，而是使用了set方法来设置值。</p>
</li>
<li><p>JDK8以前内部类访问外部类的变量时要求变量为Final类型,JDK8之后，只要求外部类为事实不可变变量，不一定要加上final</p>
<span id="more"></span></li>
</ol>
<p>  关于事实不可变final的定义：</p>
<blockquote>
<p>variable or parameter whose value is never changed after it is initialized is effectively final<br>  也就是说变量被初始化之后没有改变过即使没有final，jvm也会把这个变量解释为final类型来对待。</p>
</blockquote>
<p>  下面是官方文档的一个例子：<br>  在内部类PhoneNumber中的构造器中使用外部的numberLength的时候，JDK8之前必须显示定义为final类型，否则编译器将会给出警告，而在JDK8之后并不需要显式声明为final，但是，如果变量在初始化之后被再次赋值的话，就会出现异常了，因为打破了事实不可变的条件，所以在构造器中再次给numberLength赋值为7的时候，JDK8的编译器也给出了错误提示。<br>  同理，在printOriginalNumbers方法中方为外部类的变量<code>phoneNumber1</code>，<code>phoneNumber2</code>的时候JDK8以前的编译器给出错误提示。</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.zhaohongxuan;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhaohongxuan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalClassExample</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">String</span> <span class="variable">regularExpression</span> <span class="operator">=</span> <span class="string">&quot;[^0-9]&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">validatePhoneNumber</span><span class="params">(String phoneNumber1, String phoneNumber2)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">numberLength</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="comment">// Valid in JDK 8 and later:</span></span><br><span class="line">		<span class="comment">// int numberLength = 10;</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">formattedPhoneNumber</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			PhoneNumber(String phoneNumber) &#123;</span><br><span class="line"><span class="comment">//				 numberLength = 7;</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">currentNumber</span> <span class="operator">=</span> phoneNumber.replaceAll(regularExpression, <span class="string">&quot;&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (currentNumber.length() == numberLength)</span><br><span class="line">					formattedPhoneNumber = currentNumber;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					formattedPhoneNumber = <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">public</span> String <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> formattedPhoneNumber;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Valid in JDK 8 and later:</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOriginalNumbers</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Original numbers are &quot;</span>+phoneNumber1+<span class="string">&quot; and &quot;</span>+phoneNumber2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">PhoneNumber</span> <span class="variable">myNumber1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(phoneNumber1);</span><br><span class="line">		<span class="type">PhoneNumber</span> <span class="variable">myNumber2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(phoneNumber2);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Valid in JDK 8 and later:</span></span><br><span class="line"><span class="comment">//        myNumber1.printOriginalNumbers();</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (myNumber1.getNumber() == <span class="literal">null</span>)</span><br><span class="line">			System.out.println(<span class="string">&quot;First number is invalid&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">&quot;First number is &quot;</span> + myNumber1.getNumber());</span><br><span class="line">		<span class="keyword">if</span> (myNumber2.getNumber() == <span class="literal">null</span>)</span><br><span class="line">			System.out.println(<span class="string">&quot;Second number is invalid&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">&quot;Second number is &quot;</span> + myNumber2.getNumber());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">		validatePhoneNumber(<span class="string">&quot;123-456-7890&quot;</span>, <span class="string">&quot;456-7890&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="修饰Method"><a href="#修饰Method" class="headerlink" title="修饰Method"></a>修饰Method</h3><p>Java语言规范中的描述如下：</p>
<blockquote>
<p>A method can be declared final to prevent subclasses from overriding or hiding it.<br>It is a compile-time error to attempt to override or hide a final method.<br>A private method and all methods declared immediately within a final class (§8.1.1.2) behave as if they are final, since it is impossible to override them.<br>At run time, a machine-code generator or optimizer can “inline” the body of a final method, replacing an invocation of the method with the code in its body. The inlining process must preserve the semantics of the method invocation. In particular, if the target of an instance method invocation is null, then a NullPointerException must be thrown even if the method is inlined. A Java compiler must ensure that the exception will be thrown at the correct point, so that the actual arguments to the method will be seen to have been evaluated in the correct order prior to the method invocation.</p>
</blockquote>
<ol>
<li>final修饰方法可以阻止子类覆盖，如果试图覆盖则编译报错</li>
<li><code>private</code> 方法和<code>final</code> 类的方法表现的为final方法的属性，因为无法覆盖他们。  </li>
<li>运行时，JVM会<code>内联final方法</code>，用final方法的代码替换方法的调用，下图是一个简单示例:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">       <span class="type">int</span> x, y;</span><br><span class="line">       <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> &#123; x += dx; y += dy; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Point[] p = <span class="keyword">new</span> <span class="title class_">Point</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; p.length; i++) &#123;</span><br><span class="line">            p[i] = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">            p[i].move(i, p.length-<span class="number">1</span>-i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main方法里的for循环中的Point类中的<code>move方法</code>将会被内联为下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; p.length; i++) &#123;</span><br><span class="line">    p[i] = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">    <span class="type">Point</span> <span class="variable">pi</span> <span class="operator">=</span> p[i];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> p.length-<span class="number">1</span>-i;</span><br><span class="line">    pi.x += i;</span><br><span class="line">    pi.y += j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">Header One</th>
<th align="left">Header Two</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Item One</td>
<td align="left">Item Two</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料：<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.3.3">http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.3.3</a></p>
</blockquote>
<h3 id="修饰Class"><a href="#修饰Class" class="headerlink" title="修饰Class"></a>修饰Class</h3><pre><code>    1. final修饰Class可以防止类被继承
    2. final和abstract不能同时修饰类，因为2者是互斥的。
</code></pre>
<h3 id="final的语义"><a href="#final的语义" class="headerlink" title="final的语义"></a>final的语义</h3><pre><code>    1. Java编译器允许final域缓存在寄存器中而不用重新加载它，如果是非fina域的话，将会被重新加载
    2. final可以确保初始化过程中的安全性，不可变对象时线程安全的，在多个线程中共享这些对象无需同步。
    3. 多线程中，一个对象的final域在一个线程的构造器结束的时候，在另外的线程中可见。java中有很多安全的特点都是依据String类是被设计为final来保证的
</code></pre>
<h3 id="Java内存模型中的final-TODO"><a href="#Java内存模型中的final-TODO" class="headerlink" title="Java内存模型中的final TODO"></a>Java内存模型中的final TODO</h3><p>参考资料：<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5">http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>开始自己的Mac人生</title>
    <url>/2017/06/18/start-programming-with-macbook/</url>
    <content><![CDATA[<p>拥有一台mac应该算是从学生时代的愿望，但是苦于囊中羞涩，工作了之后想买但是自己又下不去狠心去买，618期间本来想入手15款的macbook pro，跟女朋友一说这个事情，她说要买就买最新款的，不差那几个钱，所以昨天就和她一起去南京东路苹果直营店买下了一台2017款的没有touch-bar的13寸MacBook Pro。<br>随手拍两张图：<br><img src="http://upload-images.jianshu.io/upload_images/170138-3c7f92cff23efaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-783fda5da1532238.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p>对于一个程序员，MacBook Pro绝对算是一个物超所值的生产力工具（<code>赚钱工具</code>），类unix的系统为开发提供了友好的开发环境，同时DE的稳定性又比Linux高出一大截。硬件方面，新款MacBook pro的第二代蝴蝶键盘感觉好像再敲击钢板，会有明显的反馈，所以手感还是不错的，但是如果要长期写代码的话，还是需要配一个机械键盘的。屏幕显示细腻，令人爱不释手。</p>
<p>晚上鼓捣了一晚上把电脑的开发环境搭好了，软件清单如下：</p>
<ul>
<li>笔记：<code>evernote</code>+<code>sublime-evernote</code>插件可以在sublime中书写markdown文件并和evernote无缝集合</li>
<li>任务管理：<code>滴答清单</code>，谁用谁知道</li>
<li>命令行：<code>iterm2</code> +<code>zsh</code>+<code>homebrew</code>+<code>tmux</code>+<code>vim</code></li>
<li>词典：欧陆辞典，辞典中应该算很良心的了</li>
<li>软件开发：<code>jdk 8</code>+<code>intellij idea</code>+<code>Datagrip</code>+ <code>Pycharm</code>，基本都是Jetbrains家的，不过换了keymap之后又要重新适应了</li>
<li>编辑器：<code>sublime</code>+<code>Atom</code></li>
<li>接口测试：<code>postman</code></li>
<li>文档：<code>Dash</code>，海量离线文档API，异常强大,<code>calibre</code>用来管理电子书</li>
<li>云存储： <code>坚果云</code>，国内最好用的云盘，存储日常生活的文档资料等绝对够用</li>
</ul>
<p>下面是我安装好的软件截图：<br><img src="http://upload-images.jianshu.io/upload_images/170138-24f5b583f0868329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docky"><br>好的工具有了，接下来的事情就是用好这个工具创造价值，打怪升级了，程序员这条路并不好走，但是却很有趣，最后，感谢女票，很幸运有这么好的女朋友，在生活和工作中给我很多鼓舞和支持，马上就要领证了，希望能和她一起走下去。</p>
<p>就先写着么多吧，继续研究java虚拟机去了。</p>
<p>一些软件参考自这里：<a href="https://jaywcjlove.github.io/awesome-mac/index.zh.html">awesome-mac</a></p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>tools/mac</tag>
      </tags>
  </entry>
  <entry>
    <title>intellij idea中使用javap等JDK工具</title>
    <url>/2017/04/17/intellij-external-tools/</url>
    <content><![CDATA[<p>java工程师平时工作中用到的工具挺多的，比如javap,jstack等，intellij idea 作为宇宙最强java ide idea一样可以帮我们实现这个功能，方法如下：</p>
<p><code>ctrl+alt+s</code>打开设置界面,找到<code>Tool-&gt; External Tools</code> 点击 <code>+</code>来增加一个新的外部工具。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-78fbc6c74f8bc0fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<span id="more"></span>
<p>在tool setting 的Program输入工具的路径，这中间可以插入宏，比如<code>$JDK_PATH$</code>，不需要自己再手动输入jdk的路径了，<br>在Parameters中输入<code>-c $FileClass$</code> ，<code>$FileClass$</code>代表要解析的 class文件,<code>-c</code>代表输出分解后的代码<br>在Workding Directory中输入<code>$OutputPath$</code>,代表项目的输出路径</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-9baca2b1bacea044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在java文件上右键，选择<code>External Tools -&gt; javap</code>就可以输入分解后的代码了，也可以自定义快捷键，比如设置<code>alt+p</code>就可以很方便的使用javap这个工具了，其他的工具和这个类似，都可以很方便的添加到External Tool里<br><img src="http://upload-images.jianshu.io/upload_images/170138-e8d459f2de49deee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java/intellij</tag>
      </tags>
  </entry>
  <entry>
    <title>自律与健康</title>
    <url>/2017/06/29/health-and-self-discipline/</url>
    <content><![CDATA[<blockquote>
<p>自律给我自由</p>
</blockquote>
<p>一直很喜欢Keep启动时splash上这句话，使用Keep这个软件也1年多了，想总结点东西。</p>
<p>其实最早用keep是2015年的8月，只不过那时候Keep还没有跑步的功能，而我也一直在用悦跑圈跑步，整个从2015年7月开始到2016年10月结束，总共运动了1200多公里，体重基本没怎么变化，应该是因为我不忌口的原因，运动量大吃的也多所以不会变瘦。</p>
<p>从16年10月开始从悦跑圈转到了Keep，报名了Keep的健身课程，练习了2个月，基本每天训练时间都大约30分钟，非常喜欢运动后大汗淋漓的感觉，但是跑步渐渐少了，早上起不来去跑步，晚上又要做健身，跑步就逐渐废掉了，2017年开始，渐渐捡起了跑步，虽然频率不高，但是每周总会运动几次，还是很喜欢运动过后的感觉，发发汗，洗洗澡，看书写代码的效率更高。</p>
<p>毕业已经三年，时间真的可怕，对于程序员来说，天天对着电脑，健康真的不能懈怠，该运动的时候就去运动吧，跑步也好，做plank也行，虐虐自己的身体后会爽的不亦乐乎。</p>
<p>仔细想想，习惯真的是很神奇的东西，比如上班，如果你刚开始通勤需要30分钟，那么如果换工作需要1个小时的话你会接受不了，但是如果适应几周之后你就习惯了，觉得自然了，习惯真的很重要，把运动当成一个习惯，而不是一个需要坚持的东西。</p>
<p>用心感受自我，去做每一个动作，去看每一行字，去写每一行代码，强大的自律是为了让自己更加自由的活。</p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>2017年中总结</title>
    <url>/2017/07/14/summary-in-middle-year/</url>
    <content><![CDATA[<p>如约而至的七月，空气里充满了茂盛的味道，狂风、暴雨、烈日、蝉鸣… 分外怀念有暑假的日子。<br>2017年已经过了一半，白天时间开始变短，下半年也逐渐开始了，是时候给自己的上半年总结一下了。总结是为了更好的了解自己的途径，成长也许就在不经意之间就发生了，同时也让下半年的目标更加有动力。总共会在三个维度上总结一下。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>毕业已满三年，都说三年是一个坎，五年又是一个，所以其实感觉也是挺焦虑的，怕自己能力达不到，其实，但是其实和过去的自己比的话，还是成长很多的。<br>工作最重要的事情是成长，在爱屋的一年来，感觉收获了很多，特别是熟悉了很多互联网公司用的产品，以及相关技术，虽然经历了很多不愉快的事情，调了N次作为，换了N次领导以后，我觉得爱屋也许并不适合我，我只想安安静静的写代码，想和厉害的人一起做很好的产品。</p>
<p>在6月份，我经历了面试月，基本天天的节奏就是，复习-面试-总结，循环不断的进行，上海本地的大部分公司基本都被我面过了，饿了么，美团，B站，一号店等…有失误的地方，但是还是收到了不少offer，在总结中才能更好的进步。</p>
<p>魅力惠是属于阿里的一个BU，所以要学的东西还挺多，都是阿里的那一套，很多高性能的中间件，今年下半年的最重要的任务就是深入框架内部学习，在公司工作是一方面，个人成长则是更加重要的事情。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>上半年搬了一次家，有了专属的小窝（之前是合租），在宜家买了拉克边桌、地毯、鞋柜、凳子、衣架等，让房间更加有质感，和女朋友一起拼装家具，打扫房间，贴纸等，很开心，看到一个乱糟糟的房间变成井井有条的房间，感觉很有成就感有木有。</p>
<p>今年剁了好多手，买的东西不少，3月份买了kindle，6月份买了MacBook pro，这两个东西基本都是常常在我身边的东西，kinde解决了在地铁上慢慢长路，mac则让我爱上了触摸板，爱上写作，爱上编程。</p>
<p>春天和爱人一起去周庄、锦溪玩了一圈，很喜欢一起出去玩的感觉，不过以后不能只留下图片，还得多谢谢旅行日记，记录下一些体会感想等。</p>
<p>今年跑步没怎么坚持，只是偶尔会跑跑，健身倒是还行，会跟着Keep进行一些训练，出出汗，感觉和跑步差不多，身体最重要。</p>
<h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><p>618期间又屯了好几本书，够下半年看的了，加上之前买的没看完的书，现在在kindle上已经不囤积很多书了，看完一本再买下一本。其实上半年基本没读什么新的技术书，都是看以前的旧书，有些经典值得读N遍，比如java并发编程，重构等…</p>
<h4 id="看过的书"><a href="#看过的书" class="headerlink" title="看过的书"></a>看过的书</h4><ol>
<li>黑客与画家（kindle）</li>
<li>Java高并发程序设计</li>
<li>必然</li>
<li>失乐园（kindle，上面好多性描写很直白，看的我在地铁上好尴尬）</li>
<li>大型网站系统与java中间件实践</li>
<li>未来简史(kindle)</li>
<li>巨婴国(kindle)</li>
</ol>
<h4 id="正在看的书"><a href="#正在看的书" class="headerlink" title="正在看的书"></a>正在看的书</h4><ol>
<li>Netty实战</li>
<li>Java编程思想</li>
<li>数据结构与算法分析Java描述</li>
<li>Java虚拟机规范</li>
<li>Python核心编程</li>
<li>傲慢与偏见</li>
<li>思考的艺术</li>
<li>Java8实战</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有的时候很焦虑，是因为不能沉下心来看一本书，看着好多东西要学，总是会发憷，如果不去想那么多，书一点一点看，不和别人比只和过去的自己比，只要能看到自己的进步，就好了，想得多自己还累，上半年看了一些书，去了一些地方，收获了一些东西。<br><img src="http://upload-images.jianshu.io/upload_images/170138-bb464f323a25d36f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom优秀package列表（持续更新）</title>
    <url>/2017/07/31/my-atom-packages/</url>
    <content><![CDATA[<p>Atom,VSCode 都属于Electronic 构建的跨平台编辑器,Atom 属于Github，VSCode属于Microsoft，两个的开源软件在社区里都挺活跃，Sublime也挺好用的，特别是速度，完爆Atom，VSCode 速度要比Atom快不少，那为啥要用Atom呢<br>因为Sublime在Windows上字体渲染惨不忍睹，特别是在25寸2k显示器上，字体大就发虚，所以在我的mac上sublime还是挺好用的，但是在windows上如果不是编辑大的文件（Atom打开大的文本兼职坑爹），在不讲速度的前提下，我也不用sublime，都用Atom，毕竟颜值即正义。</p>
<p>下面是我自己平时用的好用的Package列表：</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h2 id="file-icons"><a href="#file-icons" class="headerlink" title="file-icons"></a>file-icons</h2><p>让你的侧边栏和Tab更加美观，为每种文件类型都绘制了精美的图标，甩默认的好几条街。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-af44e038752f1e14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="file-icons"></p>
<h2 id="Sublime-Style-Column-Selection"><a href="#Sublime-Style-Column-Selection" class="headerlink" title="Sublime Style Column Selection"></a>Sublime Style Column Selection</h2><p>Atom默认没有Block选择的功能，但是别怕，已经有包实现了这个功能，Sublime Style Column Selection 这个包可以让你像EditPlus一样编辑<code>块文本</code>，在windows下面按住<code>alt</code>然后鼠标选择就可以选择区块文件了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-a19affacc6e0c145.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sublime Style Column Selection"></p>
<h2 id="minimap"><a href="#minimap" class="headerlink" title="minimap"></a>minimap</h2><p>预览所有的代码</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-91f3e24d8111a900.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="pretty-json"><a href="#pretty-json" class="headerlink" title="pretty-json"></a>pretty-json</h2><p>正如其名，美化json，比如你从服务器日志上copy下来的json报文，可以用它一键美化，也可以反向将Json压缩成一行。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-73374a243ad02b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="highlight-selected"><a href="#highlight-selected" class="headerlink" title="highlight-selected"></a>highlight-selected</h2><p>双击的时候高亮你选择的单词，如果此单词在该文件中已经有了 也都会被高亮显示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-e75dfaa117082b20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p>在Atom内运行代码，必备Package</p>
<h2 id="Python-Autocomplete"><a href="#Python-Autocomplete" class="headerlink" title="Python Autocomplete"></a>Python Autocomplete</h2><p><img src="http://upload-images.jianshu.io/upload_images/170138-ec183bdc8802bed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>python自动提示，写python必备。</p>
<h3 id="linter-pycodestyle"><a href="#linter-pycodestyle" class="headerlink" title="linter-pycodestyle"></a>linter-pycodestyle</h3><p>记得先pip 安装pycodestyle插件然后再安装atom package 要不然一点击保存就会报错。<br>安装的时候Atom会提示你其他的必须包，一起安装了就好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pycodestyle</span><br></pre></td></tr></table></figure>
<h3 id="Python-Tools"><a href="#Python-Tools" class="headerlink" title="Python Tools"></a>Python Tools</h3><p>快捷键<code>ctrl+alt+u</code>显示当前变量被调用的地方<br>快捷键<code>ctrl+alt+g</code>显示定义的地方</p>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>tools/atom</tag>
      </tags>
  </entry>
  <entry>
    <title>秋</title>
    <url>/2017/10/24/remember-autumn/</url>
    <content><![CDATA[<p>昨天是二十四节气的霜降，这才感觉到秋天的已经快要离我而去，因为霜降接下来就是立冬了，晚上出去跑步已经不能穿短袖短裤了，秋天，这个收获的季节，我收获了什么果实，我在想…</p>
<p>最近工作上的事情把自己压得够呛，从国庆节过来开始到现在，每天都保持在基本后半夜才能回家，而且回家还得在电脑面前工作一段时间，得到2点多才能睡觉，感觉身心俱疲，好在每件事情都会有个结局，这半个月来的折腾也让自己学到了好多东西，包括整个供应链的业务流程，以及里面的一些技术上的细节，有些东西如果自己看的话没有那么容易就看会，但是如果有东西逼着你看，逼着你学，那时候可能就学会了。</p>
<p>这段时间自己还在一直坚持运动，Keep上连续运动已经2个多月了，这是我最想感谢自己的地方，下下周就要参加杭州马拉松了，争取这两周也要多跑几次热热身，每天的锻炼也是必不可少的。</p>
<p>从8月来体重大约减下去了大约10斤，因为是从8月开始坚持晚上吃少点，如果是在公司吃的话就吃沙拉，如果没有沙拉的话就只吃菜，不吃米饭，感觉挺好的，晚上也不会饿，如果晚上运动的话，可能运动完会吃一点水果，我也没有刻意去控制自己的饮食，周末的时候该吃肉还是会炖肉吃，但是体重确是实打实的减下去了，十一放假回家的时候，妈妈说我瘦了，脸瘦了一圈，希望自己能继续加油，把自己的小肚子减下去。</p>
<p>看了美剧《冰与火之歌》并且成功把女票拉下水和我一起看，还有《白夜追凶》，从来不看犯罪悬疑恐怖的女票也看得津津有味，感觉自己特别有成就感。</p>
<p>编程上面，Python学习感觉平时够用了，但是高阶的东西，还是掌握不够，Java方面学习了Netty这个框架，不过感觉需要再做个项目巩固一下，另一方面也是锻炼自己，Java编程思想快撸一遍了，里面有好多关于Java的细节，真的很好，也让自己对Java有更加深刻的认识。在公司可以接触到很多外接不能接触到的中间件技术，希望自己能够加把劲，在工作之余，多多研究技术的实现，以及源码，让自己的能力水平更进一步，以后才能独当一面。</p>
<p>2017年已经过去了297天，还剩下两个月的时间，不得不感叹时间真的很容易流失，注意力特别容易被乱七八糟的东西吸引，看看2017年年初定下的目标，还有相当一部分还没有实现，真的感觉特别打脸，计划如果不去实践又有什么意义。</p>
<p>种一棵树最好的时间是十年前，其次是现在，过去的日子都过去吧，从现在开始，一切都还不太晚。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-24eb3a7adedc1e56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>2017年总结</title>
    <url>/2018/01/09/summery-2017/</url>
    <content><![CDATA[<p>业务上，从刚开始对供应链几乎没什么了解，到现在基本上熟悉了供应链的各个环节，包括订单的正逆向流转的各个环节，库存包括一件货物的生命周期整个流转过程，采购到退仓，一退二退三退等，供应商部分:供应商入住，框架合同，品牌授权等。业务上能够及时向相关接口人咨询相关问题，通过代码反推业务逻辑的方式来熟悉整个业务流程，总结沉淀了订单履约相关的文档，熟悉了scm审批流的开发，以及解决遇到的各种问题。</p>
<p>技术上，也没有懈怠过，在业余时间研究学习了tmf框架以及hsf框架的源代码，窥探框架的演变过程，以及里面所用到的设计模式，或者反模式，吸收良好的编程思想，当然这是个很复杂而又漫长的过程，而且学来为所用也需要假以时日，但是学习的过程是不能停止的。生命不止，编程不息。<br>最近也有在看一些书，比如《Kafka技术内幕》，《Netty实战》，《Fluet  Python》等都是很好的书，慢慢一点点的吃透。</p>
<p>生活上，最主要是规律的坚持运动，从一个160斤的胖子变了一个140多斤的胖子，参加了1次杭州马拉松，很享受运动的过程，以后还会一直继续。</p>
<p>个人的规划方面，最近几年肯定都是以技术为主，而且也喜欢技术，喜欢折腾，最近3年之内肯定都是增强自己的技术水平。当然也不只是全是技术，人生也不只是技术，大部分情况下，技术是靠业务驱动的，没有业务，技术一毛钱不值，必须是掺了业务的技术，虽然个人的努力在整个浪潮之下作用不大，而且无法改变整体局势。未来的方向一定是对某个业务很熟悉 ，然后对相关业务的，技术的整个架构，甚至底层都很熟悉，我觉得这样也很酷。追求程序的自动化，配置化，健壮性，高吞吐等，当然也要跟上时代的潮流学习AI技术，万一以后AI时机真的成熟了，说不定真的不需要一堆一堆的前后端程序员了呢，一切皆有可能，时常保留一点危机意识，大厂程序员是螺丝钉，小厂程序员干杂活，这话不假，当然如果一味的自己拧螺丝未免单调了些，如果能够发现拧螺丝的之外的过程，熟悉每一个步骤，在懂了how之后再问个what，最后在问个why，如果每个问题自己都能够这样的解决了，那么你就不只是一个螺丝钉了，环境会有一些因素，关键在个人。</p>
<p>对于scm团队的建议：</p>
<ol>
<li>可以进行code review，互相review，能够尽可能少的降低低级bug的产生</li>
<li>技术分享，每隔一段时间，都准备一项技术或者一个功能展开一次分享活动，只有在讲述的过程中才会知道自己有哪些不足。</li>
<li>可以多组织活动，聚餐、烧烤、徒步旅行等，增强联络感情</li>
</ol>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>【程序员摄影】之世博公园</title>
    <url>/2018/02/06/photograpy-in-shanghai/</url>
    <content><![CDATA[<p>立春这一天本程序狗带着相机出门采风了，因为刚买的相机有点小兴奋。出了门才发现上海的冬天真不是盖的，天上的太阳仿佛是假的一般，冻的人瑟瑟发抖。<br>风有点大，公园人不多，偶尔来个人也是跑步的，拿着我的fijifilm xt20随手拍的，感觉我仿佛买的事是假相机，照片跟手机拍的一样。</p>
<p>下面的照片都是直出，没有经过后期处理，还需要多加学习呀。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-1fc54c20425b20ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"><br> <span id="more"></span><br><img src="http://upload-images.jianshu.io/upload_images/170138-1801984beb325a3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-20fcf4b13193e74f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-bda684775be5f71a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-c7c62bd8d086efc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-7e175229048beb28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-97c2dd112e404a4d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-c9cf9c13db18531c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-017771ca252796ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"><br><img src="http://upload-images.jianshu.io/upload_images/170138-e1f25fe090891b7a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-91ac33404e5fbe1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-e913560ae942a0c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-07d1643239b782fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/170138-f09f0daf48ff8612.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="图片发自简书App"></p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>年的味道</title>
    <url>/2018/02/23/new-year-2018/</url>
    <content><![CDATA[<p>年越来越近，年味却越来越淡了。</p>
<p>上小学的时候，放寒假的那一天，全体师生总要开个大会，期末考试的颁奖礼仪结束后，校长会强调一下假期里的安全事项，然后大声宣布放假了，那一瞬间，年就开始了。</p>
<p>寒假总是比暑假要舒服，因为寒假作业要更薄一点，过年还能吃到平时不能吃的东西，穿崭新的衣服，崭新的球鞋，新衣服还一定要在大年初一穿，现在想来应该算是一种仪式吧。新衣服一般都是集市上十几块或者几十块一身的衣服，从一年级到五年级，从公安制服到警察制服到小西装，流行穿什么我们就买什么，一到过年，一到大年初一，大街上跑的都是穿公安或者警察衣服的小孩子。下面还必须配一双帅气的足球鞋，一般是十几块的样子，下跑起来倍儿快。</p>
<p>想起来最幸福的事情莫过于和爸妈一起去赶集了，倒不是说集上有多好玩，只不过是因为在路上可以奢侈一把，买一个很酥的油饼。还会买对联，买几挂鞭炮，一般叫精装大地红。一千响或者两千响，后来可能是五千响的。我呢就偷偷的把大地红上面的炮仗一个一个小心拆下来，不过我也不敢全拆，一挂鞭上拆点，然后收集起来，几百个揣到兜里面，然后点一根香，在野外的田地里，沟渠旁，一个一个的放，扔到水里，放到砖缝里，扔到酒瓶里。。。这一切现在看来毫无意义，当时能玩一天乐此不疲。</p>
<p>我一般都喜欢把寒假作业都写完了，再出去玩，因为这样玩的时候就不用想寒假作业的事情，才能痛痛快快的玩。天气好的时候就搬个凳子在太阳下面写寒假作业，冬天的阳光晒着很是舒服。</p>
<p>升初中之后，过年肯定不能像小学那样了，过年的时候会跑到游戏厅打游戏，过一把不良少年的瘾。</p>
<p>到高中的时候，过年也就十几天的样子，过完年得赶紧回到学校继续用功读书，生怕自己考不上大学。过年的时候会赶庙会，看烟火，唱唱KTV等。</p>
<p>有些时候，觉得过去的时间会永远湮没在尘埃里，但是偶尔一个瞬间，一些记忆片段会浮现在眼前，虽然飘渺，不能触摸，但是却让人热泪盈眶。因为我们再也不能回到从前，作一个风度翩翩的此间少年。</p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Manjaro Linux + i3wm心得</title>
    <url>/2018/07/28/manjaro-i3wm/</url>
    <content><![CDATA[<blockquote>
<p>所有的熟悉都是从陌生开始的。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/170138-7fa4639e3b56da27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在使用3个月<code>manjaro linux +i3wm</code>之后我打算写一篇文章来记录一下心得,首先说一下，这篇文章并不是教程，只是分享一下使用心得。在这几个月使用期间，从刚开始的懵，到最后熟练使用效率大大提升，以至于使用gnome 或者windows桌面的时候各种不适应<br>接下来会分成两部分来写，第一部分是<code>manjaro linux</code>，第二部分是<code>i3wm</code>。</p>
<h2 id="一、基于arch的manjaro-linux"><a href="#一、基于arch的manjaro-linux" class="headerlink" title="一、基于arch的manjaro linux"></a>一、基于arch的manjaro linux</h2><p>在使用Manjaro之前使用了大约1个月时间的Deepin Linux，界面确实很华丽漂亮，但是在Deepin的下面很多界面会有卡顿的感觉，比如启动器界面，以及多任务切换的时候，还有一个重要原因：我的蓝牙耳机 Fiil Diva 连上之后断断续续，基本不能用，而在Manjaro下面可以完美使用。<br> <span id="more"></span> </p>
<h3 id="1-1-常用软件"><a href="#1-1-常用软件" class="headerlink" title="1.1 常用软件"></a>1.1 常用软件</h3><h4 id="1-1-1-开发工具"><a href="#1-1-1-开发工具" class="headerlink" title="1.1.1 开发工具"></a>1.1.1 开发工具</h4><ul>
<li>java开发环境 使用yarout 终于可以拜托了debian系列繁琐的配置了，只需要无脑 <code>yaourt</code></li>
<li>intellij idea java开发必备</li>
<li>switchhosts 切换各个开发环境的hosts</li>
<li>vscode  </li>
<li>postman</li>
<li>sublime 基本上就使用vscode了，然而在编辑一些文本的时候vscode还是会卡顿，这个时候就要祭出sublime text了</li>
<li>xfce-terminal 我选择使用<code>xfce-terminal</code> 而不是<code>uvxrt</code>的原因是因为简单，而且字体展示更加优美，还可以方便的设置背景透明</li>
</ul>
<h4 id="1-1-2-日常使用"><a href="#1-1-2-日常使用" class="headerlink" title="1.1.2 日常使用"></a>1.1.2 日常使用</h4><ul>
<li>scrot 截屏软件</li>
<li>virtualbox 虚拟机，不管怎么样，在linux里面，虚拟机还是需要的，因为一些办公软件必须在windows下面才能使用。</li>
<li></li>
</ul>
<h3 id="1-2-命令行工具"><a href="#1-2-命令行工具" class="headerlink" title="1.2 命令行工具"></a>1.2 命令行工具</h3><h4 id="1-2-1-命令行文件管理：ranger"><a href="#1-2-1-命令行文件管理：ranger" class="headerlink" title="1.2.1 命令行文件管理：ranger"></a>1.2.1 命令行文件管理：ranger</h4><p><img src="https://upload-images.jianshu.io/upload_images/170138-6d4299cc09c0aba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="1设置代理"><a href="#1设置代理" class="headerlink" title="1设置代理"></a>1设置代理</h4><p>作为一个程序员，命令行上面有些资源难免要出墙，如果不用代理网速有些资源可能是龟速，比如<code>yaourt</code>某些软件的时候。如果你使用ss作为代理，可以使用alias给命令行设置代理。使用setproxy给命令行设置全局代理，使用完成之后在使用<code>unsetproxy</code>来取消代理。<br>可以把下面三句话放到你的 <code>.zshrc</code>里面，这样随时随地就都能使用了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias setproxy=&quot;export ALL_PROXY=socks5://127.0.0.1:1080&quot;</span><br><span class="line">alias unsetproxy=&quot;unset ALL_PROXY&quot;</span><br><span class="line">alias ip=&quot;curl -i http://ip.cn&quot;</span><br></pre></td></tr></table></figure>

<h2 id="二、-i3wm"><a href="#二、-i3wm" class="headerlink" title="二、 i3wm"></a>二、 i3wm</h2><p>在使用i3wm之前，我知道的linux桌面有 <code>gnome</code>,<code>cinnamon</code>,<code>kde</code>,<code>xfce</code>等，对了还有国产的<code>dde</code>，这些桌面都有一个特点，就是和windows类似的，浮动窗口管理器，一个窗口可以浮在另外一个窗口上面，所以要在多个窗口间切换，则需要使用 <code>alt+tab</code>来回切换<br>如果窗口少还好，如果窗口多的话，来回切换会非常繁琐，直到遇到了 平铺式窗口管理器i3wm。<br>i3wm的所有窗口都平铺在桌面上，可以按照你的需求平铺或堆叠。初学起来可能配置麻烦，但是一点点熟悉下来会发现熟悉了根本离不开了，就如开头说的那样，所有的熟悉都是从陌生开始的。<br>放一张截图：<br><img src="https://upload-images.jianshu.io/upload_images/170138-6c0349ecc8ea9419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2018-08-02-145643_3640x1920_scrot.png"></p>
<p>关于i3wm的配置，就不写太多了，就推荐一个视频教程就够了<br>教程地址：<a href="https://www.youtube.com/watch?v=j1I63wGcvU4&list=PL5ze0DjYv5DbCv9vNEzFmP6sU7ZmkGzcf">i3wm configuration</a><br>附上我的配置文件地址：<a href="https://github.com/zhaohongxuan/dot_files/tree/master/i3">https://github.com/zhaohongxuan/dot_files/tree/master/i3</a></p>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>linux/manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>React 组件参数传递</title>
    <url>/2018/09/06/react-tranfer-variable/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/170138-94373511a5284ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="一、父组件向子组件传值"><a href="#一、父组件向子组件传值" class="headerlink" title="一、父组件向子组件传值"></a>一、父组件向子组件传值</h3><p>父组件向子组件传值直接使用<code>props</code>进行传值，比如下面<code>Root</code>想要传值给<code>Left</code>,父组件<code>Root</code>里面直接引用子组件<code>Left</code>，并且通过组件的属性<code>name</code>传递给子组件，子组件在自己的内部，直接使用<code>this.props.name</code>来获取传递过来的值。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Left</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   <span class="title function_">construct</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">greeting</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Left</span> <span class="attr">msg</span>=<span class="string">&quot;I came From Left &quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Root</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>代码演示地址：<a href="https://codepen.io/javaor/pen/dqzRvQ">https://codepen.io/javaor/pen/dqzRvQ</a></p>
<h3 id="二、子组件向父组件传值"><a href="#二、子组件向父组件传值" class="headerlink" title="二、子组件向父组件传值"></a>二、子组件向父组件传值</h3><p>子组件向父组件与父组件给子组件传值类似，假如组件<code>Right</code>要传值给<code>Root</code>,<br><code>Root</code>将传递一个函数<code>greeting</code>给子组件<code>Right</code>，子组件<code>Right</code>调用该函数，将想要传递的信息，作为参数，传递到父组件的作用域中。<br>函数将保障子组件<code>Right</code>在调用 greeting函数时，其内部 this 仍指向父组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Right</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;   </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">greeting</span>(<span class="string">&#x27;Hello From Right&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>I&#x27;m right<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">greeting</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Msg From Right: &#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Right</span> <span class="attr">greeting</span>=<span class="string">&#123;msg</span> =&gt;</span> this.greeting(msg)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Root</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>代码演示地址：<a href="https://codepen.io/javaor/pen/WgEOdG?editors=1011">https://codepen.io/javaor/pen/WgEOdG?editors=1011</a><br>###三、兄弟节点之间的传值<br>假设<code>Right</code>想要向<code>Left</code>传递参数，因为他们之间没有之间关联的节点，只有一个公共的父组件<code>Root</code>，所以只能通过<code>Right</code>先向<code>Root</code>传值，然后在通过props从<code>Root</code>向<code>Left</code>传值。基本第二个基本上一致，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Left</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Right</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;   </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">greeting</span>(<span class="string">&#x27;Hello From Right&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>I&#x27;m right<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">greeting</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Right</span> <span class="attr">greeting</span>=<span class="string">&#123;msg</span> =&gt;</span> this.greeting(msg)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Left</span> <span class="attr">msg</span>=<span class="string">&#123;this.state.msg&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Root</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>javacript/react</tag>
      </tags>
  </entry>
  <entry>
    <title>让Alfred3支持iterm2</title>
    <url>/2018/11/19/mac-alfred3-iterm2/</url>
    <content><![CDATA[<p>alfred设置中选择<code>Terminal/Shell</code>，Application选择custom<br><img src="https://upload-images.jianshu.io/upload_images/170138-bd4f2a0ffd10fc3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<span id="more"></span>
<p>然后在下面的框中填入下面代码：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- This is v0.7 of the custom script for AlfredApp for iTerm 3.1.1+</span></span><br><span class="line"><span class="comment">-- created by Sinan Eldem www.sinaneldem.com.tr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">on</span> alfred_script(q)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">application</span> <span class="string">&quot;iTerm2&quot;</span> <span class="keyword">is</span> <span class="built_in">running</span> <span class="keyword">or</span> <span class="built_in">application</span> <span class="string">&quot;iTerm&quot;</span> <span class="keyword">is</span> <span class="built_in">running</span> <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">run script</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">			on run &#123;q&#125;</span></span><br><span class="line"><span class="string">				tell application \&quot;iTerm\&quot;</span></span><br><span class="line"><span class="string">					activate</span></span><br><span class="line"><span class="string">					try</span></span><br><span class="line"><span class="string">						select first window</span></span><br><span class="line"><span class="string">						set onlywindow to true</span></span><br><span class="line"><span class="string">					on error</span></span><br><span class="line"><span class="string">						create window with default profile</span></span><br><span class="line"><span class="string">						select first window</span></span><br><span class="line"><span class="string">						set onlywindow to true</span></span><br><span class="line"><span class="string">					end try</span></span><br><span class="line"><span class="string">					tell the first window</span></span><br><span class="line"><span class="string">						if onlywindow is false then</span></span><br><span class="line"><span class="string">							create tab with default profile</span></span><br><span class="line"><span class="string">						end if</span></span><br><span class="line"><span class="string">						tell current session to write text q</span></span><br><span class="line"><span class="string">					end tell</span></span><br><span class="line"><span class="string">				end tell</span></span><br><span class="line"><span class="string">			end run</span></span><br><span class="line"><span class="string">		&quot;</span> <span class="keyword">with</span> parameters &#123;q&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">run script</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">			on run &#123;q&#125;</span></span><br><span class="line"><span class="string">				tell application \&quot;iTerm\&quot;</span></span><br><span class="line"><span class="string">					activate</span></span><br><span class="line"><span class="string">					try</span></span><br><span class="line"><span class="string">						select first window</span></span><br><span class="line"><span class="string">					on error</span></span><br><span class="line"><span class="string">						create window with default profile</span></span><br><span class="line"><span class="string">						select first window</span></span><br><span class="line"><span class="string">					end try</span></span><br><span class="line"><span class="string">					tell the first window</span></span><br><span class="line"><span class="string">						tell current session to write text q</span></span><br><span class="line"><span class="string">					end tell</span></span><br><span class="line"><span class="string">				end tell</span></span><br><span class="line"><span class="string">			end run</span></span><br><span class="line"><span class="string">		&quot;</span> <span class="keyword">with</span> parameters &#123;q&#125;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> alfred_script</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>tools/iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年终小结</title>
    <url>/2018/12/31/2018-summarize/</url>
    <content><![CDATA[<p>春夏秋冬，四季变迁，轮回更迭，无人能阻挡时间的脚步，留下些许文字聊表慰藉。</p>
<h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><h3 id="开发技能"><a href="#开发技能" class="headerlink" title="开发技能"></a>开发技能</h3><h4 id="1-学习并学会使用React"><a href="#1-学习并学会使用React" class="headerlink" title="1.学习并学会使用React"></a>1.学习并学会使用React</h4><p> 作为一个后端开发者，前端的知识其实算是有点壁垒的，期初学起来并不容易，奈何工作中需要用到fusion，而fusion是基于React的（现已开源），所以硬着头皮学了下来，目前也写一点简单的组件，太复杂的也不太行，以后还有提升空间。</p>
<h4 id="2-跟着-Andrew-NG学习机器学习"><a href="#2-跟着-Andrew-NG学习机器学习" class="headerlink" title="2. 跟着 Andrew NG学习机器学习"></a>2. 跟着 Andrew NG学习机器学习</h4><p>网易云课堂上面的免费公开课地址：<a href="https://study.163.com/course/courseMain.htm?courseId=1004570029">吴恩达机器学习</a><br>不得不说吴恩达老师讲的是特别的好，连我这种菜鸟都能听得懂，高数、线性代数、概率论这一众知识算是重新捡回来了，从简单的线性回归到逻辑回归，正规方程到梯度下降等，从分类算法到神经网络算法等，但是感觉依然只是皮毛，能实际应用还有点距离。</p>
<h4 id="3-看HSF的源码"><a href="#3-看HSF的源码" class="headerlink" title="3.看HSF的源码"></a>3.看HSF的源码</h4><p>HSF是集团没有开源的，比起Dubbo和gRPC性能要高出很多，源码啃起来很难，尤其是在业余时间不多的情况下，深入到轮子内部才知道原来轮子这么复杂。</p>
<span id="more"></span>
<p>###生产力工具 </p>
<ol>
<li>PhotoShop的简单使用，简单的修图</li>
<li>Illustrator的使用，绘制简单的矢量图，图标。</li>
<li>Lightroom调色</li>
</ol>
<h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><h3 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h3><blockquote>
<p>千里之行，始于足下</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/170138-921ac0a0390cb5a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2018运动总结"></p>
<p>每天最艰难的其实不是跑步本身，而是早晨挣脱温暖的被窝的那股勇气。在打败早起的拦路虎后，挡在你面前的是<code>极点</code>，几乎每个跑者都会遇到，长里程跑遇到极点会极其难受，脚步很重，感觉就像背着大石头在跑，但是只要你克服了它接下来终将会赢得这个挑战。遇到极点的时候，我经常是在想，再跑100米，再跑100米，给自己打气，在跑完结束时的成就感和放松的感觉真的是没有体会过的人无法体会的。<br>使用Keep来记录跑步，记录心情，现在看来 新年的第一次跑步真的是元气满满。</p>
<ol>
<li><p>从元旦那天的跑步开始算起，今年已经跑了1800公里了，平均每个月跑量150km,也就是平均每天5km。</p>
</li>
<li><p>买了两双跑鞋，一双亚瑟士 kayano 24，一双阿迪达斯 ultra boost4，总结 ub穿起来比亚瑟士要舒服，亚瑟士偏硬，ub踩屎感更强。</p>
</li>
<li><p>完成1个全程马拉松–苏州马拉松，完成3个半程马拉松，第一个是端午节在马路上跑的，第二个是在泰国普吉岛跑的，第三个是在跑步机上跑的。<br><img src="https://upload-images.jianshu.io/upload_images/170138-c6f5806c1230cad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雨中苏马"></p>
</li>
<li><p>还没有跑步机的时候下雨天不能出去跑步心里会很痒痒，自从买了跑步机之后每一天都跑步，感觉已经和跑步分不开了。</p>
</li>
</ol>
<h3 id="骑行"><a href="#骑行" class="headerlink" title="骑行"></a>骑行</h3><ol>
<li>完成一次滴水湖骑行，总里程126km</li>
<li>完成一次淀山湖骑行，总里程153km</li>
<li>今年骑行距离达到了1013km</li>
</ol>
<h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><ol>
<li>累计平板撑时间达到10h，累计俯卧撑达到1000个，不完全统计有很多没有计算。</li>
<li>累计健身时间达到了15883分钟,相当于264个小时</li>
</ol>
<h2 id="摄影"><a href="#摄影" class="headerlink" title="摄影"></a>摄影</h2><p>自从18年1月份买了相机以来，基本上算是入坑了，花在摄影上的时间确实多了，18年的每个月都有照片留下，买相机的初衷就是要留下时间的痕迹，基本都在记录静物，拍人的比较少，还是应该多拿起相机走走。<br><img src="https://upload-images.jianshu.io/upload_images/170138-b91d33e6cb3ce603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="春"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/170138-47181f8846ff9f3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="秋"></p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ol>
<li>《菜场经济学》</li>
<li>《许三观卖血记》</li>
<li>《乌合之众》</li>
<li>《流畅的Python》</li>
<li>《了不起的盖茨比》</li>
</ol>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>理解docker-compse中的网络连接</title>
    <url>/2019/01/29/docker-compose-network/</url>
    <content><![CDATA[<p>读《Docker从入门到实践》<br><a href="https://yeasy.gitbooks.io/docker_practice/compose/usage.html">https://yeasy.gitbooks.io/docker_practice/compose/usage.html</a></p>
<p>中的docker-compose一章，在遇到下面一段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这是一段很简单的代码,但是我写的时候不小心用<code>host=&#39;localhost&#39;</code>代替了，这段代码在本地运行的很好，打开<code>http://localhost:5000</code>时能正常计数，但是在用<code>docker-compse up </code>启动之后会报</p>
<pre><code>redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.
</code></pre>
<p>很明显是flask的应用无法访问redis的服务，但是我打开了本地的redis-cli也显示无法连接<br>docker-compose 日志中，很明显redis的服务是启动在了6379端口，所以肯定是hostname的问题，在docker服务内部无法找到locahost到底是谁，因为localhost是在宿主机里的host文件里面配置的，所以app里面访问locahost来连接redis失败了，这时候要找到redis启动的真正的hostname是<code>redis</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/170138-740aca67e7fc893b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>使用docker-compose ps命令发现在<code>docker-compose up</code>启动的时候，自动创建了2个镜像实例<code>counter_web_1</code>,<code>counter_redis_1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ docker-compose ps</span><br><span class="line">    Name                    Command               State           Ports</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">counter_redis_1   docker-entrypoint.sh redis ...   Up      6379/tcp</span><br><span class="line">counter_web_1     python counter.py                Up      0.0.0.0:5000-&gt;5000/tcp</span><br></pre></td></tr></table></figure>

<p>由于我们在docker-compose.yml文件里面将counter_web_1从docker端口映射到外部网络的5000端口，因此我们才能通过localhost:5000来访问页面，所以加入<br>我们在redis里面也加上port</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">counter.py</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样的话 我们就能从宿主机来访问docker里面的redis实例了。<br><img src="https://upload-images.jianshu.io/upload_images/170138-57183c67645b46e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>Python Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解PRC之RPC基本原理</title>
    <url>/2019/12/27/learn-rpc-in-hard-way/</url>
    <content><![CDATA[<h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><h4 id="RPC的定义"><a href="#RPC的定义" class="headerlink" title="RPC的定义"></a>RPC的定义</h4><p>维基百科对RPC的定义是：</p>
<blockquote>
<p>在分布式计算，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client&#x2F;Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。<br>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。</p>
</blockquote>
<p>如下图：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdskxf7ow8j30j30luabd.jpg"></p>
<h4 id="RPC的步骤"><a href="#RPC的步骤" class="headerlink" title="RPC的步骤"></a>RPC的步骤</h4><ol>
<li>服务消费方（client）调用以本地调用方式调用服务；</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub找到服务地址，并将消息发送到服务端；</li>
<li>server stub收到消息后进行解码；</li>
<li>server stub根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给server stub；</li>
<li>server stub将返回结果打包成消息并发送至消费方；</li>
<li>client stub接收到消息，并进行解码；</li>
<li>服务消费方得到最终结果。</li>
</ol>
<h4 id="RPC解决了什么问题？"><a href="#RPC解决了什么问题？" class="headerlink" title="RPC解决了什么问题？"></a>RPC解决了什么问题？</h4><p>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</p>
<h4 id="RPC都有哪些框架？"><a href="#RPC都有哪些框架？" class="headerlink" title="RPC都有哪些框架？"></a>RPC都有哪些框架？</h4><p>开源框架：</p>
<ul>
<li>Dubbo: Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</li>
<li>gRPC ：gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</li>
<li>Hessian： Hessian是一个轻量级的<code>remotingonhttp</code>工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</li>
<li>Thrift： Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。<br>闭源框架：</li>
<li>HSF ：HSF是阿里巴巴内部使用的框架，诞生于淘宝，比诞生于B2B团队的Dubbo要早个3年，目前在阿里内部已经是HSF的天下了。</li>
<li>Motan: 微博内部使用的rpc框架，底层支持java,生态圈往<code>service mesh</code>发展以支持多语言</li>
<li>Pigeon：Pigeon是一个分布式服务通信框架（RPC），在美团点评内部广泛使用，是美团点评最基础的底层框架之一。和阿里的Dubbo类似，在微服务的场景下，提供高性能和透明得如同本地化调用的RPC调用服务。</li>
</ul>
<h4 id="RPC和HTTP的比较"><a href="#RPC和HTTP的比较" class="headerlink" title="RPC和HTTP的比较"></a>RPC和HTTP的比较</h4><p>其实两者没有没有什么可比较之处，只不过经常被人拿出来比较而已，RPC是远程过程调用，包含了传输协议和编码协议，只不过大部分RPC框架都用TCP&#x2F;IP来当做传输协议，当然HTTP也可以被当做出传输协议，比如gRPC<br>大部分人其实想问的是为什么大部分RPC框架都用TCP&#x2F;IP来当做传输协议？<br>可以思考一个问题：<code>http和tcp之间的差异是什么？</code><br>学过网路的人都知道http是建立在tcp协议所在的传输层纸上的应用层的，而在应用层就会比传输层要多很多的头部信息<br>比如下图：发送一个请求到百度，可以看到HTTP&#x2F;1.1协议的报文包含太多在传输过程中可能无用的信息：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdsle4trqij31d60u0kjl.jpg"><br>使用自定义 TCP 协议进行传输就会避免上面这个问题，极大地减轻了传输数据的开销。 这也就是为什么通常会采用自定义 TCP 协议的 RPC 来进行进行服务调用的真正原因。<br>此外，成熟的 RPC 框架还提供了 服务自动注册与发现、负载均衡、服务治理、等等高级功能，这些就是后话了，我们下一次再唠。</p>
]]></content>
      <tags>
        <tag>java/rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年终总结</title>
    <url>/2020/01/15/summary-2019-final/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/170138-12202d2eb2c085f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>​10年代的最后一天过去了，时光来到2020年，突然莫名的感伤，毕竟最早的90后已经步入了30岁，仿佛必须要写点什么才能抓住过去的时间，然而时间如流去的沙子划过指尖便再也无踪迹，只能从旧照片或者文字中才能找到一丝丝的温度，过去的一年发生了很多事情，这一年读了很多书，这一年跑了好多步，这一年经历了太多的迷茫，承受了很大的压力也备受焦虑，这一年也收获满满。</p>
<p><strong>关于工作</strong></p>
<p>四月份的时候公司搬到了杭州，原来的魅力惠渐渐的消失了，随之而来的是新的天猫奢品中心，我也做出了一个可能改变了人生命运的决定，我选择来杭州拼一把，在上海的时候公司当然也很符合当时上海互联网公司的调性，虽然有加班但是完全在承受范围内。在来之前已经听同事们说起过杭州的阿里加班有多恐怖，心里已经做好了思想准备，但是真正融入到了这个地方之后才会发现真的是特别拼命，能够当天下班的日子都屈指可数，处处充满着挑战，工作和思考招聘占据了大部分的时间，属于个人的时间几乎被榨干，但是我还是没有后悔这个选择。</p>
<p>到了杭州这边才算真正的融入了阿里的文化，同时也明白了一个道理：世界是残酷的，结果导向的。不要因为我们自己选择了一条对自己更难的路，就自我怜悯觉得这条路我们能走到这，已经非常不容易了。同一条路我们自己难走，换一个人可能走得很轻松。所以客观来讲，因为自己的选择而导致的难度的放大，引发的我们期望别人对我们的不容易而渴望好评的过程，是一厢情愿的自我怜悯。</p>
<p>9月份的阿里巴巴20年会，老马正式隐退江湖，全球的阿里人回家，我有幸去了现场，场面很壮观，当you raise me up音乐响起的时候，老马托着逍遥子缓缓上升，也差点落泪，大家一起打开手机的闪光灯挥舞，在那一刻，感受到了阿里人的力量。阿里在外界被戏称福报厂，因为老马说996是福报，在阿里外部的人可能并不是很理解为什么有那么多的人会为了公司拼命，老阿里人知道是组织文化的力量，随着司龄的不断增加你会逐步认同阿里的价值观，价值观考核也是属于绩效考核的一部分，所以大部分人就会被公司同化，同化不了的便离开，所以在招聘的时候能感受到很有趣的现象，很多人听到是阿里的立刻就挂掉电话，而有的人挤破头皮也进不来。</p>
<p><strong>关于读书</strong></p>
<p>今年读了很多书《原则》、《金字塔原理》、《苏东坡传》、《被讨厌的勇气》、《对赌》、以及《曾国藩嘉言钞》等等，将近50本书，当然去掉小说之类的真正的的干货书加技术类书籍的话也就三十几本吧，干货如《原则》、《金字塔原理》等书虽然看完做了批注总结，但是依然有一些东西不能很好的在实践中运用，属于没有完全掌握，或者说没有开窍。但是要说影响最大的要数林语堂的《苏东坡传》了。这本书带有林语堂强烈的个人色彩，有褒苏贬王的意思，可能林语堂太爱苏东坡了吧，看完苏东坡传，我也完全被苏东坡的人格魅力所征服，人生有浮有沉，但是能洒脱如苏轼的少见，苏轼的名篇也大都出自最为愁苦郁闷的黄州时期，我们有幸能以上帝视角快速浏览完他的一生，这也给我一些启发，每个人都会遇到自己的苦闷的时期，这个时候需要能够耐得住寂寞，守得住自己的初心，并学会在苦中作乐，做自己的英雄。</p>
<p>今年也读了很多哲学方面的书，哲学从某种程度上说属于无用之书，因为并不能产生什么价值，技能上也不会有什么进步，但是哲学能够让自己更加了解自己，发现自己的局限性，重新与这个世界连接，让自己的思想体系逐步自洽，这也是一辈子的目标。</p>
<p><strong>关于生活</strong></p>
<p>和恋爱六年，订婚三年，领证两年的老婆在老家结婚了，我们自己买婚纱，自己用相机拍了自己的写真集，可能并不是很完美，但是两个人在一起想怎么拍就怎么拍的感觉是在是太棒了，不用被摄影师逼迫摆各种各样尴尬的造型，从恋爱走向婚姻是一个从激情走向责任的过程，用心去体会生活，体会到对方的爱，一方面要学会被爱，一方面也要学会爱对方。</p>
<p>年底在魔都买了房，虽然不大好歹也是一个小窝，孟子曰：有恒产者有恒心。也算是完成一个小目标吧，在外漂泊的心总算可以收一收了，但同时压力也大了，怕工作不稳定，怕未来的不确定性，生活也多了一些焦虑，人生不就是这样的么，人总是要朝着美好的生活前进不是么？ </p>
<p>今年把相机卖掉了，可能是因为在杭州的缘故，相机几乎已经很少拿出来拍了，周末回到家只想休息、看书、运动，拿出去拍拍拍的动力没了，但是我发现了手机摄影的乐趣，用手机也能拍出很好看的照片，难得在于多拍，多练，多思考而不在于器材有多好。</p>
<p>今年感觉还是挺克制的，并没有买买买乱七八糟的东西， 能拿得出手的也就是苹果全家桶了，Apple watch ，airpods，iphone ，以及和mac配套的trackpad2 ,其实算下来也不少钱了，初衷是因为想跑步所以买了表，因为买了表所以必须换iphone，又因为跑步太单调买了airpods，这一切仿佛都是cook设计好的套路，但是就运动上面来讲，我觉得我并没有花冤枉钱。</p>
<p>年初的时候我给自己定下了一个小目标，每个月跑一个半马，回头看一下，今年总共跑了2600多公里，跑步已经成为了一个习惯，每个月跑一个马拉松也成为了一个约定，我完成了，所有的生命体都会逐渐适应来自外界的刺激，这个过程称为习惯，清晨闹钟响起，就起床带上手表出门跑步，或者大夏天的时候夜晚在操场吹着万丰尽情的奔跑。人都是习惯的奴隶。自律能让人获得更加长久的自由，慎独则能让我们变得更加知行合一。</p>
<p><strong>关于思考</strong></p>
<p>人，认清形势容易，认清自己难。今年可能是思考最多的一年，读书多了自然思考也就多了，更多的是思考自我与世界的关系，逐步的建立自己认知体系以及做事的章法规则等。形而上的问题可能是没有答案，但是只要能多了解自己一点，我就会开心一点，毕竟谁不想与自己做朋友呢。</p>
<p>这一年好像突然明白了很多道理，明白了为什么上课老师要让回答中心思想，明白了为什么大家要背诵全文，小时候不能设身处地的想象，等长大了处在了一定的位置和境地会发现古人以前也经历过。</p>
<p>这个世界一直在变，这是熵增定律的体现没有谁能够撼动，当我们回看历史的时候，我们也在变成历史，不要为了外物而过分影响自己的内心，寻找自己内心的真实，珍惜生命中的点滴美好，毕竟一辈子很短，放眼未来，把握当下就好。</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>我的Mac上都有什么？</title>
    <url>/2020/04/19/what-on-my-mac/</url>
    <content><![CDATA[<blockquote>
<p> 子曰： 工欲善其事必先利其器</p>
</blockquote>
<p>从论语的这句话我们能得出「 器 」的重要性， 工具的重要性自然不言而喻，用好一个软件，你的效率可以提升得到巨大的提升，俗话说的好，磨刀不误砍柴工，那么你准备好开始磨你的刀了么？</p>
<h2 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h2><p>MacOS和Windows在使用上有不少差异，本身Mac就有不少令人诟病的缺陷，下面的几款软件可以让你更好的使用这个系统，让你少走弯路。</p>
<span id="more"></span>

<h3 id="iStat-Menus"><a href="#iStat-Menus" class="headerlink" title="iStat Menus"></a>iStat Menus</h3><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzitxgpodj319w0u0n36.jpg" alt="iStat Menus"></p>
<p>「 iStat  Menus 」是一款可以在状态栏显示系统信息的软件，可以让你试试的了解系统运行的各个状态，非常直观的查看系统资源的消耗情况，而且显示非常优雅可以根据自己的喜好配置，比如下图就是内存的使用情况：</p>
<p>推荐指数：★★★★★</p>
<h3 id="Magnet"><a href="#Magnet" class="headerlink" title="Magnet"></a>Magnet</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzivgcctyj30m80dwgmq.jpg" alt="Magnet"></p>
<p>「 Magnet 」是一款快速分屏的软件，也是我在Mac上第一个付费购买的软件，价格是6元，几乎每天都会用到分屏的快捷键，比如将两个软件快速分成左、右或者上下两部分，假如你是多个屏幕的话，还可以将一个软件快速从一个屏幕移动到另外一个屏幕，总之这6块钱花的非常值。</p>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzixbe9vnj318f0m743g.jpg"></p>
<p>「 Alfred 」是Mac上面一款非常有名的效率软件，可以实现诸如文件搜索（类似于Windows上的Everything）、程序启动切换、热键搜索、计算器、词典、音乐播放、休眠锁屏以及自定义搜索功能，比如我经常需要查询订单信息，那么我就自定义一个URL来查询订单</p>
<p>对我而言，免费版的已经够用了，如果还需要更加强大的Workflow的功能那么就需要掏腰包了。</p>
<h2 id="开发软件"><a href="#开发软件" class="headerlink" title="开发软件"></a>开发软件</h2><h3 id="Intellij-IDEA"><a href="#Intellij-IDEA" class="headerlink" title="Intellij IDEA"></a>Intellij IDEA</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdziykasrxj30m80b40tn.jpg"></p>
<p>作为一个开发狗，工作上的大部分时间其实都是花在了开发软件上面，下面就来介绍下我在用的一些开发软件。</p>
<p>「 Intellij IDEA」是一款Java集成开发环境工具， 作为一只阿里后端狗，基本上用的语言就是Java了，所以首要的开发软件就是intellij idea，优点当然是多，但是也有一个致命的缺点就是：贵。如果你们公司不支持的话就只能用社区办，不过对于大部分人来说社区版本足够了<br>还可以配合Plugin以获得更加强大的特性。</p>
<p>比如安装了idea-vim就可以在编辑器使用vim了，虽然很多特性用不上，但是一些基础的操作还是可以用的，效率上也能够提升。安装了其他语言的Plugin之后还可以在idea里面写Python，scala等其他语言也足够用了。</p>
<p>推荐程度：★★★★★</p>
<h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzizqsum6j30dw06ydg2.jpg"></p>
<p>「 VSCode」是微软一款基于electroic的开源编辑器，一经开源便席卷了整个开源街，并且广泛流行起来，我最早使用的是sublime和atom最后转投了VSCode，其中sublime最大的有点是快，和基于electroic的Atom和VSCode比起来简直就是吊打，但是Atom和VSCode比起来插件没有VSCode多，速度也没有VSCode快，特别是当Github被微软收购了之后更是惨遭抛弃，VSCode越来越优秀，在github上更是有将近9w的star。</p>
<p>VSCode的插件市场更加丰富，功能也更加丰富，基于VSCode你甚至可以搭建一套IDE了，谁说免费的没有精品，VSCode就是一个例外。</p>
<p>推荐指数：★★★★★</p>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzj0eaqkkj30k80akjs3.jpg"></p>
<p>「 iTerm2」是一款免费的命令行工具，程序员离不开console，好的命令行终端自是必不可少，功能比自带的终端强太多了，比如设置背景壁纸，快捷键分屏，输入历史回放等。当然也可以配合zsh+tmux配置更加强大的命令行功能。</p>
<p>推荐指数：★★★★★</p>
<h3 id="Sequel-Pro"><a href="#Sequel-Pro" class="headerlink" title="Sequel Pro"></a>Sequel Pro</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdzj1yfni3j31s20u0gu3.jpg"></p>
<p>「 Sequel Pro」虽然软件的名字带着Pro但是却是一个免费的软件，如果你觉得不错可以捐赠作者。在阿里基本上都是用DMS网页版本的，用不到本地的mysql客户端，但是偶尔也是要连阿里云的mysql也是会用到数据库客户端，Sequel Pro虽然免费但是完全能够胜任，相比较Navicat来说也不差。</p>
<p>推荐指数：★★★★☆</p>
<h3 id="Visual-Paradigm"><a href="#Visual-Paradigm" class="headerlink" title="Visual Paradigm"></a>Visual Paradigm</h3><p>「 Visual Paradigm 」是一款非常强大的工具可以用来画原型图、画流程图、数据库关系图、工作流图以及项目管理等，当然收费也很贵，对于程序员来说一般都是用来画UML图以及数据库图，除了价格贵其他的没毛病，不过一般大公司都会有买集中授权，只要申请使用就好了。</p>
<p>推荐指数：★★★★☆</p>
<h2 id="效率软件"><a href="#效率软件" class="headerlink" title="效率软件"></a>效率软件</h2><p>效率软件就像是催化剂，不能改变我们做事情的结果，但是可以加快我们的做事情的速度，达到事半功倍的目的。</p>
<h3 id="iSlide"><a href="#iSlide" class="headerlink" title="iSlide"></a>iSlide</h3><p>「 iSlide 」是一款基于PPT的插件工具，可以方便的使用模板，图标等素材可以帮助你画出更加优雅的PPT，也许你会说我是程序员PPT这种东西太虚了，我的建议是越早准备越好，PPT画得好你才能升职加薪，代码写得好则不一定，除非你是大神级别的。</p>
<p>此前iSlide只在windows平台上才有，现在支持MacOS就更加香了，会员需要的话就买一个毕竟跟工资比，这点小钱这不算什么。</p>
<p>推荐指数：★★★★☆</p>
<h3 id="Xmind-Zen"><a href="#Xmind-Zen" class="headerlink" title="Xmind  Zen"></a>Xmind  Zen</h3><p>「 Xmind Zen 」是一款强大的思维导图工具，思维导图可以让你更加有条理的去思考问题，Xmind Zen相比较之前的版本更加的轻量（直接在App Store就可以搜索下载），更加的优雅，当然图标也更加好看了，这些都是次要的，免费版本的也够用了，平时在Mac上编辑的导图保存在iCloud上面，在iPhone或者iPad上可以轻松打开查看编辑方便的很。</p>
<p>推荐指数：★★★★★</p>
<h3 id="Trello"><a href="#Trello" class="headerlink" title="Trello"></a>Trello</h3><p>「 Trello 」是一款基于看板的项目管理软件，基于看板能够很清晰得看到项目的进度，目前存在的问题，以及截至日期等。Trello 上面的看板就相当于一块白板，卡片就相当于是白板上面便签的抽象，大家一起基于一块白板来进行协作。</p>
<p>在跟踪一个项目的时候，一般会有一个开始日期和结束日期，卡片代表需要完成的任务，列表通常代表一系列步骤，列表的结构可以非常简单，例如「TODO  」「 DOING 」和「DONE 」，也可以根据流程需要非常详细，卡片在从开始到完成期间从左向右移动，在移动完成之后也代表项目结束了。</p>
<p>不仅在工作中可以使用Trello，在日常生活中有时候也可以使用，因为很多事情都不是一下子就能完成的，比如学会一门技术，跳一次槽等，可以逐步分解项目最终完成你的目标。</p>
<p>软件虽然很好，但是在国内由于不能说的原因，导致登录同步不太好用，</p>
<p>推荐指数：★★★★☆</p>
<h3 id="滴答清单"><a href="#滴答清单" class="headerlink" title="滴答清单"></a>滴答清单</h3><p>「  滴答清单 」是一款GTD软件，可以帮你更加有效的管理任务且完成任务，<br>滴答清单的优点在于全平台，包括Apple Watch以及Chrome插件等应有尽有而且基础功能是免费的，而且有标签等功能，虽然升级到Catalina之后MacOS上面的待办事项更加强大了实际上还是有些简陋，我还是倾向于使用滴答清单，毕竟以后可能叛逃回安卓。</p>
<p>滴答清单和Trello的区别就在于Trello更加关注一个项目的进度，而滴答清单更加侧重于单个时间，当然用Trello也可以完成TODO任务，他们之间是有交集存在的。</p>
<p>推荐指数：★★★★★</p>
<p>总结</p>
<p>上面列举到的软件都是我平时用的非常多的软件，还有一些小众软件或者用的频率低的软件就暂时不列了，这些软件都非常的强大。上面只是一个引子，接下来的实践还要靠自己不断的摸索了。</p>
<p>周易云：形而上者谓之道，形而下者谓之器。想要用好这些工具并不容易，必须多学多用多思考，让「 器 」能够更好的为「 道 」服务，也让「 道 」更好的指导「 器 」产生更大的价值。</p>
]]></content>
      <tags>
        <tag>tools/mac</tag>
      </tags>
  </entry>
  <entry>
    <title>一个基于Git Rebase的高效Workflow</title>
    <url>/2020/12/06/better-git-workflow-with-git-rebase/</url>
    <content><![CDATA[<p><strong>你是否还在经历合并代码的痛苦？</strong>你是否经历过刚合并完代码，又提示合并反复多次？</p>
<p>这个时候你可能需要使用git rebase了，我会通过这篇文章来告诉你一个基于rebase的高效git workflow，学习成本很低，但是学会了受益无穷。</p>
<p>如果不想看文章正文可以直接滑到末尾，我总结了整篇文章的重点，直接用就可以了。</p>
<h1 id="为什么要用Git-rebase"><a href="#为什么要用Git-rebase" class="headerlink" title="为什么要用Git rebase"></a>为什么要用Git rebase</h1><p>很多公司在使用git的时候没有一套规范，自己想怎么提交就怎么提，rebase和merge乱用，最后导致git log非常的混乱，commit全是各种小补丁，看起来就像狗皮膏药一样。比如下面的gitlog，能够看到代码分支纵横交错，看起来非常的费力：</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130160447.png"></p>
<p>而一个整洁的git log应该是下面这样的，master是一条直线，历史的提交非常整洁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130161152.png" alt="使用rebase来协作"></p>
<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>正常的软件开发流程是：</p>
<p>首先你接到一个开发需求，比如说是，你就首先建立一个分支</p>
<p>假如你在自己的dev branch中提交了5次commit，很多都是调试性的gitlog，比如增加配置、添加log，或者直接就是一个update，这些commit你都已经push到repo了，因为代码push到Dev环境才能让测试介入测试。</p>
<p>当测试到一半的时候，突然有一个同事的feature上线了，这个时候你就需要重新更新master的代码。</p>
<p>如果使用不当，那么在你rebase&#x2F;merge master分支的时候简直就是一个灾难现场，假如你有5次提交，你需要不停的处理<strong>5次</strong>基本上相同的git 代码冲突，处理到你怀疑人生。</p>
<h1 id="使用Git-rebase来优化整个workflow"><a href="#使用Git-rebase来优化整个workflow" class="headerlink" title="使用Git rebase来优化整个workflow"></a>使用Git rebase来优化整个workflow</h1><p><strong>3.1 Squash自己branch的commit</strong></p>
<p>在和master代码进行交互之前，首先在自己的branch上使用 rebase squash自己的commit。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i [SHA] </span><br><span class="line">或者</span><br><span class="line">git rebase -i HEAD~[NUMBER OF COMMIT]</span><br></pre></td></tr></table></figure>

<p>这两者是等价的，如果使用zsh的话可以使用，grbi来代替git rebase -i这个命令.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~5 等价于 grbi HEAD~5</span><br></pre></td></tr></table></figure>

<p>假如我要squash下面的5个commit到9a86d1c（当然需要根据你的代码情况来判断，我这里只是举一个例子）的提交上面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130160851.png" alt="git log"></p>
<p>那么我们, git rebase -i HEAD~5就会出现下面的rebase 交互界面, 仔细观察会发现这个顺序其实是和gitlog<strong>相反的</strong>，最上面的是最早的commit，最下面的最近的commit。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130161014.png" alt="git rebase"></p>
<p>我们把除了第一个的commit前面pick改成s就好了，这里的s代表squash。保存之后会弹出编辑commit message的页面，在这里面更改你的commit message，结束之后保存，</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130161338.png" alt="squash commit message"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130161403.png" alt="rebase successful"></p>
<p>我这里是成功了，假如有冲突的话，需要手工进行冲突解决。由于是自己的分支上进行的rebase，所以一般不会起冲突，所以用起来很方便。</p>
<p>rebase squash完成之后，如果你之前已经push过origin的话，那么需要你执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin branchName --force</span><br></pre></td></tr></table></figure>

<p>如果你安装了zsh，可以用ggpush -f 来强制更新你的代码到origin，当然，你也可以rebase了master之后再进行这一步。</p>
<p><strong>3.2 从自己的branch rebase master代码</strong></p>
<p>squash了自己的branch之后就可以rebase master代码了，方法也非常简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull  </span><br><span class="line">或者 </span><br><span class="line">git fetch origin master:master</span><br></pre></td></tr></table></figure>

<p>这个时候一般来说不会有太多的冲突，大部分时候就是release的版本号会冲突，这个时候只需要简单处理就好了。</p>
<p>rebase master完成之后就可以把自己的代码push 到origin了，方法同3.1。</p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p><strong>整个git workflow是这样的：</strong></p>
<p>一、从master最新代码 checkout 新的分支进行开发</p>
<p>git checkout -b feature&#x2F;branch_name</p>
<p>二、中间随意进行代码提交即可，不要想着会污染git log，待所有的单元测试都完成之后，就可以使用rebase squash来合并commit，这个数量可从git log中算出来。</p>
<p>git rebase -i [SHA] 或 git rebase -i HEAD~[合并commit的数量]，</p>
<p>三、如果你之前push过 origin，可能需要force push（自己的分支不用担心），</p>
<p>git push origin branchName –force或者ggpush -f（zsh）</p>
<p>四、更新master代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master &amp;&amp; git pull  </span><br><span class="line">或者 </span><br><span class="line">git fetch origin master:master</span><br></pre></td></tr></table></figure>

<p>五、在你的feature branch rebase master代码，然后处理冲突（<strong>这时只需要处理一次冲突，因为之前做过squash</strong>）</p>
<p>git rebase master</p>
<p>六、重新force push代码到remote，如果你有CI的话，那么这里就结束了，因为CI会帮你从feature到master的步骤</p>
<p>七、如果你没有CI的话，那么需要你把feature branch <strong>merge（从feature到master用merge）</strong>到master，然后git push origin master，整个workflow就结束了。</p>
<p>这样一套 git workflow下来，你的代码提交日志将会非常整洁，看起来一点也不凌乱，如果你学会了，记得要向同事推荐，这将大大降低协作的成本。当然也要注意由于使用了 git force push，所以使用起来要<strong>小心一点</strong>，不过只要不用在自己的分支以外就没有问题。</p>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>tools/git</tag>
      </tags>
  </entry>
  <entry>
    <title>你会使用 git zsh alias 吗？</title>
    <url>/2021/01/02/zsh-git-alias/</url>
    <content><![CDATA[<p>Git 可以说是每个开发者必备的技能了，使用source tree之类的图形工具的同时，最好能修炼一下git命令行技能，在某种程度上可以让你更加高效的操作，也能在你ssh到远程机器上操作的时候能够临阵不慌，同时在工作中也能体会到git + zsh操作的方便之处。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130162903.png" alt="doggy"></p>
<span id="more"></span>
<p>alias是命令行下非常重要的一个功能，能够大大减少我们击键的次数，符合Don’t Repeat Yourself 的哲学。在oh my zsh 内置了很多使用的alias，默认git插件是启用的，所以这些alias也会启用，省去了自己配置的步骤，只需要记忆使用即可。</p>
<p>接下来我会从软件开发的场景来分享一下常用git命令的alias，重点部分用<strong>加粗字体</strong>标注，覆盖的不是很全，但绝对是常用的命令，当然也可以使用grep命令来检索相关alias。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130162940.png" alt="搜索alias"></p>
<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><ol>
<li>clone远程项目的副本，在你的项目文件夹下执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcl [repo-url] =&gt; git clone [repo-url]</span><br></pre></td></tr></table></figure>

<p>2.如果你本地已经有项目了，需要关联到远程repo 可以执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关联到一个远程仓库 </span><br><span class="line">gra =&gt; git remote add origin </span><br><span class="line">设置远程仓库的url，一般用于将ssh模式改为https或者反过来https转换为ssh模式</span><br><span class="line">grset =&gt; git remote set-url origin [repo-url]</span><br></pre></td></tr></table></figure>

<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p>列出分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列出本地所有分支，*号代表当前分支</span><br><span class="line">gb  =&gt; git branch			</span><br><span class="line">列出远程所有分支</span><br><span class="line">gbr =&gt; git branch --remote</span><br><span class="line">列出本地和远程所有分支</span><br><span class="line">gba =&gt; git branch -a	</span><br></pre></td></tr></table></figure>

<p>创建分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建新的分支, 分支还停留在当前分支</span><br><span class="line">gb [branch name]  =&gt; git branch [branch name]	</span><br><span class="line">删除现有分支</span><br><span class="line">gbd =&gt; git branch -d [branch name]	</span><br><span class="line">删除远程分支</span><br><span class="line">gbD =&gt; git push origin --delete [branch name]	</span><br></pre></td></tr></table></figure>

<p>切换分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建一个本地分支，并且切换到该分支</span><br><span class="line">gcb =&gt; git checkout -b [branch name]</span><br><span class="line">克隆一个远程分支并且切换到这个分支</span><br><span class="line">gcb =&gt; git checkout -b [branch name] origin/[branch name]	</span><br><span class="line">切换到一个本地分支</span><br><span class="line">gco =&gt; git checkout [branch name]</span><br><span class="line">切换到主分支，一般是master分支</span><br><span class="line">gcm =&gt; git checkout $(git_main_branch) </span><br><span class="line">切换到上一个checkout的分支</span><br><span class="line">gco -  =&gt; git checkout -	</span><br></pre></td></tr></table></figure>

<p>重新命名分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重新命名本地分支</span><br><span class="line">gb -m  =&gt;  git branch -m [old branch name] [new branch name]	</span><br></pre></td></tr></table></figure>

<h1 id="缓冲区文件操作（必备）"><a href="#缓冲区文件操作（必备）" class="headerlink" title="缓冲区文件操作（必备）"></a>缓冲区文件操作（必备）</h1><p>显示变更的文件，最常用的操作，类似于命令行下的ls</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">展示缓冲区文件的状态</span><br><span class="line">gst =&gt; git status </span><br></pre></td></tr></table></figure>

<p>添加文件进缓冲区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加文件进缓冲区</span><br><span class="line">ga  =&gt; git add [filename.txt]  </span><br><span class="line">添加所有变化的文件进缓冲</span><br><span class="line">gaa =&gt; git add -A	</span><br></pre></td></tr></table></figure>

<p>提交变更，我最常用的操作是<strong>gca</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提交变更并输入message </span><br><span class="line">gcmas =&gt; git commit -m &quot;[commit message]&quot;	</span><br><span class="line">在编辑器（默认是vim）中展示所有的变更行，在行首输入message保存后将提交所有变更</span><br><span class="line">gca   =&gt; git commit -v -a </span><br><span class="line">添加变更到缓冲区兵提交所有的变更</span><br><span class="line">gcam  =&gt; git commit -a -m </span><br><span class="line">修改最后一次的提交message</span><br><span class="line">gc!   =&gt; git commit -v --amend </span><br></pre></td></tr></table></figure>

<p>删除变更文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm -r [filename.txt]	&quot; 将文件/文件夹移除缓冲区</span><br></pre></td></tr></table></figure>

<h1 id="更新工作区-amp-远程仓库（必备）"><a href="#更新工作区-amp-远程仓库（必备）" class="headerlink" title="更新工作区&amp;远程仓库（必备）"></a>更新工作区&amp;远程仓库（必备）</h1><p>更新本地工作区，<strong>gl和ggpull</strong>最常用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">更新本地工作区</span><br><span class="line">gl =&gt; git pull	</span><br><span class="line">从远程仓库更新变更</span><br><span class="line">ggpull =&gt; git pull origin $(current_branch) </span><br><span class="line">获取变更，使用rebase操作来处理变更，默认是merge</span><br><span class="line">gup =&gt; git pull --rebase </span><br><span class="line">从upstream更新变更，fork仓库是更新源仓库代码用到</span><br><span class="line">glum =&gt; git pull upstream $&#123;git_main_branch&#125; </span><br></pre></td></tr></table></figure>

<p>推送缓冲区变更到远程仓库，其中<strong>ggpush</strong>最常用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gp  =&gt; git push </span><br><span class="line">推送一个分支变更到远程仓库</span><br><span class="line">ggpush =&gt; git push origin $&#123;git_current_branch&#125; </span><br><span class="line">推送本地分支到远程仓库，并关联该分支，一般用在初始化仓库</span><br><span class="line">gp -u		=&gt; git push -u origin </span><br><span class="line">推送远程分支，兵设置upstream</span><br><span class="line">gpsup =&gt; git push --set-upstream origin $(git_current_branch) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>reset本地工作区至HEAD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将当前代码重置为HEAD</span><br><span class="line">grh  =&gt;  git reset HEAD   </span><br><span class="line">grhh =&gt; git reset HEAD --hard </span><br></pre></td></tr></table></figure>

<h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><p>查看日志，我常用的是 <strong>glg和glog</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">展示commit历史，以及commit的情况</span><br><span class="line">glg - git log --stat --max-count=10 </span><br><span class="line">展示commit 历史，在单行展示message</span><br><span class="line">glo - git log --oneline --decorate --color </span><br><span class="line">展示commit历史，以terminal图形展示</span><br><span class="line">glog - git log --oneline --decorate --color --graph </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130163023.png" alt="glog"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130163101.png" alt="glog"></p>
<p>统计代码提交人的commit次数（<strong>常用</strong>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcount - git shortlog -sn</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130163127.png" alt="统计代码commit次数"></p>
<h1 id="Merge-amp-Rebase"><a href="#Merge-amp-Rebase" class="headerlink" title="Merge &amp; Rebase"></a>Merge &amp; Rebase</h1><p>合并操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将这个分支合并进当前active的分支，比如git merge master 合并master分支到当前分支</span><br><span class="line">gm =&gt; git merge [branch name]	</span><br><span class="line">将源分支合并进目标分支</span><br><span class="line">gm =&gt; git merge [source branch] [target branch]	</span><br><span class="line">终止当前merge，丢弃所有变更</span><br><span class="line">gma =&gt; git merge --abort </span><br></pre></td></tr></table></figure>

<p>变基操作（经常使用，牢记）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[numbers~HEAD]或者[SHA] rebase 代码到某个commit</span><br><span class="line">grbi =&gt; git rebase -i  </span><br><span class="line">继续rebase，一般在rebase有冲突的时候，你resolve所有冲突之后，需要进行这一步 </span><br><span class="line">grbc =&gt; git rebase --continue </span><br><span class="line">终止rebase</span><br><span class="line">grba =&gt; git rebase --abort </span><br></pre></td></tr></table></figure>

<p><strong>参考文档：</strong></p>
<p><a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>
<p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Cheatsheet">https://github.com/ohmyzsh/ohmyzsh/wiki/Cheatsheet</a></p>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>tools/git</tag>
      </tags>
  </entry>
  <entry>
    <title>技术人如何面向晋升编程？</title>
    <url>/2021/01/28/promotion-orient-programming/</url>
    <content><![CDATA[<p>这一篇文章不谈技术，以一个过来人的身份谈一谈大厂技术打工人的生存问题（逃 ，其实不仅国内大厂有这种问题，诸如Google、Facebook等国外大厂也有同样的问题 ，只要你在这个体系里面生存就一定要遵循这个规则。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20210130162202.png"></p>
<span id="more"></span>
<h1 id="为什么要面向晋升编程？"><a href="#为什么要面向晋升编程？" class="headerlink" title="为什么要面向晋升编程？"></a>为什么要面向晋升编程？</h1><p><strong>所有不能被写进晋升PPT里的工作都是打黑工！！！</strong></p>
<p>重要的事情加粗显示，不是不让你打黑工，有些时候打黑工是必须的，业务通常会有一些很紧急的需求，你一定不要不假思索地答应，最起码也要挑战一下TA，这个任务的价值在哪里？ 就算最后还是确定了一定要做，也一定要让TA知道，这个是非常难做的，而且一定要让自己老板知道，千万不要顺嘴就答应了，仿佛你所做的是理所应当的。</p>
<p>刚进大公司的时候，往往很天真，对每个人都毕恭毕敬的，仿佛伺候好了每一个人，你的前途就一片光明，然而事实很残酷，我举一个真实栗子：</p>
<p>之前在阿里时候，隔壁Team的一个同事，经常钉钉上看在半夜1点多还在群里处理业务问题，调试代码，处理工单等等，他的工作非常勤恳，哼哧哼哧地干活，结果一年到头，被领导打了个3.25，他的另外一个同事（都是P6），平时没见写过代码，就在内网上看到过几篇对项目的总结，结果后面拿了3.75去晋升了（虽然最后也没过）。</p>
<p>我们之间也打过交道，我向他请教过问题，代码水平一流，但是太沉迷于处理事情本身了，只做一个没有思想的工人，做一些没有办法被量化的工作，就算解决再多的Bug，处理再多的工单都没用，做事情一定要抓重点，小错可以随便犯，框架性的错误一定不要犯。</p>
<h1 id="如何量化工作？"><a href="#如何量化工作？" class="headerlink" title="如何量化工作？"></a>如何量化工作？</h1><p>在大公司里面，晋升都是由一群你不认识的人来决定的，也就是所谓的晋升委员会。 如果你所做的事情很难被量化，那么就很难被晋升委员会通过。</p>
<p>一般情况下，你越是努力地干活，你就越没有时间反刍，没有时间记录，你越是拿不到晋升资格。所以在做事情之前一定要考虑事情是否可以被量化。</p>
<p>什么叫可量化，就是说现状可改变的价值可以被衡量。举一个非常简单的例子，你做了一个XX系统，在上线前是是什么渣渣水平，你的系统上线之后，会达到xxx水平，这个不仅仅在大厂适用，在所有的公司都适用。</p>
<p>这个套路是：</p>
<ol>
<li>设置度量，监控现状，记录当前数据。</li>
<li>建立新系统，优化现状。（不要尝试优化以前的平台，除非你认为你是大牛）</li>
<li>记录优化后的数据，做出对比。</li>
</ol>
<p>基本上就是三步走，如果你做的事情是积极的，比如交易额等，那就得制造出上升的曲线，如果是成本类的事情，就需要制造出下降的曲线。</p>
<p>举一个我自己的例子，做了一个配置中心。需要的是</p>
<ol>
<li>监控当前因为配置问题导致的发版，记录次数，以及所花费的时间</li>
<li>开发配置中心项目，完成并上线</li>
<li>记录上线完成后，配置中心的使用次数，估算人力成本，机器成本等，并画出完美的下降趋势的曲线，这就是你晋升的时候最大的。</li>
</ol>
<p>当然这种大项目可能不仅仅是你一个人做的，所以你一定要留意在做项目时候中间遇到的各种问题，不要只埋头处理问题，记录问题同样重要，记录下来的资料，后面将会是你晋升乃至面试的重要一手资料。</p>
<h1 id="独立开发者-OR-打工人"><a href="#独立开发者-OR-打工人" class="headerlink" title="独立开发者 OR 打工人"></a>独立开发者 OR 打工人</h1><p>大公司都有相似的弊病，从Google、Facebook、Microsoft到国内的腾讯、阿里、字节等无一幸免，虽然高工资、高福利，但是想要真正实现自己的价值，在大公司其实很难做到，就氛围算再怎么像社区、大学也无法改变公司是由商业驱动的事实。</p>
<p>团队做的事情一旦上面不好看，很快就会被砍掉，也就意味着你所有的付出全都付诸东流。所以大公司，主要还是看自己的选择和运气，其次才是你的个人努力。</p>
<p>在大公司，出了个别骨干，大部分人都是螺丝钉，很大程度上，你做的事情不会是你真正想去做的事情，很大意义上不会感受到自我实现的价值，所以往往过得并不开心。你所做的事情就是向他人证明自己，通过做事情、展示数据来向领导、晋升委员会展示自己。</p>
<p>所以如果你心中有远大的理想，成为一名独立开发者，做自己喜欢的产品也许是一个不错的选择，但是我相信大部分人就算心里有光也不会选择冒险。特别是结了婚有了娃之后。</p>
<p>如果你选择了做打工人，就一定要想明白你所做的每一件事情都是你的业绩，那么就一定不要打黑工，不妨让你做的事情高效一点，面向晋升&#x2F;绩效编程，让领导能够看到你的产出（量化图表就是非常好的成果）。另一方面，量化的数据也更容易让你找到工作的意义，以及自己的人生价值。</p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>晋升</tag>
      </tags>
  </entry>
  <entry>
    <title>这本书可能改变你的习惯</title>
    <url>/2021/09/27/The%207%20Habits%20of%20Highly%20Effective%20People/</url>
    <content><![CDATA[<blockquote>
<p>人的行为总是一再重复。因此卓越不是一时的行为，而是习惯。<br>                                ——亚里士多德（Aristotle）｜古希腊哲学家、文艺理论家</p>
</blockquote>
<p>柯维博士的《高效能人士的七个习惯》让人一看就以为是地摊成功文学的感觉，实际上确实是一本含金量不低的书，对于个人成长有很大的帮助，特别是让我们能够更好的领导自己，领导自己做正确的事，以及正确的做事。</p>
<p>这本书让我能够静下心来思考，从内而外的思考，更多的考虑我自己内心的感受，自己内心的各种想法，但是这本书太高屋建瓴了，我想能够完全做到并实践的人并不多。读完这本书并不能改变你的习惯，他只能帮助你思考自身，知行合一才能让你变得更加有效能，不再让别人影响情绪，反而更能接受改变，秉承着自己的价值标准，最终找到内心的平静。</p>
<p>在这本书中他把人类成熟模式把人分为三个阶段：依赖期，独立期，互赖期。</p>
<ul>
<li>依赖期：完成一件事情需要依赖他人的帮助，他人对自己负责</li>
<li>独立期：自己一个人完成一件事情，自己对自己负责。</li>
<li>互赖期：意识到很多事情不可能自己一个人完成，开始和他人合作。</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220505160604.png" width="50%" height="50%" style="margin: 0 auto;"/></p>
<span id="more"></span>

<h2 id="个人习惯"><a href="#个人习惯" class="headerlink" title="个人习惯"></a>个人习惯</h2><h3 id="积极主动"><a href="#积极主动" class="headerlink" title="积极主动"></a>积极主动</h3><p>这一章最重要的概念就是提出来两个圈，<code>关注圈</code>和<code>影响圈</code>，顾名思义，我们每天都会关注很多事情，如果关注的事情可以被我们掌握，比如工作中分配的任务，锻炼身体等属于这一类，那么就说明这部分事情在<code>影响圈</code>内，其余的则不能被掌握，比如股票，战争等等，这些事情可能不能被我们所左右。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220505173914.png"></p>
<p>看一个人的时间和精力集中于哪些事物，也能大致判断他是否积极主动，按照《影响力》这本书说的，这一步其实就是把关注圈扩大到影响圈，把自己的能量不断扩大。被动的人往往全神贯注于关注圈，抓住环境问题、他人的弱点以及超出个人能力范围的事情不放，结果越来越怨天尤人。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220505174040.png"></p>
<p>积极的做法应该是，由内到外自发的改变，先改变自己的个人行为，让自己变得更充实和更加有创造力，然后才能进一步去影响环境。</p>
<h3 id="以终为始"><a href="#以终为始" class="headerlink" title="以终为始"></a>以终为始</h3><p>这个习惯让我们朝正确的方法前进，如果我们的梯子搭错了墙，那么就算我们怕的再高都没有用。</p>
<p>我要成为一个什么样的人吧？ 这可能是一个很复杂的问题，但是他非常有助于我们理解我们做的事情，我们需要找到一些原则来支撑我们的工作和生活，这些原则是不会随着时间变化的法则，靠着原则我们才不会在这个随波逐流的社会上迷茫。</p>
<p>对我而言，我的价值观也很简单：</p>
<ul>
<li>家庭第一</li>
<li>保持健康的身体</li>
<li>态度积极</li>
<li>保持幽默感</li>
<li>对他人真诚</li>
<li>保持礼貌</li>
<li>关注当下</li>
<li>换位思考</li>
<li>多请教别人</li>
<li>多聆听少说话</li>
</ul>
<h3 id="要事第一"><a href="#要事第一" class="headerlink" title="要事第一"></a>要事第一</h3><blockquote>
<p>根据英语词源学，“自律（discipline）”是由“信徒（disciple）”一词衍生出来的。通常情况下，信徒指的是信奉某种哲学或者某种学说、原则、价值体系的人，他们信奉某种高尚目标或这种目标的代表人物。</p>
</blockquote>
<p>换言之，如果你能够成为高效率的自我管理者，那么你的自律就是由内而外形成的，是独立意志的具体表现，你所信奉与追随的就是内在的价值观及在此基础上形成的人生要旨。有了独立意志和诚信人格，你就可以控制自己的感情、冲动以及情绪，服从这些价值观的约束。</p>
<p>《卓有成效的管理者》说过这一个习惯，有效的管理就是要事第一，领导者首先要决定的，就是哪些事情是重要的，管理者要做的事情就是把事务按照优先级排序，先做最重要的事情，自我管理的本质是自律和条例是对计划的实施。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220505180627.png" alt="经典的四象限法则"></p>
<p>需要注意的是不要陷入第三和第四象限事务，不管是紧急的还是非紧急的他们都不是很重要的事情。</p>
<blockquote>
<p>按照彼得·德鲁克（Peter Drucker）的观点，高效能人士的脑子里装的不是问题，而是机会。他们不会在各种各样的问题上浪费时间和精力，他们的思维方式是预防型的，总是能够做到防患于未然。当然，他们也有真正意义上的危机和紧急事件需要马上处理，但是这类事件的数量相对来说很少。他们能够平衡产出和产能的关系，将时间和精力集中在重要但是并不紧急的事务上，即第二象限事务，完成这些活动能够提高个人的处事能力。</p>
</blockquote>
<p>通过优化第二象限的事情来减少第一象限的事情数量，比如对于工程师而言，平时做好代码review以及Unit test，那么线上出现紧急故障的概率就会大大降低。</p>
<h2 id="公共习惯"><a href="#公共习惯" class="headerlink" title="公共习惯"></a>公共习惯</h2><p>接下来是是公共领域的成功三个习惯，这一部分让我们从独立期走向互赖期。<br>在现代生活中，人不可能单打独斗的，需要和他人进行合作。</p>
<p>对于大多数人而言，独立期的门槛已经够高了，独立期只是让我们发生改变的原因，向上追求必然会进入到公共领域，进一步依赖他人。</p>
<h3 id="双赢思维"><a href="#双赢思维" class="headerlink" title="双赢思维"></a>双赢思维</h3><p>从长远来看，双赢是人际交往中的唯一可行的模式，不是双赢就是两败俱伤。把这个世界看做是一个合作的舞台而不是角斗场，事情并不是非此即彼的。双赢思维代表自己的心智逐渐走向成熟。</p>
<h3 id="知彼解己"><a href="#知彼解己" class="headerlink" title="知彼解己"></a>知彼解己</h3><p>在表达个人观点之前，先理解别人，这是互相依赖关系中最有用的习惯。不要太过心急，要有耐心，更要尊重对方，在你能感同身受之前，人们往往不会主动吐露心声，多听少说，警惕好为人师和自以为是，因为一旦你觉得自己是对的，你就很难听进去别人的话。</p>
<h3 id="统合综效"><a href="#统合综效" class="headerlink" title="统合综效"></a>统合综效</h3><p>综合综效的本质是尊总差异，建立优势，弥补弱点。基本心态是：如果一个聪明人跟我的意见不同，那么对方的主张一定有我尚未体会的奥妙，值得加以了解学习。</p>
<p>了解了彼此，甚至还称赞彼此的差异，欣赏对方解决问题及把握机会的手法。个人的力量是团队和家庭统合综效的基础，能使整体获得一加一大于二的成效。实践统合综效的人际关系和团队会扬弃敌对的态度（1+1＝1&#x2F;2），不以妥协为目标（1+1＝11&#x2F;2），也不仅仅止于合作（1+1＝2），他们要的是创造式的合作（1＋1＞2）。</p>
<h2 id="不断更新"><a href="#不断更新" class="headerlink" title="不断更新"></a>不断更新</h2><p>习惯七就是个人产能，它保护并优化你所拥有的最重要的资产——自己。</p>
<p>它从四个层面更新你的天性，那就是：<code>身体、精神、智力、社会/情感</code>。不断更新意味着要兼顾这四种要素对自己进行投资，在这四个层面“磨刀”。</p>
<p>就如同锻炼身体一样，锻炼身体的优点几乎都在最后阶段产生，想要增强力量就必须等到肌肉纤维断裂，神经纤维感到疼痛，这个时候自然机制会予以过度补偿，肌肉纤维会在48小时后变得更加坚韧。</p>
<p>越是积极主动（习惯一），就越能在生活中有效地实施自我领导（习惯二）和管理（习惯三）；<br>越是有效管理自己的生活（习惯三），就能从事越多的第二象限事务的更新活动（习惯七）；<br>越能先理解别人（习惯五），就越能找到统合综效的双赢解决方案（习惯四和习惯六）；<br>越是在培养独立性的习惯方面加以改进（习惯一、二、三），就越能在相互依赖的环境下提高效能（习惯四、五、六）；</p>
<p>而自我更新则是强化所有这些习惯的过程（习惯七）。</p>
<blockquote>
<p>谁也无法说服他人改变，因为我们每个人都守着一扇只能从内开启的改变之门，不论动之以情或晓之以理，我们都不能替别人开门。–弗格森</p>
</blockquote>
<p>改变只能由内而外的发生，而不能由外向内，外部只能引导，就像谚语说的，你可以把马牵到河边，但你不能强迫它喝水。</p>
<p>也像阿德勒的积极心理学一样，更多的时候去考虑自己能改变的事情，而不是只会怨天尤人，把所有的问题归因到原生家庭，归因于社会，归因于他人。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://weread.qq.com/web/reader/56d325907203e8a856def7fkc81322c012c81e728d9d180">https://weread.qq.com/web/reader/56d325907203e8a856def7fkc81322c012c81e728d9d180</a></li>
</ol>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Environment体系分析</title>
    <url>/2021/12/28/Spring%20Environment%20Analysis/</url>
    <content><![CDATA[<h2 id="Spring-Environment-体系"><a href="#Spring-Environment-体系" class="headerlink" title="Spring Environment 体系"></a>Spring Environment 体系</h2><p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220506183240.png" alt="Spring-environment.excalidraw"></p>
<h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><blockquote>
<p>Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the PropertyResolver superinterface.</p>
</blockquote>
<p>Environment 继承自<strong>PropertyResolver</strong> 定义了应用运行环境的两大关键要素： profiles 和properties，其中properties接口通过父类的<strong>PropertyResolver</strong> 暴露接口.</p>
<span id="more"></span>

<p>ApplicationContext负责将Environment给后面创建Bean来使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;  </span><br><span class="line">   <span class="built_in">super</span>.setEnvironment(environment);  </span><br><span class="line">   <span class="built_in">this</span>.reader.setEnvironment(environment);  </span><br><span class="line">   <span class="built_in">this</span>.scanner.setEnvironment(environment);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对Bean进行操作的过程中，如果需要进行一些解析，会调用Environment对象进行操作。 </p>
<p>SpringBoot 中会在run方法中创建默认的  ConfigurableEnvironment, 在prepareContext中设置到Context中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;  </span><br><span class="line">	...</span><br><span class="line">      <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);  </span><br><span class="line">      <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);  </span><br><span class="line">      context = createApplicationContext();  </span><br><span class="line">      context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);  </span><br><span class="line">      prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  </span><br><span class="line">      refreshContext(context);  </span><br><span class="line">      afterRefresh(context, applicationArguments);  </span><br><span class="line">    ...</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">      handleRunFailure(context, ex, listeners);  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> context;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据类型创建environment</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">getOrCreateEnvironment</span><span class="params">()</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.environment;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;  </span><br><span class="line">   <span class="keyword">case</span> SERVLET:  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplicationServletEnvironment</span>();  </span><br><span class="line">   <span class="keyword">case</span> REACTIVE:  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplicationReactiveWebEnvironment</span>();  </span><br><span class="line">   <span class="keyword">default</span>:  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ConfigurableEnvironment"><a href="#ConfigurableEnvironment" class="headerlink" title="ConfigurableEnvironment"></a>ConfigurableEnvironment</h3><p>先来看ConfigurableEnvironment源码中的注释：</p>
<blockquote>
<p>Configuration interface to be implemented by most if not all Environment types. Provides facilities for setting active and default profiles and manipulating underlying property sources. Allows clients to set and validate required properties, customize the conversion service and more through the ConfigurablePropertyResolver superinterface.<br>Manipulating property sources</p>
</blockquote>
<p>ConfigurableEnvironment提供两大功能，设置profile和操作委托对象[[Spring PropertySource]] 来实现对Property的操作</p>
<p><a href="https://github.com/zhaohongxuan/zhaohongxuan.github.io/actions/workflows/pages/pages-build-deployment"><img src="https://github.com/zhaohongxuan/zhaohongxuan.github.io/actions/workflows/pages/pages-build-deployment/badge.svg" alt="pages-build-deployment"></a></p>
<h3 id="AbstractEnvironment"><a href="#AbstractEnvironment" class="headerlink" title="AbstractEnvironment"></a>AbstractEnvironment</h3><p>AbstractEnvironment 实现了大部分<strong>ConfigurableEnvironment</strong>的功能，包含了一下委托对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; activeProfiles = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; defaultProfiles = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(getReservedDefaultProfiles());  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MutablePropertySources</span> <span class="variable">propertySources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertySources</span>()</span><br></pre></td></tr></table></figure>

<p>子类通过<strong>customizePropertySources</strong> 的hook来操作propertySources</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.propertyResolver.getProperty(key);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="PropertyResolver-的设计"><a href="#PropertyResolver-的设计" class="headerlink" title="PropertyResolver 的设计"></a>PropertyResolver 的设计</h2><p>PropertyResolver是Environment的<strong>顶层设计接口</strong></p>
<blockquote>
<p>Interface for resolving properties against any underlying source </p>
</blockquote>
<p>PropertyResolver是为了解析Properties而生的, 接口主要定义了如何从根据一个key来获取一个value, 可以是String类型的也可以是<strong>给定的Class类型</strong></p>
<p>PropertyResolver提供了两类操作</p>
<ul>
<li>getProperty()</li>
<li>resolvePlaceholders() ，给外界暴露出一个能力来解析诸如<code>$&#123;&#125;</code>的Placeholder<br> 其他的操作都是这两个操作的变身。</li>
</ul>
<h3 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h3><p>ConfigurablePropertyResolver 定义了一个配置化的PropertyResolver，主要是为了解析<strong>占位符， 默认是${}</strong> 的property，比如[[Spring @Value的实现机制]] 中就用到了这个Resolver</p>
<p>同时，ConfigurablePropertyResolver定义了[[ConversionService]] 的接口用来将value转换为目标类型</p>
<h3 id="AbstractPropertyResolver"><a href="#AbstractPropertyResolver" class="headerlink" title="AbstractPropertyResolver"></a>AbstractPropertyResolver</h3><p>[[AbstractPropertyResolver]] 中提供了一个方法来很方便的把value转换为目标类型 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">convertValueIfNecessary</span><span class="params">(Object value, <span class="meta">@Nullable</span> Class&lt;T&gt; targetType)</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> (targetType == <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> (T) value;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="type">ConversionService</span> <span class="variable">conversionServiceToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.conversionService;  </span><br><span class="line">   <span class="keyword">if</span> (conversionServiceToUse == <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="comment">// Avoid initialization of shared DefaultConversionService if  </span></span><br><span class="line"> <span class="comment">// no standard type conversion is needed in the first place... if (ClassUtils.isAssignableValue(targetType, value)) &#123;  </span></span><br><span class="line">         <span class="keyword">return</span> (T) value;  </span><br><span class="line">      &#125;  </span><br><span class="line">      conversionServiceToUse = DefaultConversionService.getSharedInstance();  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> conversionServiceToUse.convert(value, targetType);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractPropertyResolver 中定义了，Placeholder的prefix&#x2F;sufix以及valueSeparator还有<strong>resolvePlaceholders</strong>的策略(严格或者非严格)，严格模式不能解析的placeholder会抛出异常。</p>
<h3 id="PropertySourcesPropertyResolver"><a href="#PropertySourcesPropertyResolver" class="headerlink" title="PropertySourcesPropertyResolver"></a>PropertySourcesPropertyResolver</h3><p>主要目的是通过遍历PropertySources中的key来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="type">boolean</span> resolveNestedPlaceholders)</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.propertySources != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="built_in">this</span>.propertySources) &#123;  </span><br><span class="line">         <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;  </span><br><span class="line">            logger.trace(<span class="string">&quot;Searching for key &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; in PropertySource &#x27;&quot;</span> +  </span><br><span class="line">                  propertySource.getName() + <span class="string">&quot;&#x27;&quot;</span>);  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> propertySource.getProperty(key);  </span><br><span class="line">         <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (resolveNestedPlaceholders &amp;&amp; value <span class="keyword">instanceof</span> String) &#123;  </span><br><span class="line">               value = resolveNestedPlaceholders((String) value);  </span><br><span class="line">            &#125;  </span><br><span class="line">            logKeyFound(key, propertySource, value);  </span><br><span class="line">            <span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;  </span><br><span class="line">      logger.trace(<span class="string">&quot;Could not find key &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; in any property source&quot;</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h2><p>PropertySource代表了Key-value的Property来源：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220506184157.png" alt="PropertySource.excalidraw"></p>
<p>Environment的默认实现StandardEnvironment就用到了SystemEnvironmentPropertySource, 默认将操作系统中的环境变量加载到Environment中去。</p>
<p>如果我们需要魔改Spring容器中的配置文件属性的值，比如配置中心在运行时动态刷新key的value，这个时候就需要自己操作PropertySource，自定义一个PropertySource，然后优先级设置在系统propertySource之上，这样就可以实现动态刷新了。</p>
<h3 id="PropertySources"><a href="#PropertySources" class="headerlink" title="PropertySources"></a>PropertySources</h3><p>PropertySources此接口是PropertySource的容器，默认实现<strong>MutablePropertySources</strong>实现内部含有一个CopyOnWriteArrayList来存储PropertySource。</p>
<h2 id="EnvironmentAware"><a href="#EnvironmentAware" class="headerlink" title="EnvironmentAware"></a>EnvironmentAware</h2><p>Spring的Aware组件是Spring容器给应用提供的一个钩子方法，实现了Aware接口，就可以在对应的组件里面设置对应的功能，比如实现了EnvironmentAware可以在组件里获得Environment的能力，实现了BeanFactoryAware就可以在组件里获得容器的BeanFactory，方便用户来进行一些自定义处理。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://github.com/seaswalker/spring-analysis/blob/master/note/Spring.md">https://github.com/seaswalker/spring-analysis/blob/master/note/Spring.md</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html">https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html</a></li>
</ol>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>java/spring</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Yt-dlp高效下载Youtube的视频</title>
    <url>/2022/03/14/use-yt-dlp-download-youtube-videos/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220314235517.png"></p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>如果没有全局梯子的话，在命令行里就需要使用代理来下载。使用<code>--proxy</code>来指定代理，支持<code>HTTP/HTTPS/SOCKS</code> 等协议。</p>
<span id="more"></span>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>默认下载的视频格式是webm格式，如果需要转换可以使用<code>--merge-output-format mp4</code> 来转换，mp4可以指定为其他格式，比如mkv等，下载的文件名格式是 <code>%(title)s [%(id)s].%(ext)s</code> ，通过<code>--output</code>可以指定输出的文件名格式。</p>
<p>文件名的Template语法参考：<a href="https://github.com/yt-dlp/yt-dlp/blob/master/README.md#output-template">https://github.com/yt-dlp/yt-dlp/blob/master/README.md#output-template</a> </p>
<h3 id="下载1080P视频-音频并合并"><a href="#下载1080P视频-音频并合并" class="headerlink" title="下载1080P视频+音频并合并"></a>下载1080P视频+音频并合并</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yt-dlp -f &#x27;bv[height=1080][ext=mp4]+ba[ext=m4a]&#x27; https://www.youtube.com/watch?v=WHSoSAqOyPY </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="下载4K视频-音频合并"><a href="#下载4K视频-音频合并" class="headerlink" title="下载4K视频+音频合并"></a>下载4K视频+音频合并</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yt-dlp -f <span class="string">&#x27;bv[height=2160][ext=mp4]+ba[ext=m4a]&#x27;</span> --embed-metadata    https://www.youtube.com/watch?v=WHSoSAqOyPY </span><br></pre></td></tr></table></figure>


<h3 id="下载列表"><a href="#下载列表" class="headerlink" title="下载列表"></a>下载列表</h3><p>默认输入视频URL带上list的话会自动下载list的</p>
<p>设置<code>--playlist-start 1</code> 来指定开 始的index，设置 <code>--playlist-end</code> 指定结束的index，<code>--playlist-items 1,2,5-8</code> 指定某一些item进行下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yt-dlp -f &#x27;bv+ba&#x27; --embed-metadata --merge-output-format mp4 --playlist-items 1,2,6-10 -o &#x27;%(playlist_index)s-%(playlist)s-%(title)s.mp4&#x27; https://www.youtube.com/watch\?v\=rY-7DtUFiEI\&amp;list\=PLJVKAfvqjvcofezOxMQaSHnO6HV84isXO</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="字幕操作"><a href="#字幕操作" class="headerlink" title="字幕操作"></a>字幕操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">--write-subs 把字幕写到磁盘上</span><br><span class="line">--sub-langs zh-Hans,en  多个语言使用逗号隔开，all下载全部语言</span><br><span class="line">--write-auto-subs 把自动生成的字幕写到磁盘上</span><br><span class="line">--embed-subs 把字幕嵌入视频文件中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过<code>--write-subs</code> 把字幕写到磁盘上，<code>--sub-langs zh-Hans,en</code>  多个语言使用逗号隔开，all下载全部语言，<code>--write-auto-subs</code> 把自动生成的字幕写到磁盘上，<code>--embed-subs</code> 把字幕嵌入视频文件中<br>下载视频带中英文字幕文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">yt-dlp https://www.youtube.com/watch?v=XiGk6PXt38w&amp;t=18s --sub-langs zh-Hans,en --write-subs --write-auto-subs --embed-thumbnail --write-thumbnail --write-link</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="综合操作"><a href="#综合操作" class="headerlink" title="综合操作"></a>综合操作</h2><p>下载最佳分辨率视频+音频+下载中英文字幕文件+转换为mp4+视频链接+缩略图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yt-dlp \</span><br><span class="line">--format <span class="string">&#x27;bv+ba&#x27;</span> \ </span><br><span class="line">--write-auto-subs \</span><br><span class="line">--sub-langs zh-Hans,en \</span><br><span class="line">--write-link \</span><br><span class="line">--write-thumbnail \</span><br><span class="line">--embed-metadata \</span><br><span class="line">--merge-output-format mp4 \</span><br><span class="line">--output <span class="string">&#x27;%(playlist_index)s-%(playlist)s-%(title)s.mp4&#x27;</span> \</span><br><span class="line">https://www.youtube.com/watch\?v\=rY-7DtUFiEI\&amp;list\=PLJVKAfvqjvcofezOxMQaSHnO6HV84isXO</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://github.com/yt-dlp/yt-dlp">https://github.com/yt-dlp/yt-dlp</a></li>
</ol>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>tools/dlp</tag>
      </tags>
  </entry>
  <entry>
    <title>在Obsidian中写Hexo Blog</title>
    <url>/2022/05/03/how-to-write-blog-in-obsidian-using-hexo/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Obsidian目前是我的主力笔记软件，<code>Hexo</code>是我的Blog的Github Pages引擎。孟子曰：</p>
<blockquote>
<p>鱼，我所欲也；熊掌，亦我所欲也。二者不可得兼。</p>
</blockquote>
<p>虽说二者不可兼得，但是程序员思维总是会指导我：必定有一个方案可以解决这个问题，如果没有那那就创造一个。</p>
<p>在没有Obsidian之前我写Blog的流程是直接在VSCode中打开<code>zhaohongxuan.github.io</code>文件夹，然后编辑md文件，提交到Github然后自动生成Github Pages.</p>
<p>在使用Obsidian之后我会现在Obsidian中建立相关的页面，然后编辑完成之后copy到<code>zhaohongxuan.github.io</code>文件夹，提交到github, 这就导致了一个心智负担：每次都得做重复的工作，copy文件，然后提交代码，间接导致了我不想写Blog（逃。</p>
<p>如何才能在愉快的一边在Obsidian里写笔记一边还能无缝发布Blog呢？</p>
<span id="more"></span>

<p>我的想法是通过同步Obsidian的Blog目录里的文件<code>sync</code>到我们的Github Pages Blog目录，然后在git commit push来间接达到我们的目的。</p>
<p>这里sync操作可以使用<code>rsync命令</code><sup>1</sup>来解决，rsync是一个非常厉害的命令，这里只是用到了最基本的操作，也就是覆盖式同步。</p>
<ul>
<li><p>优点：只使用git管理 GitHub Pages, 其他的md文件还是通过云盘来同步，虽然拉跨，但是在iPhone和iPad上使用省心不少。</p>
</li>
<li><p>缺点：需要在每个电脑上配置一个脚本来进行rsync操作，Mobile端一般也不会写Blog，所以不需要配置这个脚本。<br>所以这里选择了第二个思路来达到我的目的。</p>
</li>
</ul>
<h2 id="同步Obsidian的Blog文件夹到Hexo-Blog的-post文件夹"><a href="#同步Obsidian的Blog文件夹到Hexo-Blog的-post文件夹" class="headerlink" title="同步Obsidian的Blog文件夹到Hexo Blog的_post文件夹"></a>同步Obsidian的Blog文件夹到Hexo Blog的_post文件夹</h2><p>使用rsync命令，一般的linux发行版上都会自带这个命令的，需要注意的是<br>如果要覆盖是更新，记得要加上<code>--delete</code> <sup>2</sup></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avu --delete ~/Library/Mobile\ Documents/iCloud~md~obsidian/Documents/xuan/Blog/ ~/VSCodeProjects/zhaohongxuan.github.io/source/_posts/</span><br></pre></td></tr></table></figure>

<h2 id="将变化的post提交到github"><a href="#将变化的post提交到github" class="headerlink" title="将变化的post提交到github"></a>将变化的post提交到github</h2><p>这一步需要进入到Github Page的目录，我这里用的是Hexo blog，然后添加所有的md文件，提交到Github</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/VSCodeProjects/zhaohongxuan.github.io/</span><br><span class="line">git checkout src --force</span><br><span class="line">cd source/_posts</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Commit from Obsidian&quot;</span><br><span class="line">git push</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编写sh脚本"><a href="#编写sh脚本" class="headerlink" title="编写sh脚本"></a>编写sh脚本</h2><h3 id="预览Blog"><a href="#预览Blog" class="headerlink" title="预览Blog"></a>预览Blog</h3><p>编写一个预览Blog的脚本<code>sync-commit-obsidian.sh</code> </p>
<ol>
<li>同步blog文件到Blog文件夹</li>
<li>hexo server启动本地预览</li>
<li>打开浏览器预览blog</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">rsync -avu --delete ~/Library/Mobile\ Documents/iCloud~md~obsidian/Documents/xuan/Blog/ ~/VSCodeProjects/zhaohongxuan.github.io/source/_posts/</span><br><span class="line">cd ~/VSCodeProjects/zhaohongxuan.github.io</span><br><span class="line">hexo server</span><br><span class="line">open &#x27;http://localhost:4000&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个脚本可以放在一个固定文件夹里，我这里放到<code>~/Developer/scripts/</code>里，等下面Obsidian配置shell command的时候会用到。</p>
<h3 id="发布Blog"><a href="#发布Blog" class="headerlink" title="发布Blog"></a>发布Blog</h3><p>将脚本写入到一个sh文件里，<code>sync-commit-obsidian-posts.sh</code> 然后存放在一个目录里，我这里存放在<code>~/Developer/scripts/</code>下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">rsync -avu --delete ~/Library/Mobile\ Documents/iCloud~md~obsidian/Documents/xuan/Blog/ ~/VSCodeProjects/zhaohongxuan.github.io/source/_posts/</span><br><span class="line"><span class="built_in">cd</span> ~/VSCodeProjects/zhaohongxuan.github.io/source/_posts/</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Commit from Obsidian&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>


<h2 id="在Obsidian中执行Shell命令"><a href="#在Obsidian中执行Shell命令" class="headerlink" title="在Obsidian中执行Shell命令"></a>在Obsidian中执行Shell命令</h2><p>在Community Plugins中搜索<code>Shell Command</code>插件，install 之后记得enable，在Shell Command的设置页面增加<code>pub</code>来进行blog publish，这里要记得绑定到你使用的shell上，比如zsh。</p>
<p>我这里会增加两个快捷命令</p>
<h3 id="第一个是preview"><a href="#第一个是preview" class="headerlink" title="第一个是preview"></a>第一个是preview</h3><p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220504090032.png"></p>
<h3 id="第二个是publish"><a href="#第二个是publish" class="headerlink" title="第二个是publish"></a>第二个是publish</h3><p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220503180128.png" alt="publish"></p>
<p>直接使用快捷键<code>Command+P</code>唤出<code>command pelette</code>输入<code>preview</code>即可本地预览，输入<code>pub</code>即可发布Blog，当然也可以绑定快捷键直接操作，在github上就能看到Github Page相关的action已经执行了，博客成功发布。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220503164014.png"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://www.ruanyifeng.com/blog/2020/08/rsync.html">rsync 用法教程</a></li>
<li><a href="https://unix.stackexchange.com/questions/203846/how-to-sync-two-folders-with-command-line-tools">How to sync two folders with command line tools?</a></li>
<li><a href="https://forum.obsidian.md/t/mobile-setting-up-ios-git-based-syncing-with-mobile-app-using-working-copy/16499">https://forum.obsidian.md/t/mobile-setting-up-ios-git-based-syncing-with-mobile-app-using-working-copy/16499</a></li>
</ol>
]]></content>
      <categories>
        <category>obsidian</category>
      </categories>
      <tags>
        <tag>linux/rsync obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>10款插件让你的Obsidian更加好用</title>
    <url>/2022/05/05/Awesome%20Obsidian%20plugins%20I%20use/</url>
    <content><![CDATA[<p>Obsidian 是一款非常优秀的<code>双链笔记</code>软件，用它可以很方便的来管理自己的笔记，打造自己的数字花园（Digital Garden），虽然和Roam等纯粹的Outliner型笔记不太一样，它基于纯文本md文件，且支持文件夹，给了一些用户选择的自由，最重要的是启动速度很快（特别是和Notion相比，虽然是基于Electron的，不知道用了什么黑魔法）</p>
<p>同时Obsidian也是一款非常好用的写作软件，支持<code>Live Preview</code>的模式，类似于Typora的效果，个人感觉体验很好。</p>
<p>Obsidian是以Plugin化的形式设计的，很多核心的功能也都是以Plugin的形式出现的，这给了用户自由定制的空间，当然这也提高了上手的难度，无形中劝退了不少人，但是Plugin的形式会让这个软件生命力得到释放，社区的优秀的插件数量很多，用户可以根据自己的喜好自己定制自己的Obsidian，我想这也是Obsidian最吸引人的地方之一。</p>
<p>下面就介绍10款我平时用的最多的第三方插件，可以让你的Obsidian更加易用。</p>
<h2 id="外观插件"><a href="#外观插件" class="headerlink" title="外观插件"></a>外观插件</h2><span id="more"></span>

<h3 id="Hider"><a href="#Hider" class="headerlink" title="Hider"></a>Hider</h3><p>Obsidian官方主题是在是有点丑，我这边使用排名第一个主题 <code>Minimal Theme</code> 简约大气，使用Hider搭配这个主题可以隐藏掉界面上不想看到的元素，比如<code>vault name</code>， <code>title bar</code>等，搭配<code>Minimal Theme</code>简直完美</p>
<p><img src="https://github.com/kepano/obsidian-minimal/raw/master/assets/minimal-variants.png" alt="Minimal Theme"></p>
<h3 id="Obsidian-File-Explorer-Count"><a href="#Obsidian-File-Explorer-Count" class="headerlink" title="Obsidian File Explorer Count"></a>Obsidian File Explorer Count</h3><p>顾名思义，就是在Obsidian的文件管理器上显示笔记的数量，很直观建议安装。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220505130444.png"></p>
<h2 id="绘图插件"><a href="#绘图插件" class="headerlink" title="绘图插件"></a>绘图插件</h2><h3 id="ExcaliDraw"><a href="#ExcaliDraw" class="headerlink" title="ExcaliDraw"></a>ExcaliDraw</h3><p>免费的手绘白板软件，一些简单的绘图可以用它来画，很有质感，搭配Obsidian很有质感，间接省了一个ipad和还有一支笔。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220505125742.png"></p>
<h3 id="Diagram"><a href="#Diagram" class="headerlink" title="Diagram"></a>Diagram</h3><p>Diagram是在Obsidian上的drawio<sup>1</sup> ，drawio是我最喜欢的开源流程图工具，使用jira的人肯定对这个工具不陌生， 图片是svg格式的，在Obsidian里可以直接使用<code>![[]]</code> 引用在正文中显示。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220505125950.png"></p>
<h3 id="Plantuml"><a href="#Plantuml" class="headerlink" title="Plantuml"></a>Plantuml</h3><p>Plantuml<sup>2</sup> 是开源的文本绘图工具，可以直接使用代码块来进行绘图，搭配上面的drawio来说基本上已经满足所有的绘图需求。</p>
<h2 id="效率提升插件"><a href="#效率提升插件" class="headerlink" title="效率提升插件"></a>效率提升插件</h2><h3 id="QuickAdd"><a href="#QuickAdd" class="headerlink" title="QuickAdd"></a>QuickAdd</h3><p>这个插件，可以让我们预定义一些快捷的指令来记录一些具体格式的内容，也可以用它可以capture内容到指定文件，这个功能应该是借鉴于 Emacs 的 <code>org-mode</code>。<br>可以用它来记录闪念笔记，也可以指定模板来快速生成Blog，可以用它来帮你配置更多高级的功能。</p>
<p>可以点击<a href="https://www.youtube.com/watch?v=gYK3VDQsZJo&ab_channel=ChristianB.B.Houmann">How to use QuickAdd for Obsidian - with examples</a>进一步学习使用。</p>
<h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><p>可以使用query来查询散落在各个页面中的task也就是todo，这样就可以无拘束的在各个页面写下自己要做的事情，心智负担为0</p>
<p>比如可以展示出来我的write的tasks</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/iShot_2022-05-05_12.49.35.gif"></p>
<h3 id="Image-auto-upload-Plugin"><a href="#Image-auto-upload-Plugin" class="headerlink" title="Image auto upload Plugin"></a>Image auto upload Plugin</h3><p>这个插件配合Picgo<sup>3</sup> 很方便的在Obsidian里插入图片，自动上传到图床，让markdown配图变成一件<br>简单的事情，尤其是对写Blog而言。</p>
<h2 id="笔记插件"><a href="#笔记插件" class="headerlink" title="笔记插件"></a>笔记插件</h2><h3 id="Random-Note"><a href="#Random-Note" class="headerlink" title="Random Note"></a>Random Note</h3><p>这个经常用到，在复习笔记的时候很有用，点击之后会随机打开一篇笔记，类似维基百科的随机条目，对于庞大的笔记系统来说可以说是必备的插件。<img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220505100237.png"></p>
<h3 id="Hypothsis"><a href="#Hypothsis" class="headerlink" title="Hypothsis"></a>Hypothsis</h3><p>主要用来管理网页上的标柱信息，能够很方便的将网页上的高亮文本同步到Obsidian中，还可以自己写备注信息，添加标签等，可以很有效的捕捉上网的时候的灵感。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://github.com/jgraph/drawio">https://github.com/jgraph/drawio</a></li>
<li><a href="https://github.com/plantuml/plantuml">https://github.com/plantuml/plantuml</a></li>
<li><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></li>
<li><a href="https://github.com/chhoumann/quickadd">https://github.com/chhoumann/quickadd</a></li>
<li><a href="https://sspai.com/post/69375">https://sspai.com/post/69375</a></li>
<li><a href="https://catcoding.me/p/obsidian-for-programmer/">https://catcoding.me/p/obsidian-for-programmer/</a></li>
</ol>
]]></content>
      <categories>
        <category>obsidian</category>
      </categories>
      <tags>
        <tag>tools/obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Middle Server解决浏览器CORS跨域问题</title>
    <url>/2022/05/12/How%20to%20resolve%20CORS%20problem/</url>
    <content><![CDATA[<h2 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h2><p>最近学了Typescript写了一个Obsidian微信读书的插件<a href="https://github.com/zhaohongxuan/obsidian-weread-plugin">Obsidian Weread Plugin</a>，在写插件的过程中需要跨域请求<code>r.qq.com</code>来获取微信读书的书摘和想法。</p>
<p>使用axios在vscode中运行api测试的时候是好的，在obsidian中产生了<code>CORS</code>的问题，这是因为Obsidian本质上是一个Electron的app，本质上也是一个浏览器，所以才会出现跨域问题。</p>
<p>关于CORS的文章已经很多了，推荐参考Mozila <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a>，作为一个后端开发，CORS 并不陌生，，对于Spring全家桶用户来说，就是几行<code>@CrossOrigin</code>的配置问题，但是这一篇文章提供的是<code>前端视角</code>来解决CORS的思路，也就是说对服务端不可控时如何处理？</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>我们都知道CORS本身只是对浏览器才会限制，所以可以跳出来使用代理服务器来解决问题，这里刚开始，我建立了一个Springboot的Web项目专门转发来自Obsidian的请求，将请求转发到r.qq.com，这样能够正常工作，但是也印出来了另外一个问题：</p>
<p>每次使用Weread插件的时候，我都需要把SpringBoot项目启动起来，显然不够<code>优雅</code>。特别是后面插件上架了Obsidian的社区市场之后肯定更不行，你不可能要求用户自己再额外下载一个服务器来运行。</p>
<p>那么是否可以找到一个可以在前端使用的middle server呢？ 答案是可以！那就是<a href="https://github.com/chimurai/http-proxy-middleware">http-proxy-middleware</a></p>
<span id="more"></span>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="Http-Proxy-Middleware"><a href="#Http-Proxy-Middleware" class="headerlink" title="Http Proxy Middleware"></a>Http Proxy Middleware</h3><p>它是基于node开发的简单的中间层代理，搭配express使用非常简单，完全服务我的需求：<br>在Obsidian中启动Weread Plugin同步任务的时候，首先启动server，绑定一个端口</p>
<p>当用户在obsidian里点击同步的时候，实际上在所有的网络请求之前我会启动一个middle server，然后绑定到一个端口，这里写的是<code>12011</code>，然后实现onProxyRes方法，将服务器返回的<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，然后插件认为没有跨域，所以能够正常和微信阅读服务器进行通讯。</p>
<p>这里由于微信读书API只能通过<code>cookie</code>的方式来进行认证，所以将setting中的cookie设置到proxyReq上面，这样就模拟了网页端的请求。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">startMiddleServer</span>(<span class="attr">app</span>: <span class="built_in">any</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Server</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> cookie = <span class="variable language_">this</span>.<span class="property">settings</span>.<span class="property">cookie</span>;</span><br><span class="line">		<span class="keyword">if</span> (cookie === <span class="literal">undefined</span> || cookie == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Notice</span>(<span class="string">&#x27;cookie未设置，请填写Cookie&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> escapeCookie = <span class="variable language_">this</span>.<span class="title function_">escapeCookie</span>(cookie);</span><br><span class="line">		app.<span class="title function_">use</span>(</span><br><span class="line">			<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">			<span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line">				<span class="attr">target</span>: <span class="string">&#x27;https://i.weread.qq.com&#x27;</span>,</span><br><span class="line">				<span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">				<span class="attr">onProxyReq</span>: <span class="keyword">function</span> (<span class="params">proxyReq, req, res</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;Cookie&#x27;</span>, escapeCookie);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">						<span class="keyword">new</span> <span class="title class_">Notice</span>(<span class="string">&#x27;cookie 设置失败，检查Cookie格式&#x27;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">onProxyRes</span>: <span class="keyword">function</span> (<span class="params">proxyRes, req, <span class="attr">res</span>: <span class="title class_">ServerResponse</span></span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (res.<span class="property">statusCode</span> != <span class="number">200</span>) &#123;</span><br><span class="line">						<span class="keyword">new</span> <span class="title class_">Notice</span>(<span class="string">&#x27;获取微信读书服务器数据异常！&#x27;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					proxyRes.<span class="property">headers</span>[<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">const</span> server = app.<span class="title function_">listen</span>(<span class="number">12011</span>);</span><br><span class="line">		<span class="keyword">return</span> server;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在进行API调用的时候绑定到上面的代理端口<code>12011</code>上。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">readonly</span> <span class="attr">baseUrl</span>: <span class="built_in">string</span> = <span class="string">&#x27;http://localhost:12011&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getWereadNotebooks</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> noteBooks = [];</span><br><span class="line">			<span class="keyword">const</span> resp = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">baseUrl</span> + <span class="string">&#x27;/user/notebooks&#x27;</span>, &#123;&#125;);</span><br><span class="line">			noteBooks = resp.<span class="property">data</span>.<span class="property">books</span>;</span><br><span class="line">			<span class="keyword">return</span> noteBooks;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Notice</span>(</span><br><span class="line">				<span class="string">&#x27;Failed to fetch weread notebooks . Please check your Cookie and try again.&#x27;</span></span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>在同步任务结束的时候，调用<code>server</code>的<code>close</code>方法，关闭掉代理服务器，这样就完成了一次同步。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">startSync</span>(<span class="params"><span class="attr">app</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Notice</span>(<span class="string">&#x27;start to sync weread notes!&#x27;</span>);</span><br><span class="line">	<span class="variable language_">this</span>.<span class="title function_">startMiddleServer</span>(app).<span class="title function_">then</span>(<span class="function">(<span class="params">server</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start syncing Weread note...&#x27;</span>);</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">syncNotebooks</span>.<span class="title function_">startSync</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">			server.<span class="title function_">close</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTP server closed &#x27;</span>, res, server);</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Notice</span>(<span class="string">&#x27;weread notes sync complete!&#x27;</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样代理服务器仅仅会在程序运行的时候启动，不会一直在后台耗着占用我们的CPU资源，算是一种比较完美的解决方案。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></li>
<li><a href="https://github.com/chimurai/http-proxy-middleware">https://github.com/chimurai/http-proxy-middleware</a></li>
</ol>
]]></content>
      <categories>
        <category>obsidian</category>
      </categories>
      <tags>
        <tag>obsidian</tag>
        <tag>cors</tag>
        <tag>http</tag>
        <tag>midderServer</tag>
      </tags>
  </entry>
  <entry>
    <title>微信读书Cookie自动延期机制分析</title>
    <url>/2022/05/16/how-to-relong-cookies-in-weread/</url>
    <content><![CDATA[<blockquote>
<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_is_stateless_but_not_sessionless">无状态</a>的HTTP协议记录稳定的状态信息成为了可能。</p>
</blockquote>
<h2 id="分析Cookie"><a href="#分析Cookie" class="headerlink" title="分析Cookie"></a>分析Cookie</h2><h3 id="登录之前"><a href="#登录之前" class="headerlink" title="登录之前"></a>登录之前</h3><p>在进入到weread.qq.com的时候，就已经存在Cookie信息了，只不过一部分的Cookie信息是空的，<br>下面是扫码登录之前的Cookie信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220516161146.png"></p>
<span id="more"></span>

<h3 id="扫码登录"><a href="#扫码登录" class="headerlink" title="扫码登录"></a>扫码登录</h3><p>微信读书网页版获取Cookie的流程</p>
<ol>
<li>获取用户uid ，<a href="https://weread.qq.com/web/login/getuid%EF%BC%8C%E5%89%8D%E7%AB%AFjs%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAuid%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%9C%BA%E5%88%B6%E4%B8%8D%E6%B8%85%E6%A5%9A%E3%80%82">https://weread.qq.com/web/login/getuid，前端js生成一个uid，这个机制不清楚。</a></li>
<li>获取登录用户扫码信息，<a href="https://weread.qq.com/web/login/getinfo%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%BC%9A%E4%B8%80%E7%9B%B4pending%EF%BC%8C%E7%9B%B4%E5%88%B0%E4%BD%A0%E6%89%AB%E7%A0%81%EF%BC%8C%E7%84%B6%E5%90%8E%E8%8E%B7%E5%8F%96%E5%88%B0%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E3%80%82">https://weread.qq.com/web/login/getinfo，这个请求会一直pending，直到你扫码，然后获取到用户信息。</a></li>
<li>网页登录，<a href="https://weread.qq.com/web/login/weblogin%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%BA%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E5%88%B0%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF%E4%B9%8B%E5%90%8E%E4%BC%9A%E7%AB%8B%E5%8D%B3%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95%E3%80%82">https://weread.qq.com/web/login/weblogin，使用第二步的获取到网页信息之后会立即进行登录。</a></li>
<li>session初始化，<a href="https://weread.qq.com/web/login/session/init%EF%BC%8C%E6%A0%B9%E6%8D%AE%E7%99%BB%E5%BD%95%E7%9A%84%E4%BF%A1%E6%81%AF%E5%88%9D%E5%A7%8B%E5%8C%96session%EF%BC%8C%E7%84%B6%E5%B0%B1%E8%BF%94%E5%9B%9E4%E4%B8%AAhttpOnly%E7%9A%84cookie%E4%BF%A1%E6%81%AF%EF%BC%8ChttpOnly%E7%9A%84cookie%E4%BF%A1%E6%81%AF%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%60document.cookie%60">https://weread.qq.com/web/login/session/init，根据登录的信息初始化session，然就返回4个httpOnly的cookie信息，httpOnly的cookie信息不能通过`document.cookie`</a> 这个也解释了之前在console中获取的cookie无法正常使用的问题。可以看到<code>wr_skey</code>的有效期只有5400秒，过了这个有效期，调用API接口会响应401，所以关键信息也就是如何更新这个<code>wr_skey</code>是关键。</li>
<li>获取用户信息， <a href="https://weread.qq.com/web/user?userVid=xxx">https://weread.qq.com/web/user?userVid=xxx</a> 这里会根据uid查询用户的基本信息，然后放入Cookie中。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220516160707.png"></li>
</ol>
<h2 id="延长Cookie"><a href="#延长Cookie" class="headerlink" title="延长Cookie"></a>延长Cookie</h2><p>在cookie过期的时候刷新一下网页发现服务器都会自动返回<code>set-cookie</code>字段来更新<code>wr_skey</code>字段以及有效期。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220516174817.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="根据时间刷新"><a href="#根据时间刷新" class="headerlink" title="根据时间刷新"></a>根据时间刷新</h3><ol>
<li>在middle server中增加代理<code>/refresh</code>，重定向<code>https://weread.qq.com</code>用来刷新Cookie</li>
<li>设置完Cookie的时候，保存Cookie的存储时间</li>
<li>点击同步按钮的时候校验Cookie的存储时间，超过1个小时，则调用refresh刷新Cookie，超过一个小时会请求一次首页，获取set-cookie中新的cookie字段。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">app</span>.<span class="title function_">use</span>(</span><br><span class="line">	<span class="string">&#x27;/refresh&#x27;</span>,</span><br><span class="line">	<span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line">		<span class="attr">target</span>: <span class="string">&#x27;https://weread.qq.com&#x27;</span>,</span><br><span class="line">		<span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">			<span class="string">&#x27;^/refresh&#x27;</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">onProxyReq</span>: <span class="keyword">function</span> (<span class="params">proxyReq, req, res</span>) &#123;</span><br><span class="line">			<span class="keyword">const</span> cookie = <span class="title function_">getEncodeCookieString</span>();</span><br><span class="line">			proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;Cookie&#x27;</span>, cookie);</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">onProxyRes</span>: <span class="keyword">function</span> (<span class="params">proxyRes, req, <span class="attr">res</span>: <span class="title class_">ServerResponse</span></span>) &#123;</span><br><span class="line">			proxyRes.<span class="property">headers</span>[<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			proxyRes.<span class="property">headers</span>[<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			<span class="keyword">const</span> <span class="attr">respCookie</span>: <span class="built_in">string</span>[] = proxyRes.<span class="property">headers</span>[<span class="string">&#x27;set-cookie&#x27;</span>];</span><br><span class="line">			<span class="keyword">if</span> (respCookie) &#123;</span><br><span class="line">				<span class="title function_">updateCookies</span>(respCookie);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用axios来访问<code>/refresh</code> endpoint,这里使用<code>head</code>方法就够了，只需要获取head里的set cookie字段而已，不需要使用<code>get</code>方法获取整个html文档，使用get会降低请求速度。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">refreshCookie</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">await</span> axios.<span class="title function_">head</span>(<span class="variable language_">this</span>.<span class="property">baseUrl</span> + <span class="string">&#x27;/refresh&#x27;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Notice</span>(<span class="string">&#x27;刷新Cookie失败&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据401报错重试"><a href="#根据401报错重试" class="headerlink" title="根据401报错重试"></a>根据401报错重试</h3><p>如果在使用Obsidian的过程中，又在其他浏览器里刷新了微信读书的页面，会导致Obsidian的Cookie提前失效，这个时候Obsidian中在进行同步会发生401报错。</p>
<p>这里我在middle server中代理返回401的时候刷新cookie，同时在获取getNotebook的时候设置401重试，这样就算在别的浏览器里登录，Obsidian也会自动进行Cookie刷新，不让用户察觉到Cookie的存在。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">app</span>.<span class="title function_">use</span>(</span><br><span class="line">		<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">		<span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line">			<span class="attr">target</span>: <span class="string">&#x27;https://i.weread.qq.com&#x27;</span>,</span><br><span class="line">			<span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">			<span class="attr">onProxyReq</span>: <span class="keyword">function</span> (<span class="params">proxyReq, req, res</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">const</span> cookie = <span class="title function_">getEncodeCookieString</span>();</span><br><span class="line">					proxyReq.<span class="title function_">setHeader</span>(<span class="string">&#x27;Cookie&#x27;</span>, cookie);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">Notice</span>(<span class="string">&#x27;cookie 设置失败，检查Cookie格式&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">onProxyRes</span>: <span class="keyword">function</span> (<span class="params">proxyRes, req, <span class="attr">res</span>: <span class="title class_">ServerResponse</span></span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (proxyRes.<span class="property">statusCode</span> == <span class="number">401</span>) &#123;</span><br><span class="line">					<span class="title function_">refreshCookie</span>(<span class="literal">true</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (proxyRes.<span class="property">statusCode</span> != <span class="number">200</span>) &#123;</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">Notice</span>(<span class="string">&#x27;获取微信读书服务器数据异常！&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				proxyRes.<span class="property">headers</span>[<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">				proxyRes.<span class="property">headers</span>[<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cooki">HTTP cookies</a></li>
</ol>
]]></content>
      <categories>
        <category>obsidian</category>
      </categories>
      <tags>
        <tag>obsidian</tag>
        <tag>微信读书</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>微信读书Obsidian实现二维码扫描登录</title>
    <url>/2022/05/24/weread-qrcode-login-in-obsidian/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天写了个Obsidian微信读书的插件<a href="https://github.com/zhaohongxuan/obsidian-weread-plugin">GitHub - zhaohongxuan&#x2F;obsidian-weread-plugin</a>，在B站上发了一个视频<a href="https://www.bilibili.com/video/BV1f34y1h7jk#reply114024637264">学了3天typescript写了一个微信读书的Obsidian插件_哔哩哔哩</a>，最初版本是需要手动从控制台<code>复制Cookie</code>设置到设置界面才能使用的，很多B站网友给我私信说获取Cookie有问题，虽然在readme里已经写的很清楚了，但是对小白来说可能这也是个比较困难的步骤，所以我在想是否可以实现二维码扫码登录呢？</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为Obsidian其实也是个浏览器，所以理论上是可以打开浏览器窗口来展示扫码登录界面的。只要load到微信读书的扫码登录界面，然后intercept到请求的header拿到Cookie就可以了，然后后续只要被动刷新Cookie有效期即可。</p>
<p>所以问题就被分成了三部分：</p>
<ol>
<li>展示二维码扫码框</li>
<li>intercept 登录操作获取到Cookie</li>
<li>将Cookie设置到setting 中</li>
</ol>
<span id="more"></span>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="那么如何load微信读书扫码登录页面呢？"><a href="#那么如何load微信读书扫码登录页面呢？" class="headerlink" title="那么如何load微信读书扫码登录页面呢？"></a>那么如何load微信读书扫码登录页面呢？</h3><p>用electron的<a href="https://www.electronjs.org/docs/latest/api/browser-window">BrowserWindow</a>  然后loadURL打开<code>https://r.qq.com#login</code>界面即可展示扫码框。</p>
<h3 id="如何intercept获取到Cookie呢？"><a href="#如何intercept获取到Cookie呢？" class="headerlink" title="如何intercept获取到Cookie呢？"></a>如何intercept获取到Cookie呢？</h3><p>在上篇微信读书Cookie分析 [[2022-05-16-how-to-relong-cookies-in-weread]]的文章里，我已经把微信读书Cookie的机制研究了一遍。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220516161146.png"><br>在登录之前，本地已经有Cookie了，只不过关于用户相关的字段都是空的：<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220516161146.png"><br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220516161146.png"></p>
<p>在登录完成的时候，<code>[初始化会话](https://weread.qq.com/web/login/session/init)</code> 只会获取到4个set-cookie的值，然后调用 <a href="https://weread.qq.com/web/user?userVid=xxx">https://weread.qq.com/web/user?userVid=xxx</a> 再去查一次用户信息把用户信息放入Cookie中。</p>
<p>所以解法变成了intercept用户信息api拿到用户信息自己组装Cookie，但是在实战过程中发现使用eletron的webRequest获取到网络请求的body非常困难，还需要开启debugger才能使用，所以我放弃了。</p>
<p>换个思路，从request header头上找到Cookie不就行了吗？ 但是在扫码登录的session里面，请求任何页面Cookie都是不完整的，除非等到加载用户信息完成之后Cookie才会被补充完整，这个时候再去请求接口的时候Cookie就是完整的。所以解题思路就来了，我们再扫码完成回调之后 reload下页面不就好了吗？</p>
<p>代码比我想想中的要简单太多了：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="variable language_">this</span>.<span class="property">modal</span>.<span class="property">webContents</span>.<span class="property">session</span>;</span><br><span class="line">	<span class="keyword">const</span> filter = &#123;</span><br><span class="line">		<span class="attr">urls</span>: [<span class="string">&#x27;https://weread.qq.com/web/user?userVid=*&#x27;</span>]</span><br><span class="line">	&#125;;</span><br><span class="line">	session.<span class="property">webRequest</span>.<span class="title function_">onSendHeaders</span>(filter, <span class="function">(<span class="params">details</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> cookies = details.<span class="property">requestHeaders</span>[<span class="string">&#x27;Cookie&#x27;</span>];</span><br><span class="line">		<span class="keyword">const</span> cookieArr = <span class="title function_">parseCookies</span>(cookies);</span><br><span class="line">		<span class="keyword">const</span> wr_name = cookieArr.<span class="title function_">find</span>(<span class="function">(<span class="params">cookie</span>) =&gt;</span> cookie.<span class="property">name</span> == <span class="string">&#x27;wr_name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">		<span class="keyword">if</span> (wr_name !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">			settingsStore.<span class="property">actions</span>.<span class="title function_">setCookies</span>(cookieArr);</span><br><span class="line">			settingTab.<span class="title function_">display</span>();</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">modal</span>.<span class="title function_">close</span>();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">modal</span>.<span class="title function_">reload</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>在intercept <a href="https://weread.qq.com/web/user?userVid=">https://weread.qq.com/web/user?userVid=</a> 的时候判断下Cookie中<code>wr_name</code>字段是不是有值就可以了，没有值说明是<code>第一次加载</code>，就原地<code>reload</code>一次，第二次request header里Cookie就是完整的了，这个时候就可以关掉登录窗口了，登录完成。 </p>
<p>这个过程中，在登录窗口关闭之前会有一次刷新操作，不过因为时间非常短，所以这个过程对用户是几乎无感的。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://www.electronjs.org/docs/latest/api/browser-window">BrowserWindow | Electron</a></li>
<li><a href="https://www.electronjs.org/docs/latest/api/web-request">Class: WebRequest | Electron</a></li>
<li><a href="https://zhaohongxuan.github.io/2022/05/16/how-to-relong-cookies-in-weread/">微信读书Cookie自动延期机制分析 | Hank’s Blog</a></li>
<li><a href="https://github.com/zhaohongxuan/obsidian-weread-plugin">GitHub - zhaohongxuan&#x2F;obsidian-weread-plugin</a></li>
</ol>
]]></content>
      <categories>
        <category>obsidian</category>
      </categories>
      <tags>
        <tag>obsidian</tag>
        <tag>二维码登录</tag>
        <tag>electron</tag>
        <tag>BrowserWindow</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring是如何加载BeanDefinition的？</title>
    <url>/2022/06/02/spring-load-bean-definition/</url>
    <content><![CDATA[<p>Spring Bean生命周期中，BeanDefinition是最重要的部分，在初始化和实例化Bean之前，首先要把所有的需要Spring管理的Bean对应的BeanDefinition加载到Spring容器中，这一步非常关键，因为BeanDefinition是Bean关联的元数据，这一篇文章就以<code>AnnotationConfigApplicationContext</code>来分析一下Spring容器是如何加载BeanDefinition的。</p>
<h2 id="第一阶段：扫描Class文件加载BeanDefinition"><a href="#第一阶段：扫描Class文件加载BeanDefinition" class="headerlink" title="第一阶段：扫描Class文件加载BeanDefinition"></a>第一阶段：扫描Class文件加载BeanDefinition</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> &#123;  </span><br><span class="line">   <span class="built_in">this</span>();  </span><br><span class="line">   scan(basePackages);  </span><br><span class="line">   refresh();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先以package的方式来分析，初始化<code>AnnotationConfigApplicationContext</code>的时候会scan对应的包路径，然后进行refresh</p>
<p>scan的动作是在<code>ClassPathBeanDefinitionScanner</code>的doScan方法中完成的,主要任务是查找classpath下面的Class文件，判断是否为Bean，然后生成BeanDefinition。</p>
<span id="more"></span>

<p>主要源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;  </span><br><span class="line"></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();  </span><br><span class="line">   <span class="keyword">for</span> (String basePackage : basePackages) &#123;  </span><br><span class="line">      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);  </span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;  </span><br><span class="line">         <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);  </span><br><span class="line">         candidate.setScope(scopeMetadata.getScopeName());  </span><br><span class="line">         <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);  </span><br><span class="line">         <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;  </span><br><span class="line">            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;  </span><br><span class="line">            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;  </span><br><span class="line">            <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);  </span><br><span class="line">            definitionHolder =  </span><br><span class="line">                  AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);  </span><br><span class="line">            beanDefinitions.add(definitionHolder);  </span><br><span class="line">            registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> beanDefinitions;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="查找候选Component的BeanDefinition集合"><a href="#查找候选Component的BeanDefinition集合" class="headerlink" title="查找候选Component的BeanDefinition集合"></a>查找候选Component的BeanDefinition集合</h3><p>这部分代码主要在ClassPathScanningCandidateComponentProvider</p>
<ol>
<li>将包名转换为path, 通过ResourcePatternResolver来解析得到Class文件的Resource列表， 这里使用了Strategy模式来解析不同类型的资源。</li>
<li>遍历Resource List通过ASM技术将Resource封装为MetadataReader, 这里不使用反射是为了减少内存占用，使用反射必须先将Class文件Load进JVM中，这里使用了Factory模式 来获取MetadataReader</li>
<li>判断是不是候选Component,<ol>
<li>首先判断是不是在excludeFilters里，如果在excludeFilters里直接返回false</li>
<li>判断是不是在includeFilters里，如果在includeFilters里，返回true，否则返回false		</li>
<li>在创建AnnotationConfigApplicationContext的时候默认加载几个DefaultIncludeFilter, 也就是有<code>@Component</code>注解或者JSR-250注解 <code>@javax.inject.Named</code> 或者<code>javax.annotation.ManagedBean</code>, 在这里@Service 和@Controller都是有@Component，所以也都会被扫描到。</li>
<li>创建ScannedGenericBeanDefinition 它的作用是 保存ASM 扫描出来的注解元数据信息</li>
<li>根据AnnotatedBeanDefinition判断是不是一个Component<ol>
<li>独立类，不能是内部类，可以是嵌套类</li>
<li>非抽象类或者接口</li>
<li>有Lookup方法的抽象类</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="遍历符合条件的Component的BeanDefinition集合"><a href="#遍历符合条件的Component的BeanDefinition集合" class="headerlink" title="遍历符合条件的Component的BeanDefinition集合"></a>遍历符合条件的Component的BeanDefinition集合</h3><ol>
<li>解析ScopeMetadata,默认是Singleton,ScopedProxyMode是NO，ScopedProxyMode主要是非单例的Scope上使用，可以配置使用CGlib代理或者JDK动态代理</li>
<li>使用BeanNameGenerator生成BeanName，这里使用了Singlenton模式, 如果注解上有beanName就使用注解上的，没有的话就根据类名生成一个BeanName</li>
<li>如果是AbstractBeanDefinition则给BeanDefinition设置默认属性</li>
<li>如果是AnnotatedBeanDefinition则解析Component上的注解比如@Lazy，@Primary等属性到BeanDefination中</li>
<li>检查Component, 判断容器中是不是已经存在这个Bean,如果存在，则判断对象是不是相等，如果不相等说明不合法，Spring抛出ConflictingBeanDefinitionException中断加载。</li>
<li>创建BeanDefinitionHolder，主要是为了保存alias，默认alias为空</li>
<li>将beanDefinition注册到容器中，如果alias不为空，给bean注册alias，这里默认不注册</li>
</ol>
<h2 id="第二阶段：refresh过程中加载BeanDefinition"><a href="#第二阶段：refresh过程中加载BeanDefinition" class="headerlink" title="第二阶段：refresh过程中加载BeanDefinition"></a>第二阶段：refresh过程中加载BeanDefinition</h2><p>scan这一步，加载了classpath中的BeanDefinition，但是这一步只是最基础的，Spring容器在refresh阶段也留给用户一个hook方法，让用户在生成Bean之前能够自己操作BeanDefinition，这个hook就是<code>BeanDefinitionRegistryPostProcessor</code>我们可以自己自定义一个类实现它来自定义处理BeanDefinition。<br>Spring内部也有一些内置的BeanDefinitionRegistryPostProcessor，比如处理<code>@Configuration</code>的ConfigurationClassPostProcessor，Configuration Class中一般都会包含不少配置信息，比如<code>@Import</code>，<code>@Bean</code>等，我们就需要在bean实例化之前加载进Spring容器。</p>
<p>那么Configuration Class是什么时候处理的呢？ 答案是在 <code>refresh</code>阶段的<code>invokeBeanFactoryPostProcessors</code>中，主要源代码在下面<code>PostProcessorRegistrationDelegate</code>中的<code>invokeBeanFactoryPostProcessors</code>方法中。</p>
<p>因为ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor接口，所以会在这一步被调用，进而对ConfigurationClass进行解析。</p>
<h3 id="ConfigurationClassPostProcessor处理BeanDefinition解析"><a href="#ConfigurationClassPostProcessor处理BeanDefinition解析" class="headerlink" title="ConfigurationClassPostProcessor处理BeanDefinition解析"></a>ConfigurationClassPostProcessor处理BeanDefinition解析</h3><p><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20220604082945.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;  </span><br><span class="line">   <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);  </span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(  </span><br><span class="line">            <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(  </span><br><span class="line">            <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="built_in">this</span>.registriesPostProcessed.add(registryId);  </span><br><span class="line">  </span><br><span class="line">   processConfigBeanDefinitions(registry);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中processConfigBeanDefinitions 来处理ConfigBean，最重要的逻辑代码在 <code>ConfigurationClassParser</code>的<code>parse</code> ConfigurationClassParser 解析 和<code>doProcessConfigurationClass</code>方法中, 这个方法会处理main class上面的annotation，比如Component，ComponentScan等</p>
<h3 id="processConfigBeanDefinitions"><a href="#processConfigBeanDefinitions" class="headerlink" title="processConfigBeanDefinitions"></a>processConfigBeanDefinitions</h3><p>在ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry里面主要就是扫描BeanDefinitionRegistry 处理里面的有@Configuration的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;  </span><br><span class="line">   <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName); </span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 校验是不是@Configuration标注的Class，是的话放入configCandidates中</span></span><br><span class="line"> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;  </span><br><span class="line">      configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建 Parser</span></span><br><span class="line"><span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(  </span><br><span class="line">      <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,  </span><br><span class="line">      <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. parse Config类</span></span><br><span class="line">parser.parse(candidates);  </span><br><span class="line">parser.validate();  </span><br><span class="line">  </span><br><span class="line">Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.加载BeanDefinition</span></span><br><span class="line"><span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span>(!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要抽象成4步</p>
<ul>
<li>校验是不是@Configuration标注的Class，是的话放入configCandidates中</li>
<li>创建 ConfigurationClassParser</li>
<li>parse ConfigurationClass </li>
<li>加载BeanDefinition</li>
</ul>
<h3 id="加载BeanDefinition"><a href="#加载BeanDefinition" class="headerlink" title="加载BeanDefinition"></a>加载BeanDefinition</h3><p>源码在ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass</p>
<p>主要步骤为</p>
<ul>
<li>TrackedConditionEvaluator判断是否应该skip</li>
<li>注册import的class的BeanDefinition</li>
<li>注册@Bean标注的method</li>
<li>注册imported的resources的BeanDefinition, 比如说 <code>importXML</code>等</li>
<li>注册ImportBeanDefinitionRegistrar ，比如说各种<code>@EnableXXX</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForConfigurationClass</span><span class="params">(  </span></span><br><span class="line"><span class="params">      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;  </span><br><span class="line">      <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> configClass.getBeanName();  </span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.registry.containsBeanDefinition(beanName)) &#123;  </span><br><span class="line">         <span class="built_in">this</span>.registry.removeBeanDefinition(beanName);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="built_in">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());  </span><br><span class="line">      <span class="keyword">return</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (configClass.isImported()) &#123;  </span><br><span class="line">      registerBeanDefinitionForImportedConfigurationClass(configClass);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;  </span><br><span class="line">      loadBeanDefinitionsForBeanMethod(beanMethod);  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());  </span><br><span class="line">   loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里就看到了Spring boot中常见的<code>ImportBeanDefinitionRegistrar</code>的身影， 一般搭配<code>XXXAuthConfiguration</code>，<code>@ConditionalOnClass</code> 实现Springboot的自动装配功能。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config">Spring Reference Core Technologies</a></li>
<li><a href="https://github.com/spring-projects/spring-framework">GitHub - spring-projects&#x2F;spring-framework: Spring Framework</a></li>
</ol>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>java/spring</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot是如何启动的？</title>
    <url>/2022/06/05/spring-bootstrap-source-code/</url>
    <content><![CDATA[<h2 id="Spring-Boot-启动"><a href="#Spring-Boot-启动" class="headerlink" title="Spring Boot 启动"></a>Spring Boot 启动</h2><p>SpringBoot的启动类很简单，只需要调用<code>SpringApplication</code>的run方法即可，这篇文章来分析一下SpringBoot的启动类<code>SpringApplication</code>初始化的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    SpringApplication.run(Application.class, args);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SpingApplication 中 初始化了一个SpringApplication, 参数是当前SpringBoot启动的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringApplication初始化"><a href="#SpringApplication初始化" class="headerlink" title="SpringApplication初始化"></a>SpringApplication初始化</h2><ul>
<li>从classpath推断 <code>webApplicationType</code> </li>
<li>设置Initializers</li>
<li>设置Listeners</li>
<li>推断main class,主要用于log print以及banner print</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;  </span><br><span class="line">   <span class="built_in">this</span>.resourceLoader = resourceLoader;  </span><br><span class="line">   Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);  </span><br><span class="line">   <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));  </span><br><span class="line">   <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();  </span><br><span class="line">   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));  </span><br><span class="line">   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));  </span><br><span class="line">   <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="推断webApplicationType"><a href="#推断webApplicationType" class="headerlink" title="推断webApplicationType"></a>推断webApplicationType</h3><p>从classpath推断 <code>webApplicationType</code> , 主要有三种，NONE&#x2F;SERVLET&#x2F;REACTIVE<br>默认情况下是SERVLET，也就是说Springboot会默认启动一个embed的tomcat服务器，用的也是最广泛的。</p>
<h3 id="设置Initializers和Listeners"><a href="#设置Initializers和Listeners" class="headerlink" title="设置Initializers和Listeners"></a>设置Initializers和Listeners</h3><p>设置Initializers和设置Liteners 都是通过spring.factories来加载的</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220224164227.png"></p>
<p>从源码中分析</p>
<h4 id="getSpringFactoriesInstances"><a href="#getSpringFactoriesInstances" class="headerlink" title="getSpringFactoriesInstances"></a>getSpringFactoriesInstances</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;  </span><br><span class="line">   <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();  </span><br><span class="line">   <span class="comment">// Use names and ensure unique to protect against duplicates  </span></span><br><span class="line"> Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));  </span><br><span class="line">   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);  </span><br><span class="line">   AnnotationAwareOrderComparator.sort(instances);  </span><br><span class="line">   <span class="keyword">return</span> instances;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SpringFactoriesLoader-loadFactoryNames"><a href="#SpringFactoriesLoader-loadFactoryNames" class="headerlink" title="SpringFactoriesLoader.loadFactoryNames"></a>SpringFactoriesLoader.loadFactoryNames</h4><p>主要作用是从Springboot的jar包中加载 <code>spring.factories</code>文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;  </span><br><span class="line">   MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);  </span><br><span class="line">   <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> result;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">try</span> &#123;  </span><br><span class="line">      Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ?  </span><br><span class="line">            classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :  </span><br><span class="line">            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));  </span><br><span class="line">      result = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();  </span><br><span class="line">      <span class="keyword">while</span> (urls.hasMoreElements()) &#123;  </span><br><span class="line">         <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();  </span><br><span class="line">         <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);  </span><br><span class="line">         <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);  </span><br><span class="line">         <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();  </span><br><span class="line">            <span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;  </span><br><span class="line">               result.add(factoryTypeName, factoryImplementationName.trim());  </span><br><span class="line">            &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      cache.put(classLoader, result);  </span><br><span class="line">      <span class="keyword">return</span> result;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +  </span><br><span class="line">            FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用Classloader 从<code>FACTORIES_RESOURCE_LOCATION</code>加载Resource，然后根据resource来解析成为Properties文件，然后再解析成Map.</p>
<h4 id="createSpringFactoriesInstances"><a href="#createSpringFactoriesInstances" class="headerlink" title="createSpringFactoriesInstances"></a>createSpringFactoriesInstances</h4><p>这一步的目的是根据上一步load出来的Class来创建Factory实例，使用反射的方式进行创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">                                                   ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> &#123;</span><br><span class="line">    List&lt;T&gt; instances = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(names.size());</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">            Assert.isAssignable(type, instanceClass);</span><br><span class="line">            Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">            <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">            instances.add(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot instantiate &quot;</span> + type + <span class="string">&quot; : &quot;</span> + name, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220303145114.png"></p>
<p>默认的Spring boot包中的spring.factories中有5个initializer，spring boot autoconfig 中有2个initializer</p>
<h3 id="推断包含main方法的主类"><a href="#推断包含main方法的主类" class="headerlink" title="推断包含main方法的主类"></a>推断包含main方法的主类</h3><p>主要是根据StackTrace遍历当前的方法调用栈拿到主类。</p>
<h2 id="SpringApplication-Run-方法解析"><a href="#SpringApplication-Run-方法解析" class="headerlink" title="SpringApplication  Run 方法解析"></a>SpringApplication  Run 方法解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">	<span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();  </span><br><span class="line">	<span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> createBootstrapContext();  </span><br><span class="line">	<span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">	configureHeadlessProperty();  </span><br><span class="line">	<span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);  </span><br><span class="line">	listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">		<span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		<span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">		prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">		refreshContext(context);</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		listeners.started(context);</span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="createBootstrapContext"><a href="#createBootstrapContext" class="headerlink" title="createBootstrapContext"></a>createBootstrapContext</h3><p>BootstrapContext的主要作用是在ApplicationContext prepared之前提供singletons的lazy access活着是共享给其他类访问。</p>
<p>在ApplicationContext prepared完成 [[Spring Boot 初始化#prepareContext]]之后BootstrapContext就会被close掉，然后广播一个BootstrapContextClosedEvent给到其他Bean</p>
<h3 id="prepareEnvironment"><a href="#prepareEnvironment" class="headerlink" title="prepareEnvironment"></a>prepareEnvironment</h3><ul>
<li>根据webApplicationType创建Environment</li>
<li>配置Environment</li>
<li>attach ConfigurationPropertySource也就是ConfigurationProperties到environment</li>
<li>给SpringApplicationRunListener 广播environmentPrepared的Event</li>
<li>Bind Environment to Spring Application</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,  </span></span><br><span class="line"><span class="params">      ApplicationArguments applicationArguments)</span> &#123;  </span><br><span class="line">   <span class="comment">// Create and configure the environment  </span></span><br><span class="line"> <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> getOrCreateEnvironment();  </span><br><span class="line">   configureEnvironment(environment, applicationArguments.getSourceArgs());  </span><br><span class="line">   ConfigurationPropertySources.attach(environment);  </span><br><span class="line">   listeners.environmentPrepared(environment);  </span><br><span class="line">   bindToSpringApplication(environment);  </span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.isCustomEnvironment) &#123;  </span><br><span class="line">      environment = <span class="keyword">new</span> <span class="title class_">EnvironmentConverter</span>(getClassLoader()).convertEnvironmentIfNecessary(environment,  </span><br><span class="line">            deduceEnvironmentClass());  </span><br><span class="line">   &#125;  </span><br><span class="line">   ConfigurationPropertySources.attach(environment);  </span><br><span class="line">   <span class="keyword">return</span> environment;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="create-Environment"><a href="#create-Environment" class="headerlink" title="create Environment"></a>create Environment</h4><p>根据<code>applicationType</code>来判断初始化哪个Environment</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">getOrCreateEnvironment</span><span class="params">()</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.environment;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;  </span><br><span class="line">   <span class="keyword">case</span> SERVLET:  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardServletEnvironment</span>();  </span><br><span class="line">   <span class="keyword">case</span> REACTIVE:  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardReactiveWebEnvironment</span>();  </span><br><span class="line">   <span class="keyword">default</span>:  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Create-Context"><a href="#Create-Context" class="headerlink" title="Create Context"></a>Create Context</h3><p>SpringBoot默认创建的是 <code>AnnotationConfigApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">	Class&lt;?&gt; contextClass = <span class="built_in">this</span>.applicationContextClass;</span><br><span class="line">	<span class="keyword">if</span> (contextClass == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;</span><br><span class="line">			<span class="keyword">case</span> SERVLET:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> REACTIVE:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">					<span class="string">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化AnnotationConfigApplicationContext的过程中做了这么几件事情：</p>
<h4 id="初始化DefaultListableBeanFactory"><a href="#初始化DefaultListableBeanFactory" class="headerlink" title="初始化DefaultListableBeanFactory"></a>初始化<code>DefaultListableBeanFactory</code></h4><p>AnnotationConfigApplicationContext继承了<code>GenericApplicationContext</code>  ，所以默认构造器会自动创建DefaultListableBeanFactory的实例，以供后面register beanDefinition和生成bean使用。</p>
<h4 id="初始化-AnnotatedBeanDefinitionReader"><a href="#初始化-AnnotatedBeanDefinitionReader" class="headerlink" title="初始化 AnnotatedBeanDefinitionReader"></a>初始化 <code>AnnotatedBeanDefinitionReader</code></h4><ul>
<li>处理 <code>@Conditional</code> 注解</li>
<li><code>AnnotationConfigUtils.registerAnnotationConfigProcessors()</code> 注册几个处理注解Processors的BeanDefinition到BeanFactory的BeanDefinationMap中，这个是为了在refresh的过程中处理Configuration Class，也就是常说的配置类，这几个Processor分别是：<ul>
<li>ConfigurationClassPostProcessor 用来解析带有@Configuration的类，这个可以参考我之前的文章：<a href="https://zhaohongxuan.github.io/2022/06/02/spring-load-bean-definition/#ConfigurationClassPostProcessor%E5%A4%84%E7%90%86BeanDefinition%E8%A7%A3%E6%9E%90">ConfigurationClassPostProcessor处理BeanDefinition解析</a></li>
<li>AutowiredAnnotationBeanPostProcessor 用来解析Autowired注解，InstantiationAwareBeanPostProcessor，这个特殊的BPP几乎就是在Spring框架内部使用的接口，主要用来处理代理对象或者需要Lazy init的对象的场景使用。</li>
<li>CommonAnnotationBeanPostProcessor，也是一个<code>InstantiationAwareBeanPostProcessor</code>，这个BPP主要用来解析JSR-250注解，比如<code>@PostConstruct</code>,<code>@PreDestry</code>等等</li>
<li>PersistenceAnnotationBeanPostProcessor也是一个<code>InstantiationAwareBeanPostProcessor</code>,主要是支持JPA的 @PersistenceContext和@PersistenceUnit注解</li>
<li>EventListenerMethodProcessor 主要功能把注册在方法上的<code>@EventListener</code>生成独立的ApplicationListener实例，实现Spring的事件驱动。</li>
<li>DefaultEventListenerFactory 结合上面的EventListenerMethodProcessor一起来看，主要是为生成ApplicationListener实例提供默认的工厂方法。</li>
</ul>
</li>
</ul>
<h4 id="初始化-ClassPathBeanDefinitionScanner"><a href="#初始化-ClassPathBeanDefinitionScanner" class="headerlink" title="初始化 ClassPathBeanDefinitionScanner"></a>初始化 <code>ClassPathBeanDefinitionScanner</code></h4><ul>
<li>set environment</li>
<li>set Resource loaders</li>
</ul>
<h3 id="prepareContext-准备springboot应用的上下文"><a href="#prepareContext-准备springboot应用的上下文" class="headerlink" title="prepareContext 准备springboot应用的上下文"></a>prepareContext 准备springboot应用的上下文</h3><ul>
<li>set environment 绑定environment到Context</li>
<li>postProcessApplicationContext<ul>
<li>registerBeanNameGenerator 可以自定义Bean名字</li>
<li>set resource loader</li>
<li>set conversion Service 这里用到了DCL 单例模式</li>
</ul>
</li>
<li>applyInitializers</li>
<li>Add boot specific singleton beans<ul>
<li>springApplicationArguments</li>
<li>spring bootBanner</li>
</ul>
</li>
<li>处理lazy-initialization</li>
<li>load beanDefinition到context中</li>
</ul>
<p>这里面最重要一步是创建BeanDefinitionLoader，BeanDefinitionLoader是springboot的一个加载BeanDefinition的Loader，它可以加载各种各样形式的source，比如package, Configuration class, xml文件,groovy bean等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) &#123;  </span><br><span class="line">   Assert.notNull(registry, <span class="string">&quot;Registry must not be null&quot;</span>);  </span><br><span class="line">   Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);  </span><br><span class="line">   <span class="built_in">this</span>.sources = sources;  </span><br><span class="line">   <span class="built_in">this</span>.annotatedReader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(registry);  </span><br><span class="line">   <span class="built_in">this</span>.xmlReader = <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(registry);  </span><br><span class="line">   <span class="keyword">if</span> (isGroovyPresent()) &#123;  </span><br><span class="line">      <span class="built_in">this</span>.groovyReader = <span class="keyword">new</span> <span class="title class_">GroovyBeanDefinitionReader</span>(registry);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(registry);  </span><br><span class="line">   <span class="built_in">this</span>.scanner.addExcludeFilter(<span class="keyword">new</span> <span class="title class_">ClassExcludeFilter</span>(sources));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>BeanDefinitionLoader的作用就是循环各个 sources 然后创建对应的BeanDefinition然后load到applicationContext 中，解析注解配置的类可以参考之前的文章<a href="https://zhaohongxuan.github.io/2022/06/02/spring-load-bean-definition/">Spring加载BeanDefinition源码解析 | Hank’s Blog</a></p>
<h3 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext"></a>refreshContext</h3><p>上面的阶段只是把bean Definition加载进了context，到了refresh阶段了才会真正生成bean实例，这里spring boot做的工作基本上就结束了，接下来就要交给spring 底层了。</p>
<p>refresh的主要代码在AbstractApplicationContext的refresh方法中，这个后面会专门再写一篇文章。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://github.com/spring-projects/spring-boot">GitHub - spring-projects&#x2F;spring-boot: Spring Boot</a></li>
<li><a href="https://github.com/spring-projects/spring-framework">GitHub - spring-projects&#x2F;spring-framework: Spring Framework</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-load-time-weaver">Core Technologies</a></li>
</ol>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>java/spring</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Jvm Class文件结构</title>
    <url>/2022/07/31/java-hello-world-in-byte/</url>
    <content><![CDATA[<h1 id="理解Jvm-Class-文件结构"><a href="#理解Jvm-Class-文件结构" class="headerlink" title="理解Jvm Class 文件结构"></a>理解Jvm Class 文件结构</h1><p>Class 文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">	u4 magic; //Class 文件的标志</span><br><span class="line">	u2 minor_version;//Class 的小版本号</span><br><span class="line">	u2 major_version;//Class 的大版本号</span><br><span class="line">	u2 constant_pool_count;//常量池的数量</span><br><span class="line">	cp_info constant_pool[constant_pool_count-1];//常量池</span><br><span class="line">	u2 access_flags;//Class 的访问标记</span><br><span class="line">	u2 this_class;//当前类</span><br><span class="line">	u2 super_class;//父类</span><br><span class="line">	u2 interfaces_count;//接口</span><br><span class="line">	u2 interfaces[interfaces_count];//一个类可以实现多个接口</span><br><span class="line">	u2 fields_count;//Class 文件的字段属性</span><br><span class="line">	field_info fields[fields_count];//一个类可以有多个字段</span><br><span class="line">	u2 methods_count;//Class 文件的方法数量</span><br><span class="line">	method_info methods[methods_count];//一个类可以有个多个方法</span><br><span class="line">	u2 attributes_count;//此类的属性表中的属性数</span><br><span class="line">	attribute_info attributes[attributes_count];//属性表集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的这个图更加直观：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20220806135458.png"></p>
<p>使用<code>010 Editor</code> 打开 <code>Hello.class</code> 可以更加直观的查看</p>
<p><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20220806134852.png"></p>
<span id="more"></span>

<p>首先创建一个简单的Hello Word程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后使用 <code>javap -v Hello.class</code> 来将字节码文件生成反汇编文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /Users/xuan/IdeaProjects/learn-spring/target/classes/Hello.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>年<span class="number">7</span>月<span class="number">31</span>日; size <span class="number">548</span> bytes</span><br><span class="line">  SHA-<span class="number">256</span> checksum eaba6958496d3a0d5605df6adb13ad3af4d3c5939bf1244f38b255637eec3c89</span><br><span class="line">  Compiled from <span class="string">&quot;Hello.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #<span class="number">5</span>                          <span class="comment">// Hello</span></span><br><span class="line">  super_class: #<span class="number">6</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">0</span>, methods: <span class="number">2</span>, attributes: <span class="number">1</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">21</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">22.</span>#<span class="number">23</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">24</span>            <span class="comment">// Hello World</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">27</span>            <span class="comment">// Hello</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">28</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               LHello;</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               args</span><br><span class="line">  #<span class="number">17</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">18</span> = Utf8               MethodParameters</span><br><span class="line">  #<span class="number">19</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">20</span> = Utf8               Hello.java</span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">22</span> = Class              #<span class="number">29</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">30</span>:#<span class="number">31</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">24</span> = Utf8               Hello World</span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">32</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">33</span>:#<span class="number">34</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               Hello</span><br><span class="line">  #<span class="number">28</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">29</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">30</span> = Utf8               out</span><br><span class="line">  #<span class="number">31</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">32</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">33</span> = Utf8               println</span><br><span class="line">  #<span class="number">34</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Hello</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   LHello;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">4</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Hello.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification</a></li>
</ol>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>使用chezmoi管理dotfiles</title>
    <url>/2022/08/05/use-chezmoi-manage-dotfiles/</url>
    <content><![CDATA[<h2 id="为什么要管理dotfiles？"><a href="#为什么要管理dotfiles？" class="headerlink" title="为什么要管理dotfiles？"></a>为什么要管理dotfiles？</h2><p>dotfile是对自己的软件配置文件的总称，如果有多台开发设备的话，我们需要在不同的电脑上保持同样的配置，我们对工具的使用不是一成不变的，而是随着时间不断演进的，日常使用的过程中，会不断修改dotfile让工具越来越顺手，这时同步dotfile就变得非常重要了，你的工具的行为在多个平台上应该是一致的，就像VSCode自带的setting 同步功能一样。</p>
<h2 id="dotfiles管理的痛点"><a href="#dotfiles管理的痛点" class="headerlink" title="dotfiles管理的痛点"></a>dotfiles管理的痛点</h2><ul>
<li>dotfile总是分布在不同的位置，想把他们汇总在同一个位置非常不方便，使用软连接之后，用github管理又非常不便。</li>
<li>配置文件的修改不能及时同步到github</li>
<li>多个设备可能跨平台，配置文件可能是不一样的</li>
<li>相同的平台，不同的设备也有差异化的配置，比如工作电脑和自己私人电脑，有一些配置肯定是不一样的</li>
<li>密码管理器，选择自己合适的密码管理软件（）</li>
</ul>
<h2 id="什么是chezmoi？"><a href="#什么是chezmoi？" class="headerlink" title="什么是chezmoi？"></a>什么是chezmoi？</h2><p><a href="https://www.chezmoi.io/">chezmoi</a>是一款使用go语言编写的跨平台的的dot配置管理器，它是一个法语单词，意思是家，读作 &#x2F;ʃeɪ mwa&#x2F; (shay-moi)</p>
<p>chezmoi的工作原理很简单：<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20220806123526.png"></p>
<p>它使用一个working copy来管理dotfiles，<code>chezmoi</code>负责对<code>working copy</code>和<code>home directory</code> 进行同步，然后使用<code>git</code>来管理 <code>working copy</code>和<code>remote repo</code>的差异。</p>
<span id="more"></span>

<h2 id="chezmoi基本使用"><a href="#chezmoi基本使用" class="headerlink" title="chezmoi基本使用"></a>chezmoi基本使用</h2><p>安装非常简单，我使用mac 直接 <code>brew install chezmoi</code> 就行了，如果你使用其他的平台，可以参考：<a href="https://www.chezmoi.io/install/">Install - chezmoi</a></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>如果是初次使用的话，先使用<code>chezmoi init</code>会在<code>~/.local/share/chezmoi</code>创建一个git仓库，这个是local的repo，我们还需要一个remote的repo，我们可以在github上创建一个名字为：<code>dotfiles</code>的Repo来存储自己的dotfiles，dotfiles名字是chezmoi的使用惯例，使用起来更方便，参考<code>### 在其他设备上使用dotfiles</code> 这一章节。</p>
<h3 id="添加dotfile"><a href="#添加dotfile" class="headerlink" title="添加dotfile"></a>添加dotfile</h3><p>添加dotfile到chezomi管理 ，例如 <code>chezmoi add ~/.zshrc</code>  就会把我们的.zshrc文件copy到<code>~/.local/share/chezmoi</code> 中去，并且改名字为：<code>dot_zshrc</code> ，它是和<code>.zshrc</code> 一一对应的，是.zshrc的一份working copy。</p>
<h3 id="编辑dotfile"><a href="#编辑dotfile" class="headerlink" title="编辑dotfile"></a>编辑dotfile</h3><p>一旦添加到chezomoi，编辑<code>.zshrc</code>的时候我们就需要使用 <code>chezmoi edit ~/.zshrc</code>来编辑zshrc文件，这个命令会自动帮我们mapping到 <code>dot_zshrc</code>文件进行修改，当然你也可以直接到<code>~/.local/share/chezmoi</code>  直接编辑<code>dot_zshrc</code>文件，效果是一样的。<br>编辑完成之后，可以使用 <code>chezmoi diff</code> 来查看修改的部分。比如我使用 <code>chezmoi edit ~/.zshrc</code>在文件最后加上<code>alias cm=&#39;chezmoi&#39;</code> ，然后使用 <code>chezmoi diff</code>  命令，可以看到:<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20220806122654.png"><br>然后我们执行<code>chezmoi -v apply</code> 来使dotfile生效，如果你不想每次都<code>chezmoi apply</code><br>可以在<code>~/.config/chezmoi/chezmoi.toml</code>加上下面的配置文件：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[git]</span></span><br><span class="line">    <span class="attr">autoCommit</span> = <span class="literal">true</span></span><br><span class="line">    <span class="attr">autoPush</span> = <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="同步dotfile到github"><a href="#同步dotfile到github" class="headerlink" title="同步dotfile到github"></a>同步dotfile到github</h3><p>我们所做的编辑都只是在本地的working copy，想要在其他的设备上使用，首先要同步到github上，chezomi 把这个权利交给了git，我们可以首先 <code>chezmoi cd</code>  进入到 working copy的文件夹，然后就和普通的git操作一致了：</p>
<ol>
<li><code>git status</code> 来看working copy 工作区的文件状态</li>
<li><code>git add</code> 来把修改过后的dotfile添加到git缓冲区</li>
<li><code>git commit &amp; push</code> 提交dotfile 和push dotfile到github</li>
</ol>
<p>当然你也可以直接使用<code>chezmoi git </code>来进行git的相关操作而不用进入文件夹。</p>
<h2 id="在其他设备上使用dotfiles"><a href="#在其他设备上使用dotfiles" class="headerlink" title="在其他设备上使用dotfiles"></a>在其他设备上使用dotfiles</h2><p>我们维护了dotfiles repo之后，以后我们到其他的设备上初始化的时候直接 <code>chezmoi init --apply username</code>即可，chezmoi会自动到github名字为<code>username</code>的repo下寻找<code>dotfiles</code>的repo来进行初始化，叫这个名字是为了使用方便，也可以使用其他名字，在其他设备上初始化的时候，需要指定github repo的全地址：<code>chezmoi init https://github.com/username/dotfiles.git</code></p>
<h2 id="管理可执行Script"><a href="#管理可执行Script" class="headerlink" title="管理可执行Script"></a>管理可执行Script</h2><p>除了dotfiles 我们一般在开发的过程中会有一些script需要，在各个设备上运行，这个时候就可以设置script，chezmoi的script是在source 文件夹（<code>~/.local/share/chezmoi</code>）以 <code>run_</code> 开头的文件，chezmoi会以按照字母顺序执行，其中，<code>run_once_</code>开头的会执行一次，<br><code>run_onchange_</code>会在每次文件内容有变化的时候执行。<br>具体参考：<a href="https://www.chezmoi.io/user-guide/use-scripts-to-perform-actions/">Use scripts to perform actions - chezmoi</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章只是简单的介绍基本使用，除此之外，还支持 template操作，它可以帮你管理设备之间的差异，还支持多种密码管理器，支持外部文件（比如<code>.oh-my-zsh</code> 以及插件等），可以参考：<a href="https://www.chezmoi.io/user-guide/command-overview/">Command overview - chezmoi</a>  获取更多信息。</p>
<p>最后放上我的dotfile仓库：<a href="https://github.com/zhaohongxuan/dotfiles">Hank’s dotfiles</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://www.chezmoi.io/#considering-using-chezmoi">chezmoi - chezmoi</a></li>
<li>[[使用chezmoi管理dotfiles]]</li>
</ol>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>dotfiles</tag>
        <tag>chezmoi</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring @Transactional是如何工作的？</title>
    <url>/2022/08/06/spring-transaction-source-code/</url>
    <content><![CDATA[<h2 id="Spring事务使用"><a href="#Spring事务使用" class="headerlink" title="Spring事务使用"></a>Spring事务使用</h2><p>Spring配置事务还是挺简单的，第一步创建事务管理器<code>TransactionManager</code>，然后在配置中增加一个<code>@EnableTransactionManagement</code>就可以启用Spring事务了，所以关键类就是<code>@EnableTransactionManagement</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>@EnableTransactionManagement</code> 上实际上是import了<code>TransactionManagementConfigurationSelector</code>类，在这个Selector中实际import了<br>两个配置类：</p>
<ol>
<li>AutoProxyRegistrar</li>
<li>ProxyTransactionManagementConfiguration</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;  </span><br><span class="line">   <span class="keyword">switch</span> (adviceMode) &#123;  </span><br><span class="line">      <span class="keyword">case</span> PROXY:  </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(),  </span><br><span class="line">               ProxyTransactionManagementConfiguration.class.getName()&#125;;  </span><br><span class="line">      <span class="keyword">case</span> ASPECTJ:  </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;determineTransactionAspectClass()&#125;;  </span><br><span class="line">      <span class="keyword">default</span>:  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面我们来根据这个入口来分析一下Spring是如何处理事务的：</p>
<span id="more"></span>
<h3 id="AutoProxyRegistrar-导入"><a href="#AutoProxyRegistrar-导入" class="headerlink" title="AutoProxyRegistrar 导入"></a>AutoProxyRegistrar 导入</h3><p>AutoProxyRegistrar主要的作用是向Spring容器中注册了一个<strong>InfrastructureAdvisorAutoProxyCreator</strong>的Bean。<br>这一步位于spring aop包下面的 <code>AopConfigUtils#registerAutoProxyCreatorIfNecessary</code>方法中</p>
<p><code>InfrastructureAdvisorAutoProxyCreator</code>继承了<strong>AbstractAdvisorAutoProxyCreator</strong>，所以这个类的主要作用就是<code>开启自动代理</code>的作用，也就是一个<code>BeanPostProcessor</code>，会在初始化后步骤中去寻找Advisor类型的Bean，并判断当前某个Bean是否有匹配的Advisor，是否需要利用动态代理产生一个代理对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220404210931.png"></p>
<p>这里<strong>InfrastructureAdvisorAutoProxyCreator</strong>会扫描到事务处理的<code>BeanFactoryTransactionAttributeSourceAdvisor</code></p>
<h3 id="SpringAOP实现原理"><a href="#SpringAOP实现原理" class="headerlink" title="SpringAOP实现原理"></a>SpringAOP实现原理</h3><p>代理对象的生成类是：<code>AbstractAutoProxyCreator</code> 实现了BeanPostProcessor接口，会在Bean初始化完成之后通过postProcessAfterInitialization生成代理对象。<br>来看<code>postProcessAfterInitialization</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);  </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;  </span><br><span class="line">         <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> bean;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要代码就是<code>wrapIfNecessary</code>, 主要作用是生成Proxy Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;  </span><br><span class="line"> ...  </span><br><span class="line">   <span class="comment">// Create proxy if we have advice.  </span></span><br><span class="line"> Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);  </span><br><span class="line">   <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;  </span><br><span class="line">      <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);  </span><br><span class="line">      <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(  </span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));  </span><br><span class="line">      <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());  </span><br><span class="line">      <span class="keyword">return</span> proxy;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);  </span><br><span class="line">   <span class="keyword">return</span> bean;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>getAdvicesAndAdvisorsForBean</code> 为当前的Bean寻找合适的Advices，这个方法是Abstract方法，因此需要子类去实现。</p>
<p>主要实现代码在<code>AbstractAdvisorAutoProxyCreator</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(  </span><br><span class="line">      Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;  </span><br><span class="line">  </span><br><span class="line">   List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);  </span><br><span class="line">   <span class="keyword">if</span> (advisors.isEmpty()) &#123;  </span><br><span class="line">      <span class="keyword">return</span> DO_NOT_PROXY;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> advisors.toArray();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;  </span><br><span class="line">   List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();  </span><br><span class="line">   List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);  </span><br><span class="line">   extendAdvisors(eligibleAdvisors);  </span><br><span class="line">   <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;  </span><br><span class="line">      eligibleAdvisors = sortAdvisors(eligibleAdvisors);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> eligibleAdvisors;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>findEligibleAdvisors 会通过一个工具类在BeanFactory中查合适的Advisor，findAdvisorsThatCanApply会过滤可以被Apply的Advisor,  主要是看目标类和Advisor之间的关系来判断，这里主要由AOP的代码来实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220404192144.png"></p>
<h3 id="ProxyTransactionManagementConfiguration导入"><a href="#ProxyTransactionManagementConfiguration导入" class="headerlink" title="ProxyTransactionManagementConfiguration导入"></a>ProxyTransactionManagementConfiguration导入</h3><p><strong>ProxyTransactionManagementConfiguration</strong> 是一个配置类，它又定义了另外三个bean：</p>
<ol>
<li>BeanFactoryTransactionAttributeSourceAdvisor：一个Advisor</li>
<li>AnnotationTransactionAttributeSource：相当于<code>BeanFactoryTransactionAttributeSourceAdvisor</code>中的<code>Pointcut</code></li>
<li>TransactionInterceptor：相当于<code>BeanFactoryTransactionAttributeSourceAdvisor</code>中的 Advice</li>
</ol>
<p><code>AnnotationTransactionAttributeSource</code> 就是用来判断某个类上是否存在@Transactional注解， 或者判断某个方法上是否存在<code>@Transactional</code>注解的。<code>TransactionInterceptor</code>就是代理逻辑，当某个类中存在<code>@Transactional</code>注解时，到时就产生一个 代理对象作为Bean，代理对象在执行某个方法时，最终就会进入到<code>TransactionInterceptor</code>的 <code>invoke()</code>方法。</p>
<h2 id="Spring事务拦截"><a href="#Spring事务拦截" class="headerlink" title="Spring事务拦截"></a>Spring事务拦截</h2><p>PlatformTransactionManager<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220404183802.png"></p>
<h2 id="Transactional处理"><a href="#Transactional处理" class="headerlink" title="@Transactional处理"></a>@Transactional处理</h2><h3 id="Transactional-解析"><a href="#Transactional-解析" class="headerlink" title="Transactional 解析"></a>Transactional 解析</h3><p>@Transactional的处理主要是交给<code>TransactionAttributeSourceAdvisor</code>完成的，TransactionAttributeSourceAdvisor实现了<code>Advisor</code>接口，因此在Spring创建Bean的时候查找Advisor的时候，只要classpath中有加载到tx相关的jar包，并且Enable相关Transactional的配置了就会执行执行这个Advice增强功能。</p>
<h2 id="TransactionAttributeSourceAdvisor中包含了一个TransactionInterceptor-也是一个Advice，因此最终-Transactional就会最终实现事务的增强功能。"><a href="#TransactionAttributeSourceAdvisor中包含了一个TransactionInterceptor-也是一个Advice，因此最终-Transactional就会最终实现事务的增强功能。" class="headerlink" title="TransactionAttributeSourceAdvisor中包含了一个TransactionInterceptor,也是一个Advice，因此最终 @Transactional就会最终实现事务的增强功能。"></a>TransactionAttributeSourceAdvisor中包含了一个<code>TransactionInterceptor</code>,也是一个Advice，因此最终 <code>@Transactional</code>就会最终实现事务的增强功能。</h2><h2 id="事务执行原理"><a href="#事务执行原理" class="headerlink" title="事务执行原理"></a>事务执行原理</h2><p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220404183527.png"></p>
<p>一个Bean在执行Bean的创建生命周期时，会经过 <code>InfrastructureAdvisorAutoProxyCreator</code> 的初始化后的方法，会判断当前当前Bean对象是否和 <code>BeanFactoryTransactionAttributeSourceAdvisor</code> 匹配。</p>
<p>匹配逻辑为判断该Bean的类上是否存在 <code>@Transactional</code> 注解，或者类中的某个方法上是否存在 <code>@Transactional</code>注解，如果存在则表示该Bean需要进行动态代理产生一个代理对象作为Bean对象。</p>
<p>该代理对象在执行某个方法时，会再次判断当前执行的方法是否和<code>BeanFactoryTransactionAttributeSourceAdvisor</code>匹配，如果匹配则执行该Advisor中的 TransactionInterceptor的invoke()方法，执行基本流程为：</p>
<ol>
<li>利用所配置的<code>PlatformTransactionManager</code>事务管理器新建一个数据库连接</li>
<li>修改数据库连接的<code>autocommit</code>为false</li>
<li>执行<code>MethodInvocation.proceed()</code>方法，简单理解就是执行业务方法，其中就会执行sql</li>
<li>如果没有抛异常，则提交</li>
<li>如果抛了异常，则回滚</li>
</ol>
<p>TransactionInterceptor构造函数传入了一个TransactionManager 来管理事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TransactionInterceptor</span><span class="params">(TransactionManager ptm, TransactionAttributeSource tas)</span> &#123;  </span><br><span class="line">   setTransactionManager(ptm);  </span><br><span class="line">   setTransactionAttributeSource(tas);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用Advice的 invoke方法之后最终调用的是父类TransactionAspectSupport的invokeWithinTransaction来进行实际处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">   <span class="comment">// Work out the target class: may be &#123;@code null&#125;.  </span></span><br><span class="line"> <span class="comment">// The TransactionAttributeSource should be passed the target class // as well as the method, which may be from an interface. Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);  </span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...  </span></span><br><span class="line"> <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> <span class="title class_">CoroutinesInvocationCallback</span>() &#123;  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line"> <span class="meta">@Nullable</span> <span class="keyword">public</span> Object <span class="title function_">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">         <span class="keyword">return</span> invocation.proceed();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">getTarget</span><span class="params">()</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> invocation.getThis();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> Object[] getArguments() &#123;  </span><br><span class="line">         <span class="keyword">return</span> invocation.getArguments();  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/54067384">https://zhuanlan.zhihu.com/p/54067384</a></li>
<li><a href="https://juejin.cn/post/7018541168635936775">https://juejin.cn/post/7018541168635936775</a></li>
</ol>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>和焦虑做朋友</title>
    <url>/2022/08/08/how-to-deal-with-anxious/</url>
    <content><![CDATA[<h2 id="焦虑的产生"><a href="#焦虑的产生" class="headerlink" title="焦虑的产生"></a>焦虑的产生</h2><p>焦虑产生来自于恐惧，恐惧是对当下刺激的应激反应，焦虑是对未来刺激的应激反应。当我们在碰到一些严重刺激我们感官的事情时，杏仁核会接收到恐怖和惊惧，那么海马体会把这些感受记录下来。紧接着交叉神经也会启动，血压飙升、心跳加速都可以让你牢牢记住这个经历，如果它是足以对人身造成危险的情况，那么你下次很大概率会自动躲避。 换句话说也就是说，焦虑是保护自己的。</p>
<p>现代社会中，我们不需要再面对大量的恐惧了，但是筑巢本能依然存在，海马体依然保存了相关的能力，今年年初上海的疫情，让我们对基本的衣食住行感到焦虑，因为，平时唾手可得的食物，在疫情期间获取是如此的困难，这些恐惧让我们的海马体记录下来，很长时间内，我们会对未来产生焦虑，这些焦虑是良性的，保证我们生存的本能，在漫长的进化过程中，没有焦虑的人很可能因为没有储存过冬的食物而灭绝，我们能延续到现在，很大程度上是因为祖先适度的焦虑。</p>
<h2 id="焦虑不可能完全消除"><a href="#焦虑不可能完全消除" class="headerlink" title="焦虑不可能完全消除"></a>焦虑不可能完全消除</h2><p>焦虑的本质是恐惧的提前，是对未来的不确定性的担忧，这就意味着它是不可能被消除的。它不是现代人特有的， 物质极大丰富的年代反而更加剧了这种焦虑，我们看似拥有很多东西，世纪上都是空中楼阁，我们过于依赖外界，这让一切变得不确定，不确定产生焦虑。</p>
<p>面对现实，承认焦虑的存在，我们才有可能和焦虑做朋友。坦诚是一个人最好的品质。特别是对自己坦诚，大部分时候，我们喜欢自欺欺人，坦诚可以让我们面对问题本身，一旦承认了问题的存在，我们才有解决问题的可能，我们才能变得更好，这也是实事求是的来源。</p>
<p>一个焦虑的消失会伴随着另一个焦虑的诞生，就像叔本华说的，人是在无聊和痛苦之间摇摆的动物。</p>
<span id="more"></span>

<h2 id="如何缓解焦虑"><a href="#如何缓解焦虑" class="headerlink" title="如何缓解焦虑"></a>如何缓解焦虑</h2><p>必须要找到焦虑产生的根源。很多时候，焦虑来自于我们的拖延，这个时候，我们需要做的就是面对需要解决的问题，然后尝试break down，大的难题往往不好解决，所以我们需要将大的问题拆解成小问题，制造一个足够小的切入点，三分钟原则，一旦我们开始了三分钟，就很容易坚持下去。</p>
<p>也有的时候，焦虑来自无法改变的事物，焦虑未来发生的事情，比如第一次演讲，第一次出远门等，就算我们准备再充分，都会不可避免的焦虑，这个时候可以做一些其他事情转移注意力，不要让焦虑拖垮我们，一旦我们开始了，焦虑自然就消散了，很多人应该都会有这样的体会，在很多人面前发言的时候，上台前是最害怕的时候，真到了讲台上，反而没有那么紧张了。</p>
<h2 id="寻找心流"><a href="#寻找心流" class="headerlink" title="寻找心流"></a>寻找心流</h2><p>心流是让焦虑暂时离开我们的最佳方法，也就是达到忘我的状态，我们的内心像一个容器一样，一旦装下了一些事物，就不能再容纳下其他的事物，所以，最佳的方法是让我们的心被那些好的事物占据，心流就是这样一种状态。我们沉醉于我们正在做的事情，并且忘记了时间，在这个状态里，我们不愿意被打断，并且会有非常充实且愉悦的感受。</p>
<p>想达到心流状态，有两个重要指标：</p>
<ul>
<li>挑战性目标</li>
<li>即时反馈</li>
</ul>
<p>这两个目标缺一不可，打游戏可能是最容易进入心流的事情了，因为游戏的难度往往会匹配等级，让我们能够获得即时正向反馈，大扫除也是，我们看到凌乱的房间变得越来越整洁，会产生很大的正反馈。</p>
<p>专注于做每一件事情，就算事情再小，只要符合这两个条件，就会很容易达到心流的状态，比如：</p>
<ul>
<li>自己（或者和伴侣）去菜市场或者超市，去挑选水果蔬菜和肉类，看到新鲜的蔬菜和水果还带着水珠，心情会变得很好，自己采买的蔬菜也会更加有成就感。就算你自己一个人住，也不要经常点外卖，买一个雪平锅&#x2F;电饭煲 可以做出非常多的美味佳肴。</li>
<li>打扫卫生，把一个乱糟糟的空间变得井井有条也是一件非常有成就感的事情。</li>
<li>看一部电影，短视频留下的当下，能坚持看完一部电影绝对是一种能力，如果看的投入，会极大的放松，如果对新电影没有兴趣，可以看看老电影，重温老电影也是一件非常浪漫的事情，不管是一个人看，还是和爱的人一起。</li>
<li>徒步旅行，就在自己的城市里，寻常巷陌内转转也是非常不错的选择，感受城市的烟火气，我经常一个人绕着巨大的环城绿道徒步，呼吸着湿润的风，负氧离子也会让自己的心情变好。</li>
<li>跑一个步吧，没有什么事情是一场跑步解决不了的，如果10km不够那就一个半马。运动可以极大的缓解抑郁情绪，大量的流汗可以促进血液循环，让我们更加神情气爽。</li>
</ul>
<h2 id="和焦虑做朋友"><a href="#和焦虑做朋友" class="headerlink" title="和焦虑做朋友"></a>和焦虑做朋友</h2><p>拒绝完美主义，完美加上了主义就说明了它不再完美，完美主义在我看来是一个贬义词而风褒义词，完美主义者往往拒绝开始，一旦开始，遇到一些错误又马上否定全部，不能接受自己犯错，攻击自己。</p>
<p>这个世界是无限的，知识是无限的，学习永远没有尽头，因此，享受过程才能让我们走的更远，我们能把握的也仅仅只有过程而已。</p>
<p>既然焦虑是不可能消除的，是和我们如影随形的，我们就必须和平接受它，并且和它化敌为友，让它驱动我们不断进步，不断成长。</p>
<p>大部分时候我们会被束缚，我们被欲望裹挟，欲望满足了便开心，不满足便失落，但是即便是在焦虑和失望中也不要丧失对生活的信心，就像苏东坡在承天寺和张怀民一起月光庭下散步的一样坦然和宁静。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li>《心流：最优体验心理学》-米哈里·契克森米哈赖</li>
<li>《伯恩斯焦虑自助疗法》-戴维·伯恩斯</li>
</ul>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>焦虑</tag>
        <tag>心流</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事件驱动的原理</title>
    <url>/2022/09/03/spring-event-driven/</url>
    <content><![CDATA[<h2 id="Spring事件驱动"><a href="#Spring事件驱动" class="headerlink" title="Spring事件驱动"></a>Spring事件驱动</h2><p>Spring 事件驱动的代码都位于spring-context 模块的event包中，主要包括：事件(Event)发布者() Publisher) ,订阅者(Listener)组成。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>ApplicationEvent<br>java的所有事件对象一般都是java.util.EventObject的子类，Spring的整个继承体系如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220218175226.png" alt="ApplicationEvent"></p>
<span id="more"></span>

<h3 id="Publisher-发布者"><a href="#Publisher-发布者" class="headerlink" title="Publisher 发布者"></a>Publisher 发布者</h3><h4 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h4><p>AbstractApplicationContext实现了ApplicationEventPublisher接口 publishEvent</p>
<h4 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a>ApplicationEventMulticaster</h4><p>ApplicationEventPublisher实际上正是将请求委托给ApplicationEventMulticaster来实现的。其继承体系:<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220218181201.png"></p>
<h3 id="Listeners-监听者"><a href="#Listeners-监听者" class="headerlink" title="Listeners 监听者"></a>Listeners 监听者</h3><p>所有的监听器是jdk EventListener的子类，这是一个mark接口。继承体系:</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220218175429.png"></p>
<p>可以看出SmartApplicationListener和GenericApplicationListener是高度相似的，都提供了事件类型检测和顺序机制，而后者是从Spring4.2加入的，Spring官方文档推荐使用后者代替前者。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>前面说过AppjlicationEventPublisher是通过委托给ApplicationEventMulticaster实现的，所以refresh方法中完成的是对ApplicationEventMulticaster的初始化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br></pre></td></tr></table></figure>

<p>initApplicationEventMulticaster则首先在BeanFactory中寻找ApplicationEventMulticaster的bean，如果找到，那么调用getBean方法将其初始化，如果找不到那么使用SimpleApplicationEventMulticaster。</p>
<h3 id="ApplicationEventPublisher-接口"><a href="#ApplicationEventPublisher-接口" class="headerlink" title="ApplicationEventPublisher 接口"></a>ApplicationEventPublisher 接口</h3><p>AbstractApplicationContext.publishEvent核心代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleApplicationEventMulticaster.multicastEvent:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    invokeListener(listener, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="监听器获取"><a href="#监听器获取" class="headerlink" title="监听器获取"></a>监听器获取</h4><p>获取当然还是通过beanFactory的getBean来完成的，值得注意的是Spring在此处使用了缓存(ConcurrentHashMap)来加速查找的过程。</p>
<h4 id="同步-x2F-异步"><a href="#同步-x2F-异步" class="headerlink" title="同步&#x2F;异步"></a>同步&#x2F;异步</h4><p>可以看出，如果executor不为空，那么监听器的执行实际上是异步的。那么如何配置同步&#x2F;异步呢?</p>
<h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">&quot;multicasterExecutor&quot;</span> <span class="attr">pool-size</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.event.SimpleApplicationEventMulticaster&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;taskExecutor&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;multicasterExecutor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>task schema是Spring从3.0开始加入的，使我们可以不再依赖于Quartz实现定时任务，源码在org.springframework.core.task包下，使用需要引入schema：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:task=&quot;http://www.springframework.org/schema/task&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启注解支持:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启@AspectJ AOP代理 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 任务调度器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">&quot;scheduler&quot;</span> <span class="attr">pool-size</span>=<span class="string">&quot;10&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 任务执行器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">&quot;executor&quot;</span> <span class="attr">pool-size</span>=<span class="string">&quot;10&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--开启注解调度支持 @Async @Scheduled--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">&quot;executor&quot;</span> <span class="attr">scheduler</span>=<span class="string">&quot;scheduler&quot;</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在代码中使用示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailRegisterListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;RegisterEvent&gt; &#123;  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(<span class="keyword">final</span> RegisterEvent event)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;注册成功，发送确认邮件给：&quot;</span> + ((User)event.getSource()).getUsername());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://www.iteye.com/blog/jinnianshilongnian-1902886">https://www.iteye.com/blog/jinnianshilongnian-1902886</a></li>
<li><a href="https://github.com/seaswalker/spring-analysis/blob/master/note/Spring.md#applicationeventmulticaster">https://github.com/seaswalker/spring-analysis/blob/master/note/Spring.md#applicationeventmulticaster</a></li>
</ol>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring静态Bean的原理</title>
    <url>/2022/09/21/spring-static-bean/</url>
    <content><![CDATA[<p>最近遇到一个spring static bean的坑，我们知道使用Java Config的方式定义一个Bean 非常简单，只需在Configuration的method上加上 @Bean 注解即可。</p>
<p>但是这里有个例外，假如你的Bean不是一个普通的Bean，而是一个<code>BeanFactoryPostProcessor</code>就需要使用static方法来定义这个Bean。 否则你会得到一个警告：</p>
<p><code> @Bean method TestConfig.customEditorConfigurer is non-static and returns an object assignable to Spring&#39;s BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method&#39;s declaring @Configuration class. Add the &#39;static&#39; modifier to this method to avoid these container lifecycle issues; see @Bean javadoc for complete details.</code></p>
<p>也就是说，如果你的bean是一个BFPP，必须定义为static，否则，使用@Autowired, @Resource and @PostConstruct 会有问题。</p>
<p>来看 @Bean注解源码里的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Special consideration must be taken for @Bean methods that return Spring BeanFactoryPostProcessor (BFPP) types. </span><br><span class="line">Because BFPP objects must be instantiated very early in the container lifecycle,</span><br><span class="line">they can interfere with processing of annotations such as @Autowired, @Value, and @PostConstruct within @Configuration classes. </span><br><span class="line"></span><br><span class="line">To avoid these lifecycle issues, mark BFPP-returning @Bean methods as static. For example:</span><br><span class="line">      @Bean</span><br><span class="line">      public static PropertySourcesPlaceholderConfigurer pspc() &#123;</span><br><span class="line">          // instantiate, configure and return pspc ...</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">By marking this method as static, it can be invoked without causing instantiation of its declaring @Configuration class, thus avoiding the above-mentioned lifecycle conflicts. </span><br><span class="line">Note however that static @Bean methods will not be enhanced for scoping and AOP semantics as mentioned above. </span><br><span class="line">This works out in BFPP cases, as they are not typically referenced by other @Bean methods. </span><br><span class="line">As a reminder, a WARN-level log message will be issued for any non-static @Bean methods having a return type assignable to BeanFactoryPostProcessor.</span><br></pre></td></tr></table></figure>


<p>因为BFPP都需要在在Spring容器的早期进行实例化，因为他们会干扰正常的Bean实例化中处理 @Autowired @Value @PostConstruct ，这篇Blog尝试寻找一下Static Bean背后的原理。</p>
<span id="more"></span>

<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>我尝试简化一下模型来重现一下问题：</p>
<p>SpringBoot项目里有一个TestConfig类，在里面定义了一个特殊的Bean：customEditorConfigurer<br>因为CustomEditorConfigurer是一个BFPP，它的作用是注册自定义的类型转换器，Spring可以把String 转换为相对应的类型，这里我注册一个<code>UserEditor</code>，它的作用是将String转换为User对象，这样在使用@Value的时候就能实现自动类型转换，将配置文件里的字符串自动转换为一个User对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConfig</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test.user:hank&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> User user;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> CustomEditorConfigurer <span class="title function_">customEditorConfigurer</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">CustomEditorConfigurer</span> <span class="variable">customEditorConfigurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomEditorConfigurer</span>();  </span><br><span class="line">        Map&lt;Class&lt;?&gt;, Class&lt;? <span class="keyword">extends</span> <span class="title class_">PropertyEditor</span>&gt;&gt; customEditors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        customEditors.put(User.class, UserEditor.class);  </span><br><span class="line">        customEditorConfigurer.setCustomEditors(customEditors);  </span><br><span class="line">        <span class="keyword">return</span> customEditorConfigurer;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>  </span><br><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserEditor</span> <span class="keyword">extends</span> <span class="title class_">PropertyEditorSupport</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;  </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(text);  </span><br><span class="line">        <span class="built_in">super</span>.setValue(user);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在一个Bean里依赖TestConfig 获取 user将会是null，假如我们把customEditorConfigurer()方法改为static将会能正确得拿到user信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==== get test user:User(name=hank)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootDemoApplication</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    TestConfig testConfig;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        SpringApplication.run(BootDemoApplication.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;==== get test user:&quot;</span> + testConfig.getUser();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="为什么BFPP需要定义成Static-Bean？"><a href="#为什么BFPP需要定义成Static-Bean？" class="headerlink" title="为什么BFPP需要定义成Static Bean？"></a>为什么BFPP需要定义成Static Bean？</h2><h3 id="Static-Bean-Definition注册"><a href="#Static-Bean-Definition注册" class="headerlink" title="Static @Bean Definition注册"></a>Static @Bean Definition注册</h3><p>先来看下static bean和normal bean在BeanDefinition注册的有何不同，这个时候我们就需要看Spring源码了，@Bean BeanDefinition的注册是在<br>ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForConfigurationClass</span><span class="params">(  </span></span><br><span class="line"><span class="params">      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">   <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;  </span><br><span class="line">      loadBeanDefinitionsForBeanMethod(beanMethod);  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>仔细看下loadBeanDefinitionsForBeanMethod</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForBeanMethod</span><span class="params">(BeanMethod beanMethod)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (metadata.isStatic()) &#123;  </span><br><span class="line">   <span class="comment">// static @Bean method  </span></span><br><span class="line">   <span class="keyword">if</span> (configClass.getMetadata() <span class="keyword">instanceof</span> StandardAnnotationMetadata) &#123;  </span><br><span class="line">      beanDef.setBeanClass(((StandardAnnotationMetadata) configClass.getMetadata()).getIntrospectedClass());  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">else</span> &#123;  </span><br><span class="line">      beanDef.setBeanClassName(configClass.getMetadata().getClassName());  </span><br><span class="line">   &#125;  </span><br><span class="line">   beanDef.setUniqueFactoryMethodName(methodName);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="comment">// instance @Bean method  </span></span><br><span class="line">   beanDef.setFactoryBeanName(configClass.getBeanName());  </span><br><span class="line">   beanDef.setUniqueFactoryMethodName(methodName);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区别在于如果是static bean 会设置BeanClass而普通的Bean设置FactoryBeanName，这个在后面createBean的时候会用到。</p>
<h3 id="BeanPostProcessor-Bean-的实例化"><a href="#BeanPostProcessor-Bean-的实例化" class="headerlink" title="BeanPostProcessor Bean 的实例化"></a>BeanPostProcessor Bean 的实例化</h3><p>PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors发生在所有Bean实例化之前</p>
<p>在BeanFactory中搜索所有BeanFactoryPostProcessor的beanName（就是上一步添加到bean dedefinition map）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] postProcessorNames =  </span><br><span class="line">      beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>然后给BFPP排序，按照实现 PriorityOrdered &gt; Ordered &gt; 一般 BFPP，这个时候会实例化BFPP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)</span><br></pre></td></tr></table></figure>

<p>实例化步骤和普通的Bean一样，先使用 BeanFactory.getBean(beanName) 获取Bean，这一步会触发createBean的操作</p>
<ol>
<li>doCreateBean中直接调用createBeanInstance创建实例</li>
<li>createBeanInstance中instantiateUsingFactoryMethod 根据Factory Method来创建实例,委托给ConstructorResolver来进行创建，下面是关键代码：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="type">String</span> <span class="variable">factoryBeanName</span> <span class="operator">=</span> mbd.getFactoryBeanName();  </span><br><span class="line"><span class="keyword">if</span> (factoryBeanName != <span class="literal">null</span>) &#123;  </span><br><span class="line">   <span class="keyword">if</span> (factoryBeanName.equals(beanName)) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbd.getResourceDescription(), beanName,  </span><br><span class="line">            <span class="string">&quot;factory-bean reference points back to the same bean definition&quot;</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   factoryBean = <span class="built_in">this</span>.beanFactory.getBean(factoryBeanName);  </span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.beanFactory.containsSingleton(beanName)) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ImplicitlyAppearedSingletonException</span>();  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="built_in">this</span>.beanFactory.registerDependentBean(factoryBeanName, beanName);  </span><br><span class="line">   factoryClass = factoryBean.getClass();  </span><br><span class="line">   isStatic = <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">   <span class="comment">// It&#x27;s a static factory method on the bean class.  </span></span><br><span class="line">   <span class="keyword">if</span> (!mbd.hasBeanClass()) &#123;  st</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbd.getResourceDescription(), beanName,  </span><br><span class="line">            <span class="string">&quot;bean definition declares neither a bean class nor a factory-bean reference&quot;</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   factoryBean = <span class="literal">null</span>;  </span><br><span class="line">   factoryClass = mbd.getBeanClass();  </span><br><span class="line">   isStatic = <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果factoryBeanName 不为空，说明是普通的Bean实例化, 需要先创建<code>FactoryBean</code> 可以理解成宿主Bean，如果是static factory method创建的Bean则不需要。</p>
<p>创建Bean之前需要先创建Factory Bean实例，在这里FactoryBean就是<code>testConfig</code> 这个实例，在创建testConfig实例的时候发现需要有依赖的@Value dependency，这个时候会去使用TypeConverter来将String转换为User，这个时候就有问题了，我们的UserEditor还没注册完成呢，testConfig是在customEditorConfigurer实例化的时候被创建的，所以这个</p>
<ol>
<li>创建customEditorConfigurer</li>
<li>发现customEditorConfigurer不是static所以先要创建FactoryBean也就是testConfig</li>
<li>testConfig中依赖@Value，populateBean的时候需要调用UserEditor来做转换</li>
<li>UserEditor没有注册，因为customEditorConfigurer还没创建完成</li>
<li>所以User就没有初始化，user就是null</li>
</ol>
<p>如果是Static Bean的话就没有这个问题了，因为static bean 不需要依赖factoryBean来创建实例，而是直接调用的构造器来进行初始化的。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts">Core Technologies</a></li>
</ul>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>以父之名</title>
    <url>/2022/11/08/as-a-father/</url>
    <content><![CDATA[<p>不知不觉，成为父亲已经一年有余，这一年，从一个懵懂的小男生变成了一个奶爸，这一年真的经历了太多。肺炎，呕吐，腹泻，还有疫情，买奶粉等等，辛苦是真的辛苦，不过这个小家，多了一些欢声笑语，多了一些不一样的颜色，感觉自己一下子变得柔软起来。</p>
<p>当然，带娃是一件非常累的事情，喂奶，洗澡换尿布是基本操作，从刚开始的纸尿裤穿反，到后面的轻车熟路，都是时间的馈赠。有的时候还真是很怀念二人世界，多的是自由时间。</p>
<p>宝宝的到来，是一个神奇的礼物，我们都是时间的旅行者，像罗翔老师说的那样，开始意识到自己是有限的，而宝宝的到来，让我们意识到，虽然对一个人来说，人是有限的，但是繁衍让人变得无限。当然这就有些扯远了，其实就是生物的筑巢本能吧。</p>
<p>人这种生物，很奇怪的一点就是要寻找意义，很多时候，找不到意义，也就找不到继续生活下去的理由，世俗生活是大部分人的生活，我承认自己是一个俗人。</p>
<p>有的时候，我想人是孤独的，就像一场聚会，就算再热闹，也最终要散场。但是我们需要的不是结果的落寞，也需要过程的热烈。烟花的美在于它盛开的过程的绚烂，而不是一地烟灰。</p>
<p>正如和菜头说的：</p>
<blockquote>
<p>正午时分看人间烟火，夜半时分看月亮如水，各有各的风景。该举杯时举杯，该独行时独行，那么<br>就总是感觉轻安自在，没有那么多一定，也没有那么多必须，更没有那么多不得不，这就是自由。</p>
</blockquote>
<p>对于我来说，家庭角色一下子从原来一个变成了三个，丈夫，儿子，父亲。如何在这三者角色之间切换是一个技术活，一旦处理不好，就是一地鸡毛。</p>
<p>如果不是自己当父亲，自己永远无法体会一个父亲的感受，别人说的永远只是一些文字，只有自己体会了才懂，这可能这就是时间的馈赠吧。</p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>育儿</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2022</title>
    <url>/2022/12/31/bye-2022/</url>
    <content><![CDATA[<p>2022年可以说是非常魔幻的一年了，这一年我刚好三十而立，女儿一岁了，这一年经历了很多，经历了四五月份的封城，经历了十二月份的疫情放开，经历了失望，无意义，还有一些成长，感觉认识自己更多一点了。</p>
<span id="more"></span>

<p>可能人的一辈子就是一个逐渐认识到自己是一个普通人，然后接受自己的一个过程，一晃眼，一年就过去了，想要回忆这一年都发生了什么还是有些困难，大部分的事情都在时间的中褪色了，不过还是有一些事情，值得开心的。</p>
<h2 id="一些值得记录的事情"><a href="#一些值得记录的事情" class="headerlink" title="一些值得记录的事情"></a>一些值得记录的事情</h2><p>第一件事情，自学了Typescript写了一个<a href="https://github.com/zhaohongxuan/obsidian-weread-plugin">Obsidian微信读书插件</a>。这件事情纯属偶然，因为平时读书都是微信读书，然后记笔记的软件是Obsidian，自己导出笔记然后再copy到Obsidian着实有些麻烦，心想Obsidian的插件市场又那么大，以为肯定会有人已经写了这个插件，结果并没有，于是有了自己写插件的想法，去github找相关的微信读书API，然后找obsidian开发的example等，五一假期刚好是上海封城时期，自己就在家哼哧哼哧写出来了，那时候真的是精力旺盛，那几天基本上都是早上4点起床，开始写代码，因为我感觉代码就在我脑子里要倾泻下来，现在回想起来，感觉整个人是陷入到了一种人码合一的状态了，我把自己做的Obsidian插件做成了视频<a href="https://b23.tv/0QrrnMs">【学了3天typescript写了一个微信读书的Obsidian插件-哔哩哔哩】</a>放到了B站，结果还有不少人使用，自己做的工具能帮到别人，真的是一种莫大的肯定，现在，插件的Github star数已经到了431，远远超出了我的预期。<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20230103173121.png" alt="github-commit"></p>
<p>第二件事情，和朋友一起翻译一本关于MATLAB和Python的英文技术书籍，一个博士朋友问我有没有兴趣一起翻译一本技术书籍，我接受了这个挑战，刚开始的时候，翻译的真的是一言难尽，好在朋友的慢慢引导和建议，后面章节翻译的越来越好了，同事对自己的英文水平有很大提升，雅思的单词词汇量基本上没问题了，技术方面，自己也学会了MATLAB的一些基础知识，感觉收货还是很大的。</p>
<p>第三件事情，学会了双拼输入法。发现了自己的学习能力还是有的，主要就是刚开始的一个星期到两个星期，感觉打字怎么打怎么别扭，随着时间增长，我发现双拼变成了肌肉记忆。可能会有人说打字那么快干啥，我自己用全拼也能好好的，其实，学习双拼主要是我感觉它比较简单，是的就是简单，比五笔简单，然后还能满足打字速度的需求，期间还从搜狗方案切换到了小鹤方案。不过现在最大的问题是，在需要输入拼音的地方，忍不住要打双拼，比如在iphone上搜索app的时候🤣，这可能就是肌肉记忆了吧。</p>
<p>第四件事情，开上了自己的第一辆车：比亚迪宋plus DM-i，虽然并不是什么豪车，但是自己感觉挺满意，就是等车的时间有些长，从6月等到了11月，不过为了上海的绿牌我忍了。有了车之后还是方便一些，去超市购物，周末去周边的地方玩一玩都很方便，充电也很方便，感觉很满意。</p>
<h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>女儿磕磕绊绊长到了一岁，第一次抬头，第一次翻身，第一次爬行，第一次坐，第一次站，第一次叫爸爸，我都在场。有了好几次大半夜往医院赶的经历，随着女儿一点点的长大，感受到了自己身上的作为父亲的责任也越来越大，也更能感受到身为父母的不易，家庭关系也慢慢磨合得和谐很多。</p>
<p>这一年由于疫情，跑步耽误的比较多，一年也就跑了六百多公里，整个四五月份上海封城了两个月，期间一次都没跑过，三月份疫情开始蔓延，不敢出去跑步，十二月份阳了，虽然一周就转阴了，也不敢出去跑步，因为看到了太多的阳康因为运动而丧命的。<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20230103163119.png" alt="2022跑步"></p>
<p>这几年跑步的次数明显下降了，通过我的Running Page也能看出来这个趋势，处于年年下降的状态，一方面是心态发生了变化，想跑的时候就多跑一点，兴致来的时候跑个半马，不想跑的时候也不强求自己，从图中能够看出来，基本上每周都会有跑步，除非特殊情况，至少两次跑步。一方面不至于让自己懈怠，另一方面也不至于让自己很累。</p>
<p>这一年，也定一个新的跑步目标吧，年度1000km，如果没有疫情的话，我感觉应该能够完成。</p>
<h2 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h2><p>这一年，基本上读的书不多，其中对我影响最大的应该是</p>
<ul>
<li>塔勒布的《非对称风险》</li>
<li>周濂的《打开：》</li>
<li>傅高义的《邓小平时代》</li>
<li>《西游记》</li>
<li>史景迁的《太平天国》</li>
<li>黑塞的《悉达多》</li>
</ul>
<p>看的出来，我比较喜欢哲学，以及文史，今年技术书籍读的比较少，因为基本上技术学习主要靠的是官方文档，优秀的Blog等等。<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/IMG_65.JPEG" alt="2022阅读"><br>随着年龄的增长，或许是自己的天性使然，感觉更原因向内探索，这也和悉达多一样，要拜自己为师，尝试理解自己，在物理世界和内心世界之间达到某种平衡，这个世界是物质的，但也是精神的，两者必须保持自洽，人才不至于分裂。</p>
<p>阅读是一种单向的沟通，不是最高效的，但是作者依然可以通过文字把他的所思所想告诉读者，能不能理解作者的想法，那就靠天分了。现在我非常认同悉达多的那句话：</p>
<blockquote>
<p>知识可以分享，智慧无法分享，它可以被发现，被体验。智慧令人安详，智慧创造奇迹，但人们无法言说和传授智慧。</p>
</blockquote>
<h2 id="一些展望"><a href="#一些展望" class="headerlink" title="一些展望"></a>一些展望</h2><p>新的一年，希望自己能多爱这个家一点，多爱父母，多爱爱人一点，多爱女儿一点，让她们都开心一点，这个家也就立起来了，我要做的就是守护，让一切都保持和谐的状态。</p>
<p>新的一年，我会坚持读书，去书中寻找自我和超我，也会继续跑步，或长或短，或快或慢，无所谓，要做的是跑步本身，跑步让我冷静，让我能够切换角色，沉浸到跑步本身，感受到心流。</p>
<p>新的一年，也希望自己能够不断去开始，去发现，去学习，去探索，去经历。开始比完美重要，行动比言语重要。不断充实自己的大脑，然后让头脑中的点点知识，转化为实实在在的智慧，通过自己的智慧去影响这个世界。</p>
<p>未来拥有很大的不确定性，我也没有什么远大的志向，新冠让我意识到人很渺小，希望自己能够过好当下，践行好每一个瞬间就已足够。</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>疫情</tag>
        <tag>Obsidian</tag>
        <tag>2022</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>自动分组chrome标签页</title>
    <url>/2023/05/05/autogroup-your-chrome/</url>
    <content><![CDATA[<p>Chrome的标签功能在管理多个标签页时非常好用，但是在标签量更大一些的时候，手动的管理这些标签页就不太方便了，这个时候可以考虑使用chrome扩展来完成这一自动化的操作，特别是对于工作的场景，基本上每天打开的网站都是特定的场景。</p>
<p>Auto-Group Tabs是一个Chrome浏览器插件，用于自动对用户打开的多个标签进行分组，以使它们更容易管理和组织。这个插件还支持配置的导入和导出，可以方便的在多个设备上同步。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过chrome商店：<a href="https://chrome.google.com/webstore/detail/auto-group-tabs/danncghahncanipdoajmakdbeaophenb">Auto-Group Tabs - Extensions</a> 打开此链接，点击安装即可，如果在商店搜索安装的时候，有多个类似的扩展，注意选择下面这个。</p>
<h2 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h2><span id="more"></span>

<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>对于我工作的电脑，我的标签：</p>
<p>gitlab：<br>主要是管理一些打开的gitlab repo，MR、pipeline等链接</p>
<p>wiki：<br>主要是管理confluence上面的文档之类的，包括自己写的文档， Release check list等链接</p>
<p>jira：<br>主要包含，自己的</p>
<p>dev：<br>主要是在开发环境相关的一些页面，包括，开发环境的，kibana、argocd、pipeline等链接，管理后台等。</p>
<p>live：<br>主要包含一些monitoring的相关页面，比如grafana、argocd、kibana等，还有一些业务使用的页面，比如管理后台等</p>
<p>search：<br>主要是管理自己google search的结果，从search标签里查询出来的结果，如果没有被自动Group到其他的标签就会自动在当前的search标签中。</p>
<p>我的插件配置如下：<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/Pasted%20image%2020230209184708.png" alt="我的插件配置"></p>
<h3 id="使用时添加"><a href="#使用时添加" class="headerlink" title="使用时添加"></a>使用时添加</h3><p>配置完成之后，如果以后我们在打开某些网站的时候也可以很方便的添加到我们的规则里，比如在逛京东的时候，可以把京东 <code>*.jd.co</code>添加到我们的shopping规则中，然后京东就会自动添加到我们的shopping标签中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/Pasted%20image%2020230209185535.png" alt="使用"></p>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>chrome扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>认识布鲁姆分类学</title>
    <url>/2023/02/05/bloom-taxonomy/</url>
    <content><![CDATA[<p>布卢姆分类学 (Bloom’s taxonomy) 是美国教育心理学家本杰明·布鲁姆于1956年在芝加哥大学所提出的分类法，此方法将认知层次分为六个，从低到高依次是：记忆（Remember）、理解（Understand）、应用（Apply）、分析（Analyze）、评估（Evaluate）、创造（Create）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/Pasted%20image%2020230203164425.png"></p>
<p>整个认知层次结构呈金字塔分布，记忆、理解、应用三个低阶思维水平的目标位于塔的底层，而分析、评估、创造三个高阶目标位于塔尖部分，因为它们都需要更高水平的思维技能。</p>
<h2 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h2><h3 id="记忆（Remember）"><a href="#记忆（Remember）" class="headerlink" title="记忆（Remember）"></a>记忆（Remember）</h3><p>记住特定知识，包括一些具体事实、基础概念、术语等，不需要理解所学内容的内在含义，也就是通常说的死记硬背。这类一般是死知识，比如河南省的省会，世界有哪几个大洲构成等等</p>
<h3 id="理解-（Understand）"><a href="#理解-（Understand）" class="headerlink" title="理解 （Understand）"></a>理解 （Understand）</h3><p>理解所学内容并可以清晰的描述它，而且可以使用自己的话准确复述材料的内容。</p>
<p>这里面包含了三种形势来表明自己对材料的理解：<br>转换：也就是使用自己的话，或者使用和原文不同的方式来阐述它。<br>解释：可以使用自己的理解对它进行说明或者概述，这里需要有一定的抽象能力。<br>推断：预测发展的趋势和后果。</p>
<p>著名的费曼学习法就是通过输出倒逼输入的例子，如果你完全理解了一个内容，那么你就完全可以用非常浅显的语言解释给完全不懂的人听。换句话说，我们应该减少晦涩专业词语的使用，就算使用也要解释清楚其含义，如果我们无法用通俗语言来描述，大概率是自己没有真正理解它。</p>
<h3 id="应用（Apply）"><a href="#应用（Apply）" class="headerlink" title="应用（Apply）"></a>应用（Apply）</h3><p>举一反三，通过前面的记忆和理解把先前学到的知识迁移到新的情境中去解决一定的实际问题。</p>
<p>对于大部分人来说，可能是卡在这一步，上课时，老师讲得也都听懂了，也听的津津有味，但是老师布置的作业，下课一看傻眼了，根本做不出来。这也是很正常的，<br>因为，对于大部分知识来说，它们并不是死的，而是互相关联的，考察的是综合能力，复杂的知识需要更多的相关的背景知识以及有逻辑思维的大脑。 而且这也要依赖前面的理解，如果理解不够透彻，那么一定做不好这一步。</p>
<span id="more"></span>

<h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><p>前面的记忆、理解、应用只是知识的表面部分，一般中小学对知识的考察程度一般都在这一层级。到了第二部分，我们就到了更加高级的阶段，一旦认知进入了这个层次，那也就是到了一个较为专业的层次了，需要掌握知识背后的原理以及原则。</p>
<h3 id="分析（Analysis）"><a href="#分析（Analysis）" class="headerlink" title="分析（Analysis）"></a>分析（Analysis）</h3><p>将事物拆解成若干部分，认清他们之间的关系，明确它们的每个部分之间是如何关联的。复杂的事物往往是由非常多的部件构成的，比如汽车，手机等，表面上看它们知识一个工具，但是实际上，它们的内部及其复杂，每一个小的组件背后可能都是无数专利，特别是半导体芯片，集成电路等技术。</p>
<p>这就是以微观的视角来分析问题，并且能够根据一定的事实进行推断，这属于高级的大脑皮层活动。</p>
<h3 id="评价（Evaluation）"><a href="#评价（Evaluation）" class="headerlink" title="评价（Evaluation）"></a>评价（Evaluation）</h3><p>这里的评价指的是使用标准、理论或过程来评价价值评估价值，这一层级属于较高层级的的目标了，这一层次我们需要通过一定的准则对事物的价值做出判断。知乎上经常遇到的问题就是，如何评价XXX？ </p>
<h3 id="创造-（Create）"><a href="#创造-（Create）" class="headerlink" title="创造 （Create）"></a>创造 （Create）</h3><p>将之前所有的信息进行深度加工，使用新的方式重新组合起来创造新的事物，比如写作，设计等等，创新也发生于这一层级。</p>
<p>这是认知层次的最高境界，在学习一个新的知识的时候，写下来确实是倒逼自己思考的一个非常好的途径，因为写作一个创造的过程，这个过程需要不断回忆我们所学的知识，这个时候，他们可能是一个个的碎片，我们在写作的时候才能一点点把他们之间的关系捋清楚，这里面包含了（理解、应用、分析、评价）等步骤。</p>
<p>布鲁姆分类法可以作为我们的学习框架，它有助于我们思考所学内容，以及确定我们对于知识的掌握程度。此外，它也可以帮助我们提出更有价值的问题。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://zh.wikipedia.org/zh-hans/%E5%B8%83%E9%B2%81%E5%A7%86%E5%88%86%E7%B1%BB%E5%AD%A6">https://zh.wikipedia.org/zh-hans/布鲁姆分类学</a></li>
<li><a href="https://cft.vanderbilt.edu/guides-sub-pages/blooms-taxonomy">https://cft.vanderbilt.edu/guides-sub-pages/blooms-taxonomy</a></li>
</ul>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>布鲁姆分类学</tag>
        <tag>Bloom-Taxonomy</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>也许你该试试双拼输入法</title>
    <url>/2023/06/30/how-i-learn-shuang-pin/</url>
    <content><![CDATA[<p>这周最大的收获是学习了双拼输入法，而且带动了一个同事也开始学习双拼输入法了，还跟我说怎么不早告诉他😂。学习的过程也踩了不少坑，感觉有必要写出来，让后人少走弯路。</p>
<h2 id="为何入坑？"><a href="#为何入坑？" class="headerlink" title="为何入坑？"></a>为何入坑？</h2><p>最初开始学习双拼是在twitter TL上看到一条双拼的推：<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220731150844.png"></p>
<p>它让我想起了大学时候学习半途而废的经经历，于是想既然这么有价值，我也许应该重新捡起来，毕竟以前vim对我来说也是一座高山，现在也被我征服了。</p>
<p>可能会有小朋友要问了，打字效率对于一个程序员来说真的那么重要吗？</p>
<p>不重要。它只是一个工具，不使用完全没有什么影响，它能帮你做的仅仅是提高一些效率，但是对于大多数人来说可能还不到拼效率的地步，大部分人来说全拼输入法够了，VSCode也够了。你可以举很多例子来反驳，但是都不如亲自试一试，这和学习vim一个道理，而且有反驳的时间，键位也都记住了。</p>
<p>这里，我也想用道德经里的一段话来说明：</p>
<blockquote>
<p>上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之。</p>
</blockquote>
<p>假如你是一个想尝试新鲜事物的人，恰巧你也是一个“懒人”，那么我觉得你可以尝试一下双拼输入法，虽然它不能帮你摆脱重码率的困扰，但是至少能比全拼少敲几次键盘，记忆曲线也没五笔那么陡峭，基本上可以做到：1小时记忆键位，1周熟练双拼节奏，1月恢复到全拼的打字速度。</p>
<span id="more"></span>

<h2 id="哪种方案？"><a href="#哪种方案？" class="headerlink" title="哪种方案？"></a>哪种方案？</h2><p>由于以前学了半吊子搜狗的方案，我决定选继续使用搜狗的方案（坑），练了大概一个下午，记住了键位，基本上能够写作和聊天了，只是有些慢，不过没关系，基本上楞个几秒钟就想出来了，这个过程是挺痛苦的，就是那种手跟不上大脑思考的速度的感觉，不过，假如你坚持几天，你会佩服自己的。</p>
<p>后来我发了一个即刻状态：<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220731143438.png"><br>一大堆人给我安利：小鹤方案，然后我意识到可能sogou的方案可能没有小鹤的好，于是我在网上搜了小鹤的方案，发现小鹤的零声母的处理比sogou更加优雅。</p>
<p>sogou的方案默认使用 <code>o</code> + 对应的韵母来实现打字，背诵起来是轻松不少，但是打字的时候感觉不是特别顺手。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220731121420.png"><br>小鹤的零声母方案把韵母的首字母当作声母 ：<br>    单字母韵母，零声母 + 韵母所在键，如： 啊＝aa 哦&#x3D;oo 额&#x3D;ee<br>    双字母韵母，零声母 + 韵母末字母，如： 爱＝ai 恩&#x3D;en 欧&#x3D;ou<br>    三字母韵母，零声母 + 韵母所在键，如： 昂＝ah</p>
<p>小鹤方案更加符合直觉，虽然需要记忆，但是要比其他方案顺手。比如，打一个 西安，sogou是<br><code>xioj</code>，小鹤是<code>xian</code> ，<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220731121321.png"></p>
<p>除了零声母的方案，其他的键位相对于sogou来说也顺手不少，对于刚熟悉了sogou的双拼方案的我来说又是一次挑战，不过还好，一大半的键位都是一致的，虽然经历了一些波折，最终还是归于小鹤，毕竟小鹤是广大双拼爱好者们共同摸索出来的，所以如果你要学习双拼一定直接选择小鹤，不要走弯路了。</p>
<h2 id="键位如何记忆？"><a href="#键位如何记忆？" class="headerlink" title="键位如何记忆？"></a>键位如何记忆？</h2><p>可以参考官方的记忆口诀：<a href="https://help.flypy.com/#/up">小鹤入门</a><br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20220731122811.png"></p>
<h2 id="如何练习？"><a href="#如何练习？" class="headerlink" title="如何练习？"></a>如何练习？</h2><ol>
<li>在 <a href="https://help.flypy.com/#/">小鹤入门</a> 记忆口诀</li>
<li>建议直接在<a href="https://api.ihint.me/shuang/">双拼练习 @ BlueSky</a> 练习即可，键位掌握半天时间就够了</li>
<li>记住了键位之后，就可以把系统的输入法切换成双拼输入法了，macOS，windows，ios都是自带的有双拼输入法的，而且有多种方案可以选择。</li>
<li>也许你该找个人聊聊天？</li>
</ol>
<p>PS. 全篇文章使用macOS自带的双拼输入法（小鹤方案）写作完成。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://api.ihint.me/shuang/">双拼练习 @ BlueSky</a></li>
<li><a href="https://help.flypy.com/#/">小鹤入门</a></li>
</ol>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>双拼输入法</tag>
      </tags>
  </entry>
  <entry>
    <title>将Apple Watch跑步数据同步到Garmin</title>
    <url>/2023/07/08/apple-watch-to-shuzixindong/</url>
    <content><![CDATA[<p>起因是这样的，上马有个积分的功能，他可以影响正常的抽签（虽然是黑盒，但是有人反馈关系很大）的权重，而积分只能通过，签到，线下比赛，以及跑步获取，前两种好理解，第三种，跑步记录换取积分，需要上马官方合作伙伴数字心动APP来提供数据，然而，数字心动APP只能通过Garmin设备通过，并不支持Apple Watch直接上传（如果支持了，那么也没有这个项目了），于是我想是否能够曲线救国，将记录上传到Garmin，然后再通过Garmin同步到数字心动，这样就可以正常获取积分了。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202311152208371.png" alt="Twitter"></p>
<p>首先我需要做的是验证可行性，于是我研究了一下Garmin开发者平台<a href="https://developer.garmin.com/fit/file-types">^1</a>，发现Fit文件中包含了设备信息的，Garmin设备应该都是上传的Fit文件，所以，理论上可以通过将GPX转换为Fit文件，同时将设备信息写入Fit文件就可以伪装成Garmin设备上传的记录。</p>
<p>然后我花了一下午做了一个简单的POC，把我导出的GPX文件转换为Fit（当然也可以直接用Fit文件，Apple Watch导出的也是Fit文件）文件，然后通过Garmin Fit的SDK工具将文件decode成csv，然后把设备信息加上重新打包成fit上传Garmin Connect，跑步记录中就有设备信息了，经测试，这个伪造的运动记录可以正常从Garmin同步到数字心动了，于是上马APP上也就有了跑步的里程信息。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202311152210877.png" alt="Twitter"></p>
<p>于是接下来就是将这个过程自动化了，刚好发现一直在用的跑步主页项目<a href="https://github.com/yihong0618/running_page">Running page</a>中的Strava脚本有backup到Garmin的功能，因此我就想，能否通过这个修改脚本加入默认的Garmin设备，这样就可以将健身记录通过Garmin间接的同步到其他APP中，不仅仅是数字心动,实现的效果如下图：<br><a href="https://user-images.githubusercontent.com/8613196/250013264-ba668c5f-2dab-4405-b2d6-f0e49b4c99d4.png">Strava_to_garmin</a></p>
<p>于是就开干了，改动不是很大，主要就是将原来的Fit文件decode，然后加入Fake的Garmin信息，然后重新打包成新的Fit文件， 最终的PR在这里：<a href="https://github.com/yihong0618/running_page/pull/435">https://github.com/yihong0618/running_page/pull/435</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202311152217854.png"></p>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title>上海马拉松自动签到工具</title>
    <url>/2023/11/05/shangma-auto-sign-tool/</url>
    <content><![CDATA[<p><img src="https://github.com/zhaohongxuan/shangma_auto_sign/assets/8613196/702b57e1-eb15-4acb-b0ab-8cab448c6003" alt="254017014-2ea91157-452f-4113-887b-a6de8e14cf08-2"></p>
<p>前端时间写的<a href="https://github.com/zhaohongxuan/shangma_auto_sign">上海马拉松自动签到工具</a>已经完成很久了，有不少跑友都反映上马抽中了，而我也在经历了8年没中之后，今年很“幸运”的抽中了上海马拉松了，开心之情溢于言表，于是便想写一些内容来记录一下这个过程。</p>
<span id="more"></span>

<p>上海马拉松在中国应该算是顶级的马拉松赛事了，对于每一位跑者都意义非凡，对我来说，我一直想要跑一次上马，然而从15年开始抽签，一直抽到2022年，一直都没中，于是在小红书上看一些攻略，发现有人说上马积分对于抽签比重占的很大，尤其是当年度的积分，由于积分只能通过跑步、签到、以及赛事获取，我打算从签到和跑步来实现我攒积分的目标，其中跑步我已经在前面的文章中写过了，可以将Apple Watch同步到Strava再同步到Garmin，然后同步到数字心动，再到上马来获取积分。</p>
<p>那么签到呢？在我签过几次到之后我想能否实现一个自动化的签到程序，从而避免自己天天手动签到呢？虽然积分很少，但是日积月累也是相当可观的，一年也有365积分，相当于参加两次线下比赛了。</p>
<p>于是开始着手开始做，首先要研究上马的API，最简单的想法就是，获取Cookie，然后调用签到接口直接签到即可，或者使用OAuth认证拿到Token即可。嗯，想法确实不错，事实上也的确如此，只不过上马所有的API都有加密，然后后端验签，因此我使用Python写的脚本根本不能用，因为没有找到加密的方法以及密钥。所以我打算转而使用Javascript来实现，因为所有的Client加密应该都能拿到加密方法以及密钥，所以我在混淆过后的js代码debug，找到了sign的方法，直接将几个参数拼接，然后调用sign方法即可。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202311152244882.png"><br>当然，这样必须依赖Cookie，然而第一个版本是可以正常work的。</p>
<p>接下来要进行优化的就是使用用户名和密码进行登录签到，这样就涉及到了加密，于是我又仔细的debug了Login时的js代码，发现加密过程中的的nonstr是不变的，nonstr就是用来生成加密时的Key和初始向量（IV），有了它们，加解密也就可以轻松完成了。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202311152250830.png">，</p>
<p>加解密代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">encrypt</span>(<span class="params">word</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> srcs = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(word)</span><br><span class="line">  <span class="keyword">var</span> encrypted = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(srcs, key, &#123;</span><br><span class="line">    <span class="attr">iv</span>: iv,</span><br><span class="line">    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> encryptTxt = encrypted.<span class="property">ciphertext</span>.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">const</span> hexString = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(encryptTxt)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Base64</span>.<span class="title function_">stringify</span>(hexString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">decrypt</span>(<span class="params">encryptWord</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> wordArray = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Base64</span>.<span class="title function_">parse</span>(encryptWord)</span><br><span class="line">  <span class="keyword">const</span> encryptedCiphertext = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">stringify</span>(wordArray)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> encrypted = <span class="title class_">CryptoJS</span>.<span class="property">lib</span>.<span class="property">CipherParams</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">ciphertext</span>: <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(encryptedCiphertext)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> decrypt = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">decrypt</span>(encrypted, key, &#123;</span><br><span class="line">    <span class="attr">iv</span>: iv,</span><br><span class="line">    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">var</span> decryptedStr = decrypt.<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>)</span><br><span class="line">  <span class="keyword">return</span> decryptedStr.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title>小米AX1800实现科学上网</title>
    <url>/2023/12/17/xiaomi-ax1800-shellclash/</url>
    <content><![CDATA[<p>一直想在家中实现全局科学上网，这样在家里就不需要一直开着各种客户端了，一方面是每个设备科学上网的客户端都还不一样，存在重复配置，另一方面，客户端也会加快电池的消耗，本来打算投资软路由或者旁路由的，经过一番搜索发现小米的AX1800路由器是基于openwrt的，可以通过<a href="https://github.com/juewuy/ShellCrash/blob/master/README_CN.md">ShellClash项目</a>在不影响原系统的情况下实现科学上网，这篇文章记录一下安装的经过，理论上所有的openwrt的路由器都可以安装，只要搜索自己路由器的型号，查找ssh登录的方法就行了。</p>
<span id="more"></span>

<h3 id="固件准备"><a href="#固件准备" class="headerlink" title="固件准备"></a>固件准备</h3><p>并不是所有的版本都能刷OpenClash，小米AX1800最后一个可以开通ssh的版本是：1.0.336<br>下载地址： <a href="https://github.com/chr1sc2y/warehouse-deprecated/blob/main/resources/proxy/miwifi_rm1800_firmware_fafda_1.0.336.bin">miwifi_rm1800_firmware_fafda_1.0.336.bin</a><br>在路由器的系统状态页点击：手动升级，然后选择下载的固件，进行降级。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217074805.png" alt="image.png"></p>
<h3 id="开启ssh并设置root密码"><a href="#开启ssh并设置root密码" class="headerlink" title="开启ssh并设置root密码"></a>开启ssh并设置root密码</h3><p>路由器降级成功之后，在路由器管理界面，打开Chrome控制台，将下面的脚本粘贴进去，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSTOK</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> match = location.<span class="property">href</span>.<span class="title function_">match</span>(<span class="regexp">/;stok=(.*?)\//</span>);</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params">stok, command</span>) &#123;</span><br><span class="line">    command = <span class="built_in">encodeURIComponent</span>(command);</span><br><span class="line">    <span class="keyword">let</span> path = <span class="string">`/cgi-bin/luci/;stok=<span class="subst">$&#123;stok&#125;</span>/api/misystem/set_config_iotdev?bssid=SteelyWing&amp;user_id=SteelyWing&amp;ssid=-h%0A<span class="subst">$&#123;command&#125;</span>%0A`</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(location.<span class="property">origin</span> + path));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">enableSSH</span>(<span class="params"></span>) &#123;</span><br><span class="line">    stok = <span class="title function_">getSTOK</span>();</span><br><span class="line">    <span class="keyword">if</span> (!stok) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;stok not found in URL&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stok = “<span class="subst">$&#123;stok&#125;</span>”`</span>);</span><br><span class="line"></span><br><span class="line">    password = <span class="title function_">prompt</span>(<span class="string">&#x27;Input new SSH password&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!password) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;You must input password&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">execute</span>(stok,</span><br><span class="line">            <span class="string">`  </span></span><br><span class="line"><span class="string">    nvram set ssh_en=1  </span></span><br><span class="line"><span class="string">    nvram commit  </span></span><br><span class="line"><span class="string">    sed -i ‘s/channel=.*/channel=\\”debug\\”/g’ /etc/init.d/dropbear  </span></span><br><span class="line"><span class="string">    /etc/init.d/dropbear start  </span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">text</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(text));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;New SSH password: &#x27;</span>+password);</span><br><span class="line">    <span class="title function_">execute</span>(stok, <span class="string">`echo -e “<span class="subst">$&#123;password&#125;</span>\\n<span class="subst">$&#123;password&#125;</span>” | passwd root`</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">text</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(text));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">enableSSH</span>();</span><br></pre></td></tr></table></figure>

<p>在弹出狂中填入ssh root账号的密码，这里设置为<code>admin</code><br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217075253.png" alt="image.png"></p>
<h3 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h3><p>首先确定一下路由器的ip地址，在路由器管理界面可以查看到，一般是<code>192.168.31.1</code>，因为我是中继的，所以路由器的地址是<code>192.168.1.7</code>。这里需要根据自己的实际需求来修改。</p>
<p>使用下面的ssh命令，输入刚才设置的密码<code>admin</code>登录到小米路由器后台：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.7</span><br></pre></td></tr></table></figure>

<p>正常情况下应该是可以登录的，但是我的报了个错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to negotiate with 192.168.1.7 port 22: no matching host key type found. Their offer: ssh-rsa</span><br></pre></td></tr></table></figure>

<p>使用下面的命令可以正常登录了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -oHostKeyAlgorithms=+ssh-rsa root@192.168.1.7</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217075829.png" alt="image.png"></p>
<h3 id="安装ShellClash"><a href="#安装ShellClash" class="headerlink" title="安装ShellClash"></a>安装ShellClash</h3><p>访问 <a href="https://github.com/juewuy/ShellCrash/blob/master/README_CN.md">ShellClash安装</a>有详细的安装步骤</p>
<p>如果可以访问Github可以用Github源，如果不行的话可以使用jsDelivrCDN源或者作者私人源。</p>
<p><strong>路由设备使用curl安装</strong>：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GitHub源(可能需要代理)</span></span><br><span class="line">export url=&#x27;https://raw.githubusercontent.com/juewuy/ShellCrash/master&#x27; &amp;&amp; sh -c &quot;$(curl -kfsSl $url/install.sh)&quot; &amp;&amp; source /etc/profile &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">jsDelivrCDN源</span></span><br><span class="line">export url=&#x27;https://fastly.jsdelivr.net/gh/juewuy/ShellCrash@master&#x27; &amp;&amp; sh -c &quot;$(curl -kfsSl $url/install.sh)&quot; &amp;&amp; source /etc/profile &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">作者私人源</span></span><br><span class="line">export url=&#x27;https://gh.jwsc.eu.org/master&#x27; &amp;&amp; sh -c &quot;$(curl -kfsSl $url/install.sh)&quot; &amp;&amp; source /etc/profile &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>按照指引安装即可。</p>
<h3 id="使用Clash"><a href="#使用Clash" class="headerlink" title="使用Clash"></a>使用Clash</h3><p>安装成功之后，在命令行中输入clash进入面板</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217080301.png" alt="image.png"></p>
<h4 id="导入配置"><a href="#导入配置" class="headerlink" title="导入配置"></a>导入配置</h4><p>这里选择2，导入Clash配置文件链接。<br>如果你买的是现成的机场的话，一般会有clash订阅的地址，copy粘贴到里面即可。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217080551.png" alt="image.png"></p>
<p>如果是自己搭建的V2ray的话，需要生成订阅链接，把其他协议如ss，ssr，vmess等转换为clash，可以使用开源工具<a href="https://github.com/CareyWang/sub-web">sub-web</a>自己搭建，也可以使用别人搭建的公益网站，，<strong>注意⚠️</strong>：使用第三方的转换工具可能会导致节点泄漏，这里笔者使用公益网站的是：<a href="https://convert.imgki.com/">https://convert.imgki.com/</a></p>
<p>使用方法很简单，把vmess协议的链接放进去，然后点击生成订阅，剩下的可以上一步一样。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217081026.png" alt="image.png"></p>
<h4 id="安装面板"><a href="#安装面板" class="headerlink" title="安装面板"></a>安装面板</h4><p>在开始菜单中输入9 更新&#x2F;卸载<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217081241.png" alt="image.png"></p>
<p>选择4 安装本地Dashboard面板，安装推荐安装即可。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217081310.png" alt="image.png"></p>
<p>面板Dashboard安装完成之后，输入<code>http://192.168.1.7:9999/ui/</code> 即可进入Clash后台，这里的ip地址改成自己路由器的地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231217081422.png" alt="image.png"></p>
<p>接下来就是愉快的使用了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/juewuy/ShellCrash/blob/master/README_CN.md">https://github.com/juewuy/ShellCrash/blob/master/README_CN.md</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/458905777">小米 AX1800 安装 ShellClash - 知乎</a></li>
<li><a href="https://forum.openwrt.org/t/unable-to-connect-via-ssh-no-matching-host-key-type-found/114430">https://forum.openwrt.org/t/unable-to-connect-via-ssh-no-matching-host-key-type-found/114430</a></li>
</ul>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>AX1800</tag>
        <tag>Clash</tag>
        <tag>ShellClash</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka为什么这么快？</title>
    <url>/2023/12/19/why-kafka-so-fast/</url>
    <content><![CDATA[<h2 id="Kafka为什么这么快（吞吐性高）？"><a href="#Kafka为什么这么快（吞吐性高）？" class="headerlink" title="Kafka为什么这么快（吞吐性高）？"></a>Kafka为什么这么快（吞吐性高）？</h2><p>kafka作为一个处理实时数据和日志的管道，每秒可以处理几十万条消息，那么为什么Kafka的吞吐量这么高呢？ </p>
<p>我们先来看一下Kafka的文件存储系统：</p>
<p><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20231219184832.png" alt="kafka file system"></p>
<span id="more"></span>

<h3 id="分区机制"><a href="#分区机制" class="headerlink" title="分区机制"></a>分区机制</h3><p>Kafka中一个主题有多个Partition（分区），一个Topic可以横跨多个Broker。在生产消息时，因此在向Topic发送消息的时候将消息<code>并发地</code>写入到多个broker ，broker的数量可以横向扩展。</p>
<p>在消费消息时，引入了消费者群组（Consumer Group）的概念，一个分区只能被一个消费者群组中的的一个消费者消息，但是可以被其他群组的消费者消费，可以在一个消费组里起多个消费者，每个消费者消费一个分区，这样就提高了消费者的性能。需要注意的是，消费组里的消费者个数如果多于分区数的话，那些多出来的消费者就会处于空闲状态，所以一个消费组里的消费者个数跟分区数相等就好了。</p>
<p>分区的设计使得Kafka消息的读写性能可以突破单台broker的I&#x2F;O性能瓶颈，可以在创建主题的时候指定分区数，也可以在主题创建完成之后去修改分区数，通过增加分区数可以实现水平扩展，但是要注意，分区数也不是越多越好，一般达到某一个阈值之后，再增加分区数性能反而会下降，具体阈值需要对Kafka集群进行压测才能确定。</p>
<h3 id="日志分段存储"><a href="#日志分段存储" class="headerlink" title="日志分段存储"></a>日志分段存储</h3><p>为了防止日志（Log）过大，Kafka引入了日志分段（LogSegment）的概念，将日志切分成多个日志分段。在磁盘上，日志是一个目录，每个日志分段对应于日志目录下的日志文件、偏移量索引文件、时间戳索引文件（可能还有其他文件）。<br>向日志中追加消息是顺序写入的，只有最后一个日志分段才能执行写入操作，之前所有的日志分段都不能写入数据。  </p>
<p>为了便于检索，每个日志分段都有两个索引文件：&#x3D;&#x3D;偏移量索引文件&#x3D;&#x3D;和&#x3D;&#x3D;时间戳索引文件&#x3D;&#x3D;。每个日志分段都有一个基准偏移量baseOffset，用来表示当前日志分段中第一条消息的offset。偏移量索引文件和时间戳索引文件是以稀疏索引的方式构造的，偏移量索引文件中的偏移量和时间戳索引文件中的时间戳都是严格单调递增的。查询指定偏移量（或时间戳）时，使用<code>二分查找</code>快速定位到偏移量（或时间戳）的位置。可见Kafka中对消息的查找速度还是非常快的。</p>
<h3 id="操作系统页缓存"><a href="#操作系统页缓存" class="headerlink" title="操作系统页缓存"></a>操作系统页缓存</h3><p>页缓存是操作系统实现的一种主要的磁盘缓存，以此用来减少对磁盘I&#x2F;O的操作。具体来说，就是把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问。  </p>
<p>Kafka中大量使用了页缓存，消息都是先被写入页缓存，再由操作系统负责具体的刷盘任务（Kafka中也提供了<code>同步刷盘</code>和<code>异步刷盘</code>的功能）</p>
<p>Kafka并不太依赖JVM内存大小，而是主要利用Page Cache，如果使用应用层缓存（JVM堆内存），会增加GC负担，增加停顿时间和延迟，创建对象的开销也会比较高。</p>
<p>读取操作可以直接在Page Cache上进行，如果消费和生产速度相当，甚至不需要通过物理磁盘直接交换数据，这是Kafka高吞吐量的一个重要原因。</p>
<p>这么做还有一个优势，如果Kafka重启，JVM内的Cache会失效，Page Cache依然可用。</p>
<h3 id="磁盘顺序访问"><a href="#磁盘顺序访问" class="headerlink" title="磁盘顺序访问"></a>磁盘顺序访问</h3><p>Kafka的每条消息都是append的，不会从中间写入和删除消息，保证了磁盘的顺序访问，所以不管文件多大，写入总是O(1)的时间复杂度。减少频繁的小IO操作，Kafka的策略是把消息集合在一起，批量发送，尽可能减少对磁盘的访问。</p>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>写入的时候放到RecordAccumulator进行聚合，批量压缩，还有批量刷盘等…</p>
<h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>异步操作可以在调用send方法后立即返回，等待buffer满了之后交给poll线程，发送消息、接收消息、复制数据也都是通过NetworkClient封装的poll的方式。</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><blockquote>
<p>Kafka 使用零复制技术向客户端发送消息——也就是说，Kafka 直接把消 息从文件（或者更确切地说是 Linux 文件系统缓存）里发送到网络通道，而不需要经过任 何中间缓冲区。这是 Kafka 与其他大部分数据库系统不一样的地方，其他数据库在将数据 发送给客户端之前会先把它们保存在本地缓存里。这项技术避免了字节复制，也不需要管理内存缓冲区，从而获得更好的性能。</p>
</blockquote>
<p>我们以将磁盘文件通过网络发送为例。传统模式下，一般使用如下伪代码所示的方法先将文件数据读入内存，然后通过Socket将内存中的数据发送出去。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20231219174217.png" alt="none zero copy"></p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer = File.read</span><br><span class="line">Socket.send(buffer)</span><br></pre></td></tr></table></figure>

<p>这一过程实际上发生了四次数据拷贝。首先通过系统调用将文件数据读入到内核态Buffer（DMA拷贝），然后应用程序将内存态Buffer数据读入到用户态Buffer（CPU拷贝），接着用户程序通过Socket发送数据时将用户态Buffer数据拷贝到内核态Buffer（CPU拷贝），最后通过DMA拷贝将数据拷贝到NIC Buffer。同时，还伴随着四次上下文切换。</p>
<p><strong>sendfile和transferTo实现零拷贝</strong></p>
<p>Linux 2.4+内核通过<code>sendfile</code>系统调用，提供了零拷贝。数据通过DMA拷贝到内核态Buffer后，直接通过DMA拷贝到NIC Buffer，无需CPU拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件-网络发送由一个<code>sendfile</code>调用完成，整个过程只有两次上下文切换，因此大大提高了性能。</p>
<p>具体实现上，Kafka的数据传输通过TransportLayer来完成，其子类<code>PlaintextTransportLayer</code>通过Java NIO的FileChannel的<code>transferTo</code>和<code>transferFrom</code>方法实现零拷贝。</p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>Kafka使用端到端的块压缩功能。如果启用，数据将由producer压缩，以压缩格式写入服务器，并由 consumer 解压缩。压缩将提高 consumer 的吞吐量，但需付出一定的解压成本。这在跨数据中心镜像数据时尤其有用。</p>
<p>目前 Kafka 共支持四种主要的压缩类型：Gzip、Snappy、Lz4 和 Zstd。关于这几种压缩的特性，</p>
<table>
<thead>
<tr>
<th>压缩类型</th>
<th>压缩比率</th>
<th>CPU 使用率</th>
<th>压缩速度</th>
<th>带宽使用率</th>
</tr>
</thead>
<tbody><tr>
<td>Gzip</td>
<td>Highest</td>
<td>Highest</td>
<td>Slowest</td>
<td>Lowest</td>
</tr>
<tr>
<td>Snappy</td>
<td>Medium</td>
<td>Moderate</td>
<td>Moderate</td>
<td>Medium</td>
</tr>
<tr>
<td>Lz4</td>
<td>Low</td>
<td>Lowest</td>
<td>Fastest</td>
<td>Highest</td>
</tr>
<tr>
<td>Zstd</td>
<td>Medium</td>
<td>Moderate</td>
<td>Moderate</td>
<td>Medium</td>
</tr>
</tbody></table>
<h2 id="Referreces"><a href="#Referreces" class="headerlink" title="Referreces"></a>Referreces</h2><ul>
<li><a href="https://kafka.apache.org/documentation/#design">Apache Kafka Design</a></li>
<li><a href="https://developer.ibm.com/articles/j-zerocopy/">Efficient data transfer through zero copy - IBM Developer</a></li>
</ul>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>消息中间件</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Templater在Obsidian中实现每日诗词</title>
    <url>/2023/12/20/obsidian-support-daily-poem/</url>
    <content><![CDATA[<p>一直使用Templater的Quote功能，使用方法也很简单，直接使用<code>&lt;% tp.web.daily_quote() %&gt;</code> ，但是默认调用的接口是：<a href="https://api.quotable.io/">https://api.quotable.io</a>, 返回的英文的名言，如果想要中文的名言或者每日诗词等就没法做到。 好在Templater的作者还留了一个口子：用户脚本，用户可以自己按照<a href="https://flaviocopes.com/commonjs/">CommomJS</a>的规范来编写自己的脚本，文档参考这里：<a href="https://silentvoid13.github.io/Templater/user-functions/script-user-functions.html">Templater User function</a>，这里需要注意的是：<strong>不支持第三方node module！！</strong></p>
<span id="more"></span>

<h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><p>因此我们只需要调用一个今日诗词的接口就行了，这里选择了<a href="https://v1.jinrishici.com/">今日诗词</a>的接口，接下来就是请求数据然后解析数据了。<br>然后由于obsidian的限制，我们不能直接引用第三方的node module，比如<code>node-fetch</code>，好在Templater暴露了obsidian自身的接口，接口都在<code>tp.obsidian</code>中，因此，我们可以利用Obsidian自身的<code>request</code>方法来调用古诗词的api返回我们自己想要的内容，下面是示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">daily_poem</span>(<span class="params">tp</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> tp.<span class="property">obsidian</span>.<span class="title function_">request</span>(<span class="string">&#x27;https://v1.jinrishici.com/all/&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> &#123; content,origin,author &#125; =  <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response) ;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`&gt;[!quote] \n <span class="subst">$&#123;content&#125;</span>  &lt;cite style=&quot;text-align: right; display: block;&quot; &gt; —  <span class="subst">$&#123;author&#125;</span>·《<span class="subst">$&#123;origin&#125;</span>》&lt;/cite&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = daily_poem;</span><br></pre></td></tr></table></figure>
<p>代码中对cite的位置做了调整，默认是向左对齐的，我改成了向右对齐，如果不喜欢的，可以手动修改。</p>
<h3 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h3><h4 id="保存脚本"><a href="#保存脚本" class="headerlink" title="保存脚本"></a>保存脚本</h4><p>复制上面的脚本代码保存为一个js文件，这里命名为<code>daily_poem.js</code>，并将脚本存放在Vault中的一个文件夹中，笔者设置的是：<code>Assets/Script</code>，你可以根据自己的实际需求设定，这个文件夹在下面使用的使用要用。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202312201206853.png"></p>
<h4 id="设定脚本所在的文件夹"><a href="#设定脚本所在的文件夹" class="headerlink" title="设定脚本所在的文件夹"></a>设定脚本所在的文件夹</h4><p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202312201205855.png"></p>
<h4 id="在Daily-Notes模板中使用"><a href="#在Daily-Notes模板中使用" class="headerlink" title="在Daily Notes模板中使用"></a>在Daily Notes模板中使用</h4><p>在自己的Daily Notes的模板中直接使用 <code>&lt;% tp.user.daily_poem(tp) %&gt;</code>即可使用，这里必须要传tp进去，因为tp是Templater的全局变量，如果不手动传入，就不能调用obsidian的request方法。<br>下面是我在Daily Notes中使用的效果：<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202312201214674.png"></p>
<p>当然，除了调用现成的API处理json数据之外，如果访问的页面是原始HTML，还可以处理DOM元素，使用选择器来获取我们想要的数据，可玩性更高了。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://silentvoid13.github.io/Templater/user-functions/script-user-functions.html">使用脚本自定义用户函数</a></li>
<li><a href="https://silentvoid13.github.io/Templater/internal-functions/internal-modules/obsidian-module.html">Obsidian内置函数</a></li>
</ol>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>obsidian</tag>
        <tag>古诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>再见，我的2023</title>
    <url>/2023/12/27/2023-review/</url>
    <content><![CDATA[<p>首先我要感谢这一年的自己，对自己说一声辛苦了。虽然这一年过得十分艰难，很多事情都发展不顺利，但是还是要对自己说一声辛苦了，最起码坚持到了最后，成功又度过了一年。</p>
<h2 id="一些收获"><a href="#一些收获" class="headerlink" title="一些收获"></a>一些收获</h2><p>从2023年底到今年年初，主要是和同学一起翻译《Python for MATLAB Development》，人民邮电出版社引进的一本比较小众的技术书，出版社审核的时间有点长，不出意外的话，应该2024年第一季度会出版，这是我正式翻译的第一本书，难度确实不小，虽然现在各类翻译软件层出不穷，但是想要准确的翻译还是有不小的挑战的，里面的专业词汇有点多，长句也很多，花了将近半年才翻译完。</p>
<span id="more"></span>

<p>开源方面，今年没挖大坑，主要就是围绕着跑步和骑行构建了一些自己的工具。首先是使用<a href="https://github.com/ben-29">@ben-29</a> 的<a href="https://github.com/ben-29/workouts_page">workout page</a>,把自己的骑行数据展示到<a href="https://zhaohongxuan.github.io/workouts/">我的运动主页</a>了，确实很很酷。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20231227122237.png" alt="image.png"></p>
<p>围绕着跑步也贡献了一部分代码，一个比较大的项目是：<a href="https://github.com/zhaohongxuan/shangma_auto_sign">上马自动签到工具</a>，为了给自己偷懒，自己分析上马官网前端代码，使用Nodejs写了一个上马签到的程序，由于之前都是Java技术栈，没怎么使用过Nodejs，边查Javascript语言文档边写代码，最终花了一个晚上和一个上午把工具给做出来了。去年做的<a href="https://github.com/zhaohongxuan/obsidian-weread-plugin">微信读书Obsidian插件</a>也是，主意都是一念之间想起来的，Typescript语言也是边学边写，那时候还没有ChatGPT，结果三天就把原型代码写出来了，还是挺佩服我自己的。</p>
<p>此外，还给Running Page贡献了几个feature，比如为Keep导出的GPX文件增加心率数据，还有为同步到Garmin的运动记录中增加Device Info等。这些都是我在实际中遇到的问题，我只不过是把这些问题解决了而已，同时这些Feature也能帮助别人，何乐而不为呢？</p>
<p>今年开始花费了不少在Twitter（X）上公开表达，主要是把自己的一些想法和学到的东西分享出来，主要是下半年开始玩，粉丝涨到了3K多，不是特别在意粉丝的多少，这些数据都是次要的，发推主要是为了分享自己学习的一些结果，公开学习有助于自己表达。</p>
<h2 id="生活日常"><a href="#生活日常" class="headerlink" title="生活日常"></a>生活日常</h2><p>女儿今年已经两岁多了，这个时间段是最调皮捣蛋的时候，而且精力十分旺盛，作息时间已经和大人基本一致了，需要花费很多精力去陪她，回想刚过年的时候，女儿刚学会走路，趔趔趄趄的往前扑，仿佛看到了小时候的自己。和小朋友在一起的时候虽然有的时候各种淘气捣蛋惹人生气，但是大部分很开心，因为一切都是向上的，在每一天平淡的日子里，她们在一点点的成长。</p>
<p>生活就是日常点滴的汇聚，大多数时候都感觉生活很幸福的，自从去年年底买了车之后，今年去的地方也多了，去了上海海洋馆，野生动物园，金山城市沙滩，东海等，自驾回老家洛阳了两趟，和老婆一起去了老君山，鸡冠洞等，除此之外，去周边的儿童乐园玩什么的，开车也是很方便的，不得不说，车在一定程度上提高了生活的幸福感。</p>
<p>就像一个平静的湖面突然落入一颗石子一样，总是会出现一些意外来打破生活的平静，五一刚从老家回上海没几天，大哥就中风了，情况很严重，做了脑部手术，老妈需要回家一段时间照顾，我也请假在家了一段时间来照顾女儿，突然有一瞬间，我感觉这个世界太残酷了，健康是一个人的根本，但是大部分健康的人是体会不到的，你正在经历的日常可能就是他人遥不可及的梦。</p>
<p>八月份的时候，女儿在小区里走路的时候，被一个4岁的小男孩骑车撞了一下，我赶紧带她去儿科医院缝了针，这是当爸爸的最难受的一次，虽然伤口很小，但是女儿哭的特别厉害，这时候恨不得自己替她承受这一份苦难，然而并不能，这一刻，我又一次体会到了父母的艰辛。而事情还没结束，由于当时对方父母不在场，监控又在死角，还好当时旁边有好心人说了这个小男孩家里的门牌号，最终又是一场心累的沟通，经过居委的多次调节，对方答应承担医药费了。好在小孩子的伤口都恢复的比较快，一周缝线就脱落了，但是还是有一些伤疤，一直在用去伤疤的药，现在伤疤越来越淡了，期待伤疤赶快消失。</p>
<p>细数下来，今年发生的事情几乎都是不怎么好的事情，可能大脑对于不好的事情总是记的特别牢固，但是对于开心快乐的时刻忘的比较快，经常在翻阅照片的时候才会发现大部分时候记录的都是快乐的时光，可能快乐的时间过得太快导致记忆出现偏差了吧。</p>
<h2 id="新玩意儿"><a href="#新玩意儿" class="headerlink" title="新玩意儿"></a>新玩意儿</h2><p>年初购买了 Macbook Pro 14  2021 ，之前的Macbook Pro 2017屏幕出现了舞台光，非常影响使用，这个应该算是通病，但是苹果没有维修计划，只能便宜卖了，刚好2021款的降价幅度比较大，不到9700就能到手了，于是果断下单了，体验下来确实要比英特尔芯片的Macbook要强大不少，出门基本上没带过充电线。</p>
<p>Giant Revolt F1 主要用于上下班通勤，单程38km骑了好几个月，最后胖了好几斤，骑车的确不能减肥，想要减肥而买车还是需要三思。</p>
<p>由于时光相册关停，相册备份成了一个问题，刚好双十一入手了 Green DX4600 NAS，买成品NAS主要是考虑到折腾的少，主要用于照片备份以及搭建影音库，没有必要自己折腾，刚好把之前的盛夏的三块2.5寸硬盘都利用上了。</p>
<p>终于把之前的眼镜淘汰了，配了蔡司的眼镜，相比较之前的旧眼镜，感觉蔡司的镜片透光度提升了很多，眼镜店里测了下旧眼镜，发现透光度只有86%了，我也不知道这两年咋过的。。总之，这些天天使用的工具，一定要选好的，能提高了不少幸福度。</p>
<p>另外，今年还花了128买了微信读书年卡会员，总体感觉还是挺值的，一年之内读了不少书，还攒了不好书币，应该算是超值了，不过明年应该不会再续了，先把手上攒的书读完再说。</p>
<h2 id="工作相关"><a href="#工作相关" class="headerlink" title="工作相关"></a>工作相关</h2><p>这一年的中国经济的基调是“下降”，公司作为一家外企发展并不太好，呆在现在的公司已经3年了，能感受到今年要做的需求再慢慢减少，就目前来说，公司的现金流紧张，现在正在经历裁员和私有化，最最操蛋的是，已经Vest的股票也要作废，令人发指，然而Repackage却符合该国的法律，真是滑稽啊。</p>
<p>基金投资躺平了一年之后，亏损日益扩大，最多的一只基金已经亏损了近50%，好在年中的时候看李笑来的《让时间陪你慢慢变富》的时候，学到了分散投资，把一部分资金投入了美股的ETF基金，减少了相当一部分的损失，不过整体上对未来在股市上的预期降低了很多。</p>
<p>有那么几个瞬间，我仿佛想明白了工作的意义，工作只是手段，不是目的，如果工作是朝着自己的长期目标前进的时候，那么你一定做着自己热爱的事情，那就勇敢前行吧，如果不是，那么就要重新想象自己未来的长期目标和工作的关系了，重新寻找一个能唤起自己激情的地方吧，多寻找，多尝试，我想总会找到的。</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>粗略的想好像这一年没怎么读书，但是看了微信读书的报告，还是吓了一跳，发现这一年居然读了十几本书，大部分时候都是在地铁上读，因为平时自己的时间真的太少了，有的时候还挺喜欢在地铁上读书的，感觉比在家里沙发上读书更容易专注，仿佛地铁嘈杂的声音是白噪声似的，地铁上我一般使用Boox Poker3电纸书阅读，对眼睛友好，用它读了不少历史方面的书，特别是张宏杰老师的书，太上瘾了，下面简单列一下今年看的书。</p>
<ul>
<li>1月《悉达多》</li>
<li>2月《纳瓦尔宝典》</li>
<li>3月《汴京之围：北宋末年的外交、战争和人》</li>
<li>4月《Kafka权威指南》《Designing Data-Intensive Applications》（Ongoing）</li>
<li>5月《道德经》</li>
<li>6月《楚汉双雄》、《智慧和魔咒》</li>
<li>7月《法治的细节》、《饥饿的盛世》、《千年悖论》</li>
<li>8月《大明王朝的七张面孔》</li>
<li>9月《让时间陪你慢慢变富》</li>
<li>10月《中国历代政治得失》</li>
<li>11月《我与地坛》、《宝贵的人生建议》</li>
<li>12月《定位》、《长安的荔枝》、《挑战不可能》（Ongoing）</li>
</ul>
<p>这里面的书除了DDIA都看完了，DDIA事由于中英对照着看，进度有点慢，到现在还有几个章节没看完，不过收获确实很大，对数据系统有了更加深刻的认知。</p>
<h2 id="骑行和跑步"><a href="#骑行和跑步" class="headerlink" title="骑行和跑步"></a>骑行和跑步</h2><p>上半年的主旋律是骑行，3月份的时候买了一辆平把公路车Giant Revolt F1，一直拿来用于上下班，今年骑了好几次淀山湖，还有太浦河，前灯古镇，当然冬天的时候还骑了苏州太湖的东山（本来打算骑东西山的，风太吹了，放弃）。</p>
<p>骑行的时间长了，跑步自然就少了，今年总共跑了六百多公里，和往年比应该是最少一年了，不过今年依然跑了两个马拉松，一个是苏州半程马拉松，还有一个就是上马，很明显都没PB，但是都跑到了我的理想区间，半马1个小时44分，全马3个小时50分钟，主要就是10月份练了一个月，能达到这样的成绩我已经很满意了，明年应该会继续报名上马。</p>
<p>运动是内啡肽分泌的一个重要途径，内啡肽被称为脑内吗啡，能让人感受到幸福，所以我每周都会进行几次运动，冬天的话频次会相对减少一些，但是好的天气一定会出去运动。</p>
<h2 id="思考和展望"><a href="#思考和展望" class="headerlink" title="思考和展望"></a>思考和展望</h2><p>2023年，过得不算太好， 但是仍然有失有的，我仍然感谢生活，至少我都挺过来了，2024年，我应该会更多的时间花费在家庭上，陪伴女儿成长，多出去玩一玩。在技术上深化一下自己的技术栈，拓展自己的职业边界，更多的时间来公开学习，多写作，多记录自己的想法，写作是澄清自己思想的方法，把遇到的各种问题和解决方法，多输出一些有价值的内容，探索自己的好奇心和Passion，寻找更多可能性，争取更多的闲暇时间来<code>build something wonderful</code>，可以是一个开源小工具，可以是写一本书，可以是任何东西，总之，可以让世界变得更加美好就够了。 </p>
<p>我一直认为人生重在体验，体验需要Dive into，所以有的时候需要大胆一些，勇敢一些，尝试一些未曾经体验过的事物，探索内心深处的热爱，去从未到达的地方，去感受这个世界的五彩斑斓，人生是旷野，方向不止一个，多花一点思考自己前行的目标，保持内心平和，身体健康。<br>·</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>生意再小，也要有自己的事业</title>
    <url>/2024/01/06/start-your-business/</url>
    <content><![CDATA[<p>读完了《重来：更为简单有效的商业思维》这本小册子，最大的感受是，「生意再小也要有自己的事业」，且越早开始越好。</p>
<p>事业的可以从自己的「痒处」开始，也就是打造自己需要的产品，不一定是颠覆的产品，可以在现有的产品上进行微创新，但是至少一定解决了人的一些痛点或者痒点的产品。</p>
<span id="more"></span>

<p>一定要抓住这个稍纵即逝的灵感，然后以非常强的行动力去执行，比如放弃出去玩，花上一个周末去打造一个原型产品，然后不断发布产品，投放社区和市场，获取反馈，不断迭代，螺旋型上升，空有灵感，一文不值。</p>
<p>2022年做的微信读书Obsidian插件就是这种感觉，自己在使用的过程需要自己手动copy笔记到Obsidian，感觉很麻烦，于是产生了一个简单的想法：做个插件来同步笔记，给自己偷懒，接下来就是学习Typescript，然后废寝忘食的开始写代码，我记得有一天早上4点起床就开始抱着电脑开始写代码了，到早上8点多发布了插件的第一个版本，整个过程非常投入，完全不感觉到累，只感受到了创造的快乐。</p>
<blockquote>
<p>📌 斯坦利·库布里克（Stanley Kubrick）曾经这样激励电影制片人：“找个摄像机和一些胶片吧，随便拍个什么样的片子出来都成。”库布里克明白，当你刚开始一项工作时，你必须开始创造自己的东西。最重要的事情就是起而行之。所以，拿起摄像机，灌张唱片，开始拍摄吧</p>
</blockquote>
<p>一个绝妙点子还不够，更重要的是超强的行动力，有了行动才有反馈，并产生新点子，然后更好的促使自己行动，就像是一个滚雪球的过程。因此，如果有主意和想法就笃定一点，不要到处询问意见。这里我要分享和菜头的一篇文章：<a href="https://www.hecaitou.com/2023/12/remain-silent-until-done.html">槽边往事: 在完成前保持沉默</a>。</p>
<p>乔布斯曾说过，当我们知道了我们所做的世界上的事物都是由哪些并不比我们聪明或者优秀的人打造出来的，我们就可以着手去改变，我们可以创造给这个世界带来美好的事物。一旦我们理解了这个道理，我们就会变得不一样。</p>
<p><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20240105165004.png" alt="image.png"></p>
<p>每一个人都可以有自己的灵感创意，跟随自己的好奇心和兴趣创造出一些有趣的产品，开启自己的事业，这个事业可以不大，只要满足一定用户群体然后持续盈利即可。大有大的难处，小有小的优点，「小」意味着改正错误的成本很小，而且没有在聚光灯之下意味着我们可以灵活调整策略，解决问题，测试创意。因此公司不一定要很大，只有能持续盈利即可。</p>
<p>当然，这个过程会很难，不要轻易放弃自己的主业，可以先在业余时间探索一下自己的兴趣，创作点属于自己的产品，这样可以获得更多的满足感，另一方面还有可能改善经济状况，同时也为未来的职业发展打下基础。</p>
<p>人这一辈子很短，做有趣的事情，去创造吧，在这个宇宙中留下一些足迹吧。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li>重来：更为简单有效的商业思维</li>
</ol>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>思考</tag>
        <tag>商业</tag>
      </tags>
  </entry>
  <entry>
    <title>我的Obsidian笔记工作流</title>
    <url>/2024/01/04/obsidian-workflow/</url>
    <content><![CDATA[<p>个人认为笔记的本质是： <strong>让思考继续发生</strong>。记笔记不是目的，是为了更好的服务于思考，但是大脑不善于存储和检索，因此才要记笔记，本质是上是给大脑减压，记笔记的各种方法也都是为了让大脑更好的思考。大脑本能是躲避思考的，所以要尽可能简化记笔记的流程，形成习惯。</p>
<p>由于我对卡片笔记的理解还不够深刻，也还在探索中，因此这篇文章旨在分享我的一些心得和体会，每个人的习惯不一样，因此笔记方法因人而已，别人的方法不一定是适合自己的，每个人都要探索形成自己的笔记方法。</p>
<h2 id="我的笔记原则"><a href="#我的笔记原则" class="headerlink" title="我的笔记原则"></a>我的笔记原则</h2><span id="more"></span>

<ul>
<li>没有最好的笔记软件，没有工具可以解决所有问题。</li>
<li>没有最好的笔记方法，不迷信任何人的方法，探索自己记录笔记的方法。</li>
<li>方法是可以被改进的，工具是可以被改进的。</li>
<li>记录笔记时多记录元数据，多建立链接和标签，尽量和其他笔记发生链接，尽量不建立Orphan笔记。</li>
<li>笔记要定期回顾，把过期的draft笔记清理掉。</li>
</ul>
<h2 id="为什么是Obsidian？"><a href="#为什么是Obsidian？" class="headerlink" title="为什么是Obsidian？"></a>为什么是Obsidian？</h2><ul>
<li>Obsidian很简单，开箱即用，虽然没有开源，但是个人用户免费。</li>
<li>Obsidian基于纯文本的markdown文件，不怕跑路，就算跑路了，markdown转移到其他软件中成本也小。</li>
<li>Obsidian不是基于网络的，离线同步的模式可以更好的适应不同的环境。</li>
<li>Obsidian够开放，插件市场很丰富，还可以自己编写插件，定制属于自己的功能。</li>
<li>Obsidian在支持双链的同时还保持了和传统笔记一样的文件夹层级，对于普通用户更加友好，大纲型笔记（如RoamResearch和logseq为代表）可能不太适合我（并不是说大纲型笔记不好）。</li>
</ul>
<p>当然，这只是当下的选择而已，以后可能还会随着时间变化，不必执着于工具，掌握了方法，使用<code>Apple Notes</code>一样可以把笔记整理的很好，笔记工具有很多，选择一个自己趁手的工具就好了，在不断的写作中不断迭代自己的方法即可。</p>
<h2 id="Obsidian-工作流"><a href="#Obsidian-工作流" class="headerlink" title="Obsidian 工作流"></a>Obsidian 工作流</h2><p>目前我的卡片笔记工作流，是基于Obsidian的<code>Daily Notes</code>，也称为Journal构建的。对我来说，记log最大的优点在于记录的时候不用思考这个笔记应该放在哪里，不要小瞧这个小问题，这一步很消耗脑力，大脑为了躲避思考，可能就会排斥做笔记，做笔记的难度就提升了。</p>
<p>Journal型笔记最大的优点就在于记录的时候压力很小，如果大脑中有一个idea，直接capture住这个idea加入到log中就行了，在这个过程中尽可能多的为这个idea添加元数据，比如标签或者双链，这就需要自己在建立笔记的时候尽量多使用标签或者双链，这样，我们在以后提取的时候就能够尽可能多的提取到有用的信息，让自己大脑可以方便的Switch Context，有了这些特征信息，大脑就能更快、更准确的把这些信息提取出来，让思考继续发生。有了这些idea，一些伟大的产品就可以诞生，可能是一个side project，甚至是一个company。</p>
<p>下面是我在Obsidian中记录笔记的workflow：<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20240104183635.png"></p>
<h3 id="捕获-Capture"><a href="#捕获-Capture" class="headerlink" title="捕获 Capture"></a>捕获 Capture</h3><p>捕获（Capture）是记录脑瓜子里一闪而过的一些想法，这里就分成了两类：</p>
<ul>
<li>一类是自己想到的，比如散步的时候，一闪而过的灵感。</li>
<li>一类是在阅读，这里的阅读很宽泛，包括读书、rss工具、公众号、社交媒体或者看视频和听博客时候自己想到的一些想法。<br>这里Journal其实充当了灵感笔记（Fleeting Note ）的作用。</li>
</ul>
<h4 id="捕获想法（灵感）"><a href="#捕获想法（灵感）" class="headerlink" title="捕获想法（灵感）"></a>捕获想法（灵感）</h4><p>Capture灵感和想法需要即时性，因为灵感不常有，是个非常稀缺的东西，一般出现在reflection中，比如正念的过程，或者刚睡醒的早上，或者运动的过程中。大部分时候就是一瞬间的事情，理论上可以用任何工具，手机上自带的Notes 或者Todolist都是可以的，这一步主要是帮助自己快速捕捉到大脑的想法，因为这些灵感稍纵即逝。</p>
<p>在移动端，我自己使用Obsidian的Quickadd插件，下拉就可以在Journal记录想法，手机上不适合大段的编辑文字，但是非常适合捕捉灵感。比如在地铁上，或者走路的时候，突然迸发的灵感，就可以用手机随时记录。</p>
<p>在电脑端，我会直接在Obsidian的Journal中直接记录。平时我的电脑的一个屏幕里是专门放置的Obsidian，<br>如果是简单的想法，我会直接在log中记录想法，然后打上标签，如果未来以后有什么计划，比如要写一个帖子或者blog等，会建立一个<strong>双向链接</strong>的Placeholder，然后打上标签，比如 <code>#tasks/write</code>等，这些标签会在一个主页里通过dataview和<a href="https://github.com/obsidian-tasks-group/obsidian-tasks">Tasks</a>插件进行搜索展示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">not done</span><br><span class="line">sort by due desc</span><br><span class="line">description includes tasks/write</span><br></pre></td></tr></table></figure>

<p>如果是要发一个X帖子这样的简单的Task，我就直接在Journal中新建一个bullet list 记录，然后随手打一个标签，然后使用Dataview汇总：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list L.text</span><br><span class="line">from &quot;Journal&quot;</span><br><span class="line">flatten file.lists as L</span><br><span class="line">where contains(L.tags, &quot;#backlog&quot;) and contains(L.tags, &quot;#twitter&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="捕获阅读信息"><a href="#捕获阅读信息" class="headerlink" title="捕获阅读信息"></a>捕获阅读信息</h4><p>更多时候，我们是在阅读的时候产生的灵感，我们被我们的好奇心和兴趣所牵引，去阅读、观看、收听一些我们感兴趣的内容，我常用的工具如下：</p>
<ul>
<li>阅读工具：<ul>
<li>微信读书，我使用自己写的Obsidian Weread Plugin同步读书笔记到Obsidian中。</li>
<li>NetNewsWire：Apple平台最佳的开源rss阅读器，订阅的优秀的blog和newsletter来收集信息。</li>
<li>Safari阅读列表：一些gitbook会收藏进safari的阅读列表中，在碎片时间进行阅读。</li>
</ul>
</li>
<li>社交媒体：<ul>
<li>X（Twitter）：关注海内外一些优秀的开发者分享的一些有趣的内容。</li>
<li>Telegram：关注了一些开发者的频道，会分享一些业界比较关注的资讯。</li>
<li>IT之家：已经使用十年了，基本上每天都会刷一会儿</li>
</ul>
</li>
<li>媒体工具：<ul>
<li>Bilibili：看一些自己感兴趣的视频，</li>
<li>小宇宙：在跑步或者地铁上的时候会听一些自己订阅的播客。</li>
</ul>
</li>
</ul>
<p>如果是读到的感兴趣的内容，就需要建立一个简单的卡片笔记，把援引的链接记录下来，然后把文章的内容和自己的想法下来，在这一步就是类似于制作卡片的过程，不需要过多的引用原文，要尽可能多的思考，然后用自己的话写出来，然后尽可能多的添加元数据信息，比如各种标签，以及关联上各种已经存在的链接，让这个卡片渐渐丰满起来，这个卡片是为了以后整理加工使用的，</p>
<p>这一步千万不要着急，一天能有个三四个卡片就够了，每个卡片代表了自己思考的过程。</p>
<h3 id="整理和提取"><a href="#整理和提取" class="headerlink" title="整理和提取"></a>整理和提取</h3><p>整理是把这些零散的信息，重新加工成自己需要的笔记，在<strong>捕获</strong>这一步，我们已经尽可能多的把信息保存下来了。<br>比如，各种个样的标签，我这里使用Obsidian的dataview插件和tasks插件，把需要进一步整理的任务列出来，仅此，检索这些需要进一步处理的任务变得简单。</p>
<p>此外，由于我们此前已经在文献笔记卡片上记录了足够多的信息，因此，就算过了几天，大脑也能快速切换到当前的上下文，快速进入记笔记的状态，不用担心提笔忘字。比如，我们要根据卡片内容，写一个twitter帖子，或者写一篇blog，我们可以根据现在卡片上的内容以及关联的各种信息和其他卡片，进一步整理加工，形成一个永久笔记（Permanent Notes）。</p>
<p>这一步可能比较耗时，比如一篇blog写上大半天都是有可能的。</p>
<h3 id="输出和回顾"><a href="#输出和回顾" class="headerlink" title="输出和回顾"></a>输出和回顾</h3><blockquote>
<p>你对某件事情越感兴趣，就会阅读得越多，思考得越多，进而收集的笔记越多，最终越有可能从中提出问题和想法。它可能正是你一开始就感兴趣的东西，但更有可能是你的兴趣已经发生了变化，这就是洞见的作用。 –《卡片笔记写作法》</p>
</blockquote>
<p>最终，我们写出了一个有价值的内容，可以存放到一个单独的文件夹保存，等待以后检索和提取，也可以分享到社交平台上接受检验，我们的目的不在于分享本身，而是公开学习的过程可以促使我们更好的思考和学习，而笔记只是学习的成果。当然笔记并不是要在文件夹中吃灰的，而是需要经常回顾的，在回顾的过程中，可能会产生新的灵感，每一次回顾，我们都可以获取新的收获。我一般使用Random的插件来随机访问自己写的笔记，然后反思之后产生新的想法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简述一下我一天的记录流程：</p>
<ul>
<li>每天早上起床洗漱完成之后，打开Journal，看下Dashboard，回顾一下先前的任务和没有做完的事情，然和写下这一天的主要目标🎯，比如完成某个任务，学习一个主题等。</li>
<li>看一会儿RSS和X，如果看到感兴趣的主题，会capture成为一个卡片，然后链接到Journal中，然后给卡片打上各种标签，如果当时有时间就思考，然后构建一个卡片，如果没有时间，那就打上标记TBD，等待后续进一步处理，Dashboard中会记录各种TBD的卡片的记录。</li>
<li>地铁上使用微信读书标记以及写想法，然后使用插件同步笔记到Obsidian中。</li>
<li>工作中遇到的一些问题，或者想法也会及时capture到journal中。</li>
<li>有自己的时间的时候开始整理自己的卡片，根据卡片整理成永久笔记。分享自己的研究学习成果到互联网。</li>
<li>删除没有用的draft note</li>
</ul>
<p>这个流程的核心是有一个地方可以存放自己的闪念笔记（Fleeting Notes，存放自己的灵感和草稿），然后将它们源源不断地转换为永久笔记，永久笔记就是自己学习的成果，可以将它们分享到网络上，或者存放在自己单独的文件夹中。在持续不断的[[公开学习]]中，我们不断将学到的东西转换为其他人能够看的懂的内容，这种[[费曼学习法]]可以极大的提高自己的学习效率，在一个小小的领域里面不断研究，进步是非常迅速的。</p>
<p>每个人都有自己的记录笔记的方式方法，每个人记录笔记的方法不一定适合他人，最多只能给启发。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li>《卡片笔记写作法：如何实现从阅读到写作》</li>
<li><a href="https://catcoding.me/p/obsidian-for-programmer/">我的 Obsidian 使用经验  程序员的喵</a></li>
</ul>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>obsidian</tag>
        <tag>卡片笔记</tag>
        <tag>工具效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft算法笔记</title>
    <url>/2024/02/22/raft-notes/</url>
    <content><![CDATA[<p>最近看了DDIA，对于分布式共识算法很感兴趣，可以说共识算法是分布式的基石，而 Raft 算法又是共识算法中最简单的一个，Raft算法是一个专门用于管理日志复制的共识算法。共识（consensus）是大家关心的某件事情（比如选举、分布式锁、全局ID、数据复制等等）达成一致的<strong>过程及其算法</strong>。</p>
<p>Raft算法诞生与2013年，论文名字叫作《In Search of an Understandable Consensus Algorithm》，寻找一个更加容易理解的共识算法，从名字就能看出来，作者对 Paxos 的绝望。</p>
<span id="more"></span>

<h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p>在分布式系统中，为了提升高可用，一般使用基于副本的容错模型：复制状态机，复制状态机使用多个成员组成集群，成员之间数据完全一致（也称为副本），它可以保证即使在小部分（≤ (N-1)&#x2F;2）节点故障的情况下，系统仍然能正常对外提供服务。</p>
<p>复制状态机一般和共识算法一起才能发挥作用，下面是一个典型的复制状态机架构。<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20240112161859.png" alt="image.png"></p>
<p>从图中我们可以清晰的看到：</p>
<ul>
<li>第一步：客户端发起数据写入请求。</li>
<li>第二步：<code>共识模块</code>负责将请求写入Log，以及将Log 复制到其他的Server。</li>
<li>第三步：将Log应用到状态机，由于每一个Server的Log中存储的命令序列是完全相同的，因此可以保证所有Server产生相同的结果。</li>
<li>第四步：状态机把结果返回给客户端。</li>
</ul>
<h2 id="Raft算法的核心"><a href="#Raft算法的核心" class="headerlink" title="Raft算法的核心"></a>Raft算法的核心</h2><p>Raft算法通过选举机制确保每个任期（Term）中只有一个领导者（Leader），这个Strong Leader 负责处理客户端的请求和日志的复制。这样可以保证系统的高效性和一致性，避免了多个领导者引起的冲突，从而实现共识。</p>
<p>只有Leader才能接受来自Client的日志请求，Leader收到日志请求之后将日志写入到磁盘（无须咨询其他Server），然后将日志复制到其他Follower，这个过程是单向的。使用Leader&#x2F;Follower模型可以大大简化日志复制的管理。</p>
<p>Raft算法的核心问题这三个核心问题是：</p>
<ul>
<li>Leader选举 （Leader Election）</li>
<li>日志复制（Log replication）</li>
<li>确定性（Safety）</li>
</ul>
<p>最后一项确定性其实是前两个问题的约束条件，Raft算法在同一时刻有如下保证：</p>
<ul>
<li><strong>Leader Append-Only</strong>：Leader日志单调递增，Leader永远不会覆盖或者删除自己日志里面的内容，永远只会新增内容</li>
<li><strong>Log Matching</strong>：日志匹配，如果两个server的日志包含了相同的Index和Term，那么在该index之前的所有条目都是相同的。</li>
<li><strong>Leader Completeness</strong>：Leader完整性，如果日志条目被提交到给定任期，那么该日志会被复制到更高任期的Leader上。</li>
<li><strong>State Machine Safety</strong>：状态机安全，如果Server已经确定给定Index出的日志条目已经应用到了状态机，那么其他Server一定不会知道该Index处应用不同的日志条目。</li>
</ul>
<h2 id="如何选出一个Leader？"><a href="#如何选出一个Leader？" class="headerlink" title="如何选出一个Leader？"></a>如何选出一个Leader？</h2><p>Raft节点总共有三种状态：</p>
<ul>
<li>Leader ：集群中只可能有一个Leader，Leader的作用是把Log复制到其他节点，周期性的向Follower发送心跳，维持统治。</li>
<li>Follower：跟随者，只能被动接受日志，Follower超时之后自动变为Candidate开始竞选Leader。</li>
<li>Candidate：竞选者，选举时间超时之后，Follower变为Candidate</li>
</ul>
<p>其中Leader和Follower是持久状态，Candidate是一个中间状态，在选举时间超时之后Follower自动变为Candidate开始竞选Leader。</p>
<p>Raft 算法中，节点之间采用 RPC 进行通信，下面两种 RPC 是 Raft 基础功能的必要实现：</p>
<ul>
<li><strong>RequestVote RPC</strong>：请求投票 RPC，候选人在选举期间发起，用于通知其他节点投票</li>
<li><strong>AppendEntries RPC</strong>：日志复制 RPC，由领导者发起，用于复制日志和提供心跳消息。</li>
</ul>
<p>另外Raft中还有另外一个比较重要的概念：term 任期，每个term都由选举产生，每个Term都是一个单调递增的编号，每一轮选举都是一个Term周期，在一个Term中只能产生一个Leader ，每个node都存储了当前term的编号。<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20240112164058.png" alt="image.png"></p>
<p>一个term一般包含两个阶段，选举阶段和统治阶段，当然如果没有选举成功，比如在集群扩容时产生的平票问题，则只有选举阶段。<br>在上面的图中，term1开始一次新选举，选举成功之后开始正常统治，term2和term1类似，term3则是选举失败，term4正常选举成功。term在Raft中起到了逻辑时钟的作用，它可以保障Raft在任意时刻只有一个Leader，特别是在集群成员变更的时候，比如上面的term3阶段，这个阶段没有Leader，集群不能对外界提供服务，由于各个节点设置的随机超时时间不一样，最先超时的Follower节点首先变为Candidate开始竞选Leader，竞选成功之后就是后面的term4阶段。</p>
<h3 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h3><p>Raft使用心跳机制来出发选举，Raft选举过程节点状态迁移图如下：<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20240112150121.png" alt="image.png"><br> 初始状态下所有节点都是Follower， 随机设定的选举时间超时之后，Follower变为Candidate，Candidate将自己的Term+1开始竞选Leader，向所有节点发送投票请求（RequestVote RPC），投票会有三种结果：</p>
<ul>
<li>选举成功：如果Candidate获得大部分选票（$N&#x2F;2+1$），那么将从Candidate升级为Leader</li>
<li>选举失败：有两种情况会导致选举失败，1. 选举过程中发现其他Leader的心跳； 2. 投票请求响应的Term大于当前节点的Term则选举时候不到</li>
<li>选举超时：投票请求知道固定时间内没有收到其他节点的响应，或者收到了响应的节点数量没有大于$N&#x2F;2+1$ ,那么选举就会超时，进入下一轮选举。</li>
</ul>
<p>Leader在发现其他Server有更高的任期编号，则自动退回到Follower。</p>
<p>这个选举流程还是挺简单的，但是我们仍然会有疑问，节点的投票条件是什么？其实就一条：<strong>具备完备的 committed log（被多数节点接受并且持久化的的日志） 数据即可</strong>，有两种情况：</p>
<ul>
<li>如果收到的请求投票消息的Term小于自己当前的Term，则拒绝投票。</li>
<li>如果收到的请求投票消息的Term大于自己当前的Term，则更新自己的Term为收到的Term，节点状态转变为Follower。</li>
<li>如果自己还没有投票或者已经投票给了当前的Candidate，且收到的请求投票消息的Last Log Index和Term都大于等于自己的Last Log Index和Term，则投赞成票。</li>
<li>如果收到的请求投票消息的Last Log Index和Term都小于自己的Last Log Index和Term，则拒绝投票。</li>
</ul>
<p>当出现多个Candidate同时宣布自己是Leader时，由于选举过程中存在随机化的因素，可能会出现选平票的情况。在这种情况下，Raft算法规定如果两个Candidate的Term相同，那么选举将以最先收到选票的Candidate为准。其它候选者在接收到更高Term的选票后会立即转变为Follower，参与下一轮的选举。这样可以确保最终只有一个领导者被选举出来。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://raft.github.io/raft.pdf">In Search of an Understandable Consensus Algorithm</a></li>
<li><a href="https://www.qiyacloud.cn/2021/10/2021-10-21/">云原生 etcd 系列 ｜ 最难 paxos 最易 raft </a></li>
</ol>
]]></content>
      <categories>
        <category>技术随笔</category>
      </categories>
      <tags>
        <tag>raft</tag>
        <tag>共识算法</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>RIME 输入法使用体验</title>
    <url>/2024/03/20/most-powerful-input-method-rime/</url>
    <content><![CDATA[<p>磨刀不误砍柴工，输入法是平时<strong>使用频率极高</strong>的工具类软件，因此值得花时间去让这个工具变得更加趁手，在 2022 年我学会了双拼输入法（如果你还在使用全拼，我强烈建议学一下双拼，可以参考我之前写的这篇博客：<a href="https://zhaohongxuan.github.io/2023/06/30/how-i-learn-shuang-pin/">也许你该试试双拼输入法 | Hank’s Blog</a></p>
<span id="more"></span>

<p>我一直用的是 macOS 系统自带的双拼输入法，今年年初看到很多 X 友都强烈推荐 RIME输入法，我决定使用这个开源的输入法，使用至今已经3个多月了，这篇文章就来总结一下我的使用体验。<br>这篇文章只是我的体验，不会详细介绍 RIME 输入法的详细功能，更详细的配置可以查官方文档，希望能对你使用输入法产生一些启发。<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/WX20240320-185930@2x.png" alt="image.png"></p>
<h2 id="为什么是RIME？"><a href="#为什么是RIME？" class="headerlink" title="为什么是RIME？"></a>为什么是RIME？</h2><ul>
<li>RIME是一个高度定制的输入法，意味着它非常的自由。</li>
<li>它是基于 yaml 配置的，没有GUI，因此需要你有一些程序基础和耐心才能配置。</li>
<li>强大的拓展系统，可以使用 lua 实现自定义功能。</li>
<li>体积小巧，无须联网，没有隐私问题。</li>
</ul>
<p>基于上面这些对于一个程序员来说完全不是问题，而且是优势，因此我选择使用它来作为我的输入法再好不过了。<br>当然，如果你对输入法没有感受到痛点，我建议还是使用成品输入法，现在关闭这篇文章还来得及，至少现在来说，支持双拼的<strong>微信输入法</strong>已经足够好用了（除去隐私问题）。</p>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>在Mac平台的一个比较受欢迎的实现是 Squirrel 输入法，中文又称鼠须管，别担心配置文件是在各个平台通用的，因此只需要维护一个自己的一套输入法配置就好了，所有平台都可以共享。</p>
<p>强烈建议不要从头开始写一份配置，目前网络上友有很多鼠须管配置文件，我使用的是<a href="https://github.com/Mintimate/oh-my-rime">mint-rime</a>，也成为oh-my-rime，你也可以基于其他的配置文件来二次配置。</p>
<p>薄荷拼音的基本配置可以参考这里：<a href="https://www.mintimate.cc/">oh-my-rime Input Method | Mint Pinyin</a>，讲的可以说是非常细致了。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>直接下载配置文件zip包，解压之后放置在 <code>~/Library/Rime</code> 中，然后在菜单栏点击菜单栏【ㄓ】-【重新部署】即可完成基础配。如果是使用全拼输入法的话这里就可以正常使用了。</p>
<p>这种方式适合大部分用户，方便快捷，后续可以使用云盘来同步配置文件。</p>
<h4 id="软链接安装"><a href="#软链接安装" class="headerlink" title="软链接安装"></a>软链接安装</h4><p>如果是Git用户，可以fork一份配置，然后git clone到本地的项目文件夹 ，进入仓库目录，将本地目录创建软链接到到 Rime 的配置目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s &quot;$(pwd)&quot; ~/Library/Rime</span><br></pre></td></tr></table></figure>

<p>⚠️ 使用这种方式的时候要注意，如果是public repo 的话<code>custom_phrase.txt</code> 中不要放置敏感的信息。</p>
<h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><p>安装完成之后一般就能使用了，但是如果要实现一些自定义的功能，需要修改配置，修改配置的方法有两种：</p>
<ul>
<li>直接修改原始配置：</li>
<li>Patch 配置，<br>我建议使用第二种方式，Patch 在不影响原始配置文件的情况下来实现自定义的功能，支持覆盖配置和新增配置，后续在更新作者配置的时候更加方便，如果使用Github的话，只需要写一个Github action就可以定时同步配置了</li>
</ul>
<p>下面来介绍一下我Patch的一些配置，你可以做一些参考。</p>
<h3 id="Patch-自己的输入方案"><a href="#Patch-自己的输入方案" class="headerlink" title="Patch 自己的输入方案"></a>Patch 自己的输入方案</h3><p>默认情况下，RIME使用的一般都是拼音输入法，我们可以根据自己的需求修改自己的方案，在 <code>default.yaml</code> 可以配置自己需要的输入方案<br>我自己是双拼用户，所以，在schema list中只保留了小鹤双拼</p>
<p>我这里根据自己的需要，只保留了<code>小鹤双拼</code>的方案，设置方法很简单，新增一个 <code>default.custom.yaml</code> 中把其他的schema都删除掉，只保留double_pinyin_flypy，然后设置候选字一页为 9 个：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">schema_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">schema:</span> <span class="string">double_pinyin_flypy</span>    <span class="comment"># 小鹤双拼</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">page_size:</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>你可以根据自己的需求保留相应的方案，使用的时候使用 <code>ctrl + ~</code> 切换方案。</p>
<h3 id="Patch-自定义皮肤"><a href="#Patch-自定义皮肤" class="headerlink" title="Patch 自定义皮肤"></a>Patch 自定义皮肤</h3><p>首先要理解如何自定义皮肤，下面是鼠须管输入法皮肤每个配置项，你可以自己根据自己的喜好来定制自己的专属皮肤。<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/20240122182514.png" alt="image.png"><br>也可以使用 Squirrel 皮肤设计软件<a href="https://github.com/LEOYoon-Tsaw/Squirrel-Designer">GitHub - LEOYoon-Tsaw&#x2F;Squirrel-Designer: Squirrel Theme Simulator</a>来设计皮肤，目前我使用的皮肤就是这个皮肤设计软件自带的 flat 主题，我感觉非常漂亮。<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20240317165220.png" alt="image.png">
　</p>
<p>新增一个 <code>squirrel.custom.yaml</code> 配置文件用来覆盖默认的主题配置，分别patch 掉 style和preset_color_schemes字段。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">style:</span></span><br><span class="line">    <span class="comment"># 选择皮肤，亮色与暗色主题</span></span><br><span class="line">    <span class="attr">color_scheme:</span> <span class="string">flat_light</span></span><br><span class="line">    <span class="attr">color_scheme_dark:</span> <span class="string">purity_of_form_custom</span></span><br><span class="line">  <span class="attr">preset_color_schemes:</span></span><br><span class="line">    <span class="attr">flat_light:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;&#x27;flat_light&#x27;&quot;</span></span><br><span class="line">        <span class="attr">font_face:</span> <span class="string">&quot;Helvetica&quot;</span></span><br><span class="line">        <span class="attr">font_point:</span> <span class="number">15.0</span></span><br><span class="line">        <span class="attr">candidate_list_layout:</span> <span class="string">linear</span></span><br><span class="line">        <span class="attr">text_orientation:</span> <span class="string">horizontal</span></span><br><span class="line">        <span class="attr">inline_preedit:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">translucency:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">mutual_exclusive:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">corner_radius:</span> <span class="number">15.0</span></span><br><span class="line">        <span class="attr">hilited_corner_radius:</span> <span class="number">13.0</span></span><br><span class="line">        <span class="attr">border_height:</span> <span class="number">-5.0</span></span><br><span class="line">        <span class="attr">border_width:</span> <span class="number">-5.0</span></span><br><span class="line">        <span class="attr">line_spacing:</span> <span class="number">4.0</span></span><br><span class="line">        <span class="attr">spacing:</span> <span class="number">10.0</span></span><br><span class="line">        <span class="attr">alpha:</span> <span class="number">60.0</span></span><br><span class="line">        <span class="attr">shadow_size:</span> <span class="number">1.0</span></span><br><span class="line">        <span class="attr">color_space:</span> <span class="string">display_p3</span></span><br><span class="line">        <span class="attr">back_color:</span> <span class="number">0x1AFFFFFF</span></span><br><span class="line">        <span class="attr">candidate_text_color:</span> <span class="number">0xB3000000</span></span><br><span class="line">        <span class="attr">comment_text_color:</span> <span class="number">0x80333333</span></span><br><span class="line">        <span class="attr">label_color:</span> <span class="number">0xBB333333</span></span><br><span class="line">        <span class="attr">hilited_candidate_back_color:</span> <span class="number">0x7DC6C6C6</span></span><br><span class="line">        <span class="attr">hilited_candidate_text_color:</span> <span class="number">0x000000</span></span><br><span class="line">        <span class="attr">hilited_comment_text_color:</span> <span class="number">0xBF333333</span></span><br><span class="line">        <span class="attr">hilited_candidate_label_color:</span> <span class="number">0x000000</span></span><br><span class="line">        <span class="attr">preedit_back_color:</span> <span class="number">0x1A000000</span></span><br><span class="line">        <span class="attr">text_color:</span> <span class="number">0xBF323232</span></span><br><span class="line">        <span class="attr">hilited_text_color:</span> <span class="number">0xBF1A1A1A</span></span><br></pre></td></tr></table></figure>


<p>然后重新部署就可以生效了。</p>
<h3 id="Patch-双拼-preedit-format"><a href="#Patch-双拼-preedit-format" class="headerlink" title="Patch 双拼 preedit_format"></a>Patch 双拼 preedit_format</h3><p>默认情况下，输入双拼音节，comment框中会自动转换为全拼，但是按回车之后上屏的依然还是双拼，我感觉还是不习惯，可以把这个配置改掉，我在Github上找到了解决的方案：<a href="https://github.com/rime/squirrel/issues/261">双拼模式下怎么能不让输入框的拼音自动展开成全拼？ · Issue #261 · rime&#x2F;squirrel · GitHub</a></p>
<p>在 <code>double_pinyin_flypy.schema.yaml</code> 文件里，找到 translator配置项，把 preedit_format 设置为 <code>[]</code>，这样双拼就不会自动展开成全拼了。 </p>
<p>最终结果如下：<br><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20240317180116.png" alt="image.png"></p>
<h3 id="macOS更新托盘图标"><a href="#macOS更新托盘图标" class="headerlink" title="macOS更新托盘图标"></a>macOS更新托盘图标</h3><p><a href="https://github.com/lewangdev/rime-ice/releases/tag/0.0.1-squirrel-system-tray-icon">Release Squirrel System Tray Icon for MacOS Ventura&#x2F;Sonoma  · lewangdev&#x2F;rime-ice · GitHub</a><br>默认的托盘图标很窄，可以参考这个连接：修改为系统输入法一样的宽图标，强迫症狂喜。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20240317180314.png" alt="image.png"></p>
<h2 id="配置同步"><a href="#配置同步" class="headerlink" title="配置同步"></a>配置同步</h2><p>如果在一个设备上修改了配置，如何在其他的设备上还能够正常同步？</p>
<h3 id="同步至-iCloud"><a href="#同步至-iCloud" class="headerlink" title="同步至 iCloud"></a>同步至 iCloud</h3><p>1、配置文件里打开 <code>installation.yaml</code>，将 <code>id</code> 改为自己设备的名称，比如家里的Macbook Pro之类的。<br>2、复制下面路径代码粘贴进去，将 <code>admin</code> 替换为 Mac 管理员名称（代码里 <code>RimeSync</code> 是同步后文件夹名称，支持自定义）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sync_dir: &quot;/Users/admin/Library/Mobile Documents/com~apple~CloudDocs/RimeSync&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/20240317171250.png" alt="image.png"></p>
<p>更多同步的选项可以看文档：<a href="https://www.mintimate.cc/zh/guide/deviceSync.html">多设备同步 | oh-my-rime输入法</a></p>
<h3 id="Git-同步"><a href="#Git-同步" class="headerlink" title="Git 同步"></a>Git 同步</h3><p>上面的「软链接安装」章节已经提到了，如果使用Git管理的话，最好通过软链接的方式安装，就和正常管理一个项目一样简单。</p>
<h2 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h2><p>iPhone上面可以使用【仓输入法】<a href="https://github.com/imfuxiao/Hamster">GitHub - imfuxiao&#x2F;Hamster: librime for iOS App</a>，配置文件和电脑端的位置文件一样，只需要把配置文件复制一份到iCloud的仓输入法文件夹就可以了，然后部署就可以了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/Mintimate/oh-my-rime">GitHub - Mintimate&#x2F;oh-my-rime: The Simple Config Template Of Rime By Mintimate. QQ Chat-Group: 703260572</a></li>
<li><a href="https://dvel.me/posts/rime-ice/">Rime 配置：雾凇拼音 - Dvel’s Blog</a></li>
<li><a href="https://github.com/ssnhd/rime?tab=readme-ov-file">GitHub - ssnhd&#x2F;rime: Rime Squirrel 鼠须管配置文件（朙月拼音、小鹤双拼、自然码双拼）</a></li>
<li><a href="https://github.com/iDvel/rime-ice">GitHub - iDvel&#x2F;rime-ice: Rime 配置：雾凇拼音 | 长期维护的简体词库</a></li>
<li><a href="https://github.com/imfuxiao/Hamster">GitHub - imfuxiao&#x2F;Hamster: librime for iOS App</a></li>
</ul>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>双拼输入法</tag>
        <tag>Rime</tag>
        <tag>鼠须管</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Obsidian Dataview搭建微信读书阅读主页</title>
    <url>/2024/05/31/obsidian-weread-card-overview/</url>
    <content><![CDATA[<p>之前在Weread的Wiki中介绍过使用Dataview和Minimal主题管理微信读书的方法：<a href="https://github.com/zhaohongxuan/obsidian-weread-plugin/wiki/%E4%BD%BF%E7%94%A8Dataview%E8%BF%9B%E8%A1%8C%E4%B9%A6%E7%B1%8D%E7%AE%A1%E7%90%86">使用Dataview进行书籍管理</a> ，随着Weread插件的不断迭代，现在增加了不少元数据，比如，开始阅读日期:readingDate，完成阅读日期：finishedDate ，阅读进度：progress等，且不需要手动添加readYear属性了，有了这些新的数据就可以更好的汇总读书数据了。</p>
<p>使用效果如图：<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/202405311721932.png" alt="Weread Card"></p>
<span id="more"></span>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>下载 <a href="https://obsidian.md/">Obsidian - Sharpen your thinking</a>，并安装好软件</li>
<li>安装Obsidian Weread 插件，本人开发的一款Obsidian插件，用于同步所有的微信读书数据，有了数据才能做汇总页，可以在Obsidian官方市场下载或者Github Release页面下载手动安装：<a href="https://github.com/zhaohongxuan/obsidian-weread-plugin">GitHub - zhaohongxuan&#x2F;obsidian-weread-plugin</a></li>
<li>安装Obsidian Dataview插件，官方市场下载</li>
<li>Minimal主题或者自定义Card View 的css， 如果使用Minimal主题的话就不需要自定义css了，</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="同步微信读书数据"><a href="#同步微信读书数据" class="headerlink" title="同步微信读书数据"></a>同步微信读书数据</h3><p>通过本人开发的 Obsidian Weread 插件，将自己微信读书的数据同步到Obsidian中，有了数据才能做汇总页，更多使用说明，可以参考微信读书Obsidian插件主页：<a href="https://github.com/zhaohongxuan/obsidian-weread-plugin">GitHub - zhaohongxuan&#x2F;obsidian-weread-plugin: Obsidian Weread Plugin is a plugin to sync Weread(微信读书) hightlights and annotations into your Obsidian Vault.</a></p>
<p>这里需要记录下自己的微信读书笔记的文件夹，比如我自己的是<code>Reading/Weread</code></p>
<h3 id="主题准备"><a href="#主题准备" class="headerlink" title="主题准备"></a>主题准备</h3><h4 id="选项一："><a href="#选项一：" class="headerlink" title="选项一："></a>选项一：</h4><p>安装minimal 主题，直接在官方主题市场搜索下载</p>
<h4 id="选项二："><a href="#选项二：" class="headerlink" title="选项二："></a>选项二：</h4><p>由于Card View的效果提取自minimal主题，因此，如果不适用minimal主题的话就需要手动安装Card View的css样式表。下载<a href="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/Cards.css">Cards.css</a> 放置到自定义css文件夹中、然后启用该css。</p>
<p>具体操作如下：<br><img src="https://raw.githubusercontent.com/zhaohongxuan/picgo/master/202405311705960.png"></p>
<h3 id="创建Card页面"><a href="#创建Card页面" class="headerlink" title="创建Card页面"></a>创建Card页面</h3><p>创建一个空白页面，以源码的方式编辑文档，在文件的顶部，粘贴以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">cssclasses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cards</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cards-cols-5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">iframe-wide</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cards-cover</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cards-align-bottom</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>这段代码是和css搭配的，顶部有这些属性的文档才会应用Card View 样式，不会影响到其他的文档。</p>
<h3 id="使用Dataview筛选数据"><a href="#使用Dataview筛选数据" class="headerlink" title="使用Dataview筛选数据"></a>使用Dataview筛选数据</h3><p>使用Dataview可以很方便的筛选、汇总数据，这里主要使用微信读书笔记的<code>元数据</code>进行筛选和汇总，这些字段默认都会在文档顶部的frontmatter中存在。</p>
<p>我这里主要使用的属性如下：</p>
<ul>
<li>cover 书籍的封面</li>
<li>file.link 表示的是双链地址</li>
<li>readingTime 阅读时长</li>
<li>readingStatus 阅读状态，总共有四个状态，空、在读、读过、读完。</li>
<li>author 作者</li>
<li>readingDate 开始阅读的时间</li>
<li>finishedDate 开始阅读的时间</li>
<li>lastReadDate 最近一次阅读时间</li>
</ul>
<p>我的微信读书汇总页面，总共分成三个部分，2024在读清单、2024完成清单、历史完成清单，把当前年份领出来就是为了方便自己查看当年的数据。</p>
<h3 id="2024年在读清单"><a href="#2024年在读清单" class="headerlink" title="2024年在读清单"></a>2024年在读清单</h3><p>这里包括了，我2024年阅读的书籍，过滤条件为：</p>
<ul>
<li>微信读书文件夹，我这里是 <code>Reading/weread</code></li>
<li>cover不为空的</li>
<li>readingStatus 是<code>在读</code>的</li>
<li>lastReadDate.year 是 <code>2024</code>年的<br>最后一个条件表示的是，如果一本书在今年以前没读完，今年又重新读了，会被归结到今年在读清单里。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">table without <span class="title function_">id</span> (<span class="string">&quot;![](&quot;</span> + cover + <span class="string">&quot;)&quot;</span>) <span class="keyword">as</span> cover ,file.<span class="property">link</span> <span class="keyword">as</span> <span class="title class_">Title</span>, readingTime, readingStatus, author <span class="keyword">as</span> <span class="title class_">Author</span>, <span class="title function_">dateformat</span>(readingDate,<span class="string">&quot;yyyy-MM-dd&quot;</span>) </span><br><span class="line"><span class="keyword">from</span> <span class="string">&quot;Reading/weread&quot;</span>  where cover != <span class="literal">null</span> and readingStatus = <span class="string">&quot;在读&quot;</span> and lastReadDate.<span class="property">year</span> = <span class="number">2024</span></span><br></pre></td></tr></table></figure>

<h3 id="2024年已读清单"><a href="#2024年已读清单" class="headerlink" title="2024年已读清单"></a>2024年已读清单</h3><p>这个脚本抓取的是2024年已经阅读完成的书籍，上在读不一样的地方：</p>
<ul>
<li>readingStatus 是<code>读完</code>的，这个依赖于你自己在微信读书上面的标记，一般来说，我们每读一本书都会标记成读完。</li>
<li>finishedDate.year &#x3D; 2024</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">table without <span class="title function_">id</span> (<span class="string">&quot;![](&quot;</span> + cover + <span class="string">&quot;)&quot;</span>) <span class="keyword">as</span> cover,  file.<span class="property">link</span> <span class="keyword">as</span> <span class="title class_">Title</span>, author <span class="keyword">as</span> <span class="title class_">Author</span>, <span class="string">&quot;笔记：&quot;</span> + noteCount <span class="keyword">as</span> <span class="title class_">NoteCount</span>, <span class="title function_">dateformat</span>(finishedDate,<span class="string">&quot;yyyy-MM-dd&quot;</span>) , readingTime</span><br><span class="line"><span class="keyword">from</span> <span class="string">&quot;Reading/weread&quot;</span>  where cover != <span class="literal">null</span> and readingStatus = <span class="string">&quot;读完&quot;</span>  and finishedDate.<span class="property">year</span> = <span class="number">2024</span> </span><br><span class="line"><span class="variable constant_">SORT</span> finishedDate <span class="variable constant_">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="历史已读"><a href="#历史已读" class="headerlink" title="历史已读"></a>历史已读</h3><p>就是上面的脚本，把上面的&#x3D;换成&lt;，就是历史所有的已读书籍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">table without <span class="title function_">id</span> (<span class="string">&quot;![](&quot;</span> + cover + <span class="string">&quot;)&quot;</span>) <span class="keyword">as</span> <span class="title class_">Cover</span> ,file.<span class="property">link</span> <span class="keyword">as</span> <span class="title class_">Title</span>, author <span class="keyword">as</span> <span class="title class_">Author</span>, <span class="string">&quot;笔记：&quot;</span> + noteCount <span class="keyword">as</span> <span class="title class_">NoteCount</span>, <span class="title function_">dateformat</span>(finishedDate,<span class="string">&quot;yyyy-MM-dd&quot;</span>) <span class="keyword">as</span> <span class="title class_">FinishedDate</span> </span><br><span class="line"><span class="keyword">from</span> <span class="string">&quot;Reading/weread&quot;</span>  where cover != <span class="literal">null</span> and readingStatus = <span class="string">&quot;读完&quot;</span>  and finishedDate.<span class="property">year</span> &lt; <span class="number">2024</span></span><br><span class="line">sort finishedDate <span class="variable constant_">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Obsdian的玩法很多，你可以根据自己的实际需求来进行更改，添加自己需要展示的字段，删除不需要展示的字段，而且不使用自定义css和minimal主题也可以完成，比如使用Project插件和Component插件，可以参考：<a href="https://www.bilibili.com/video/BV1AF4m1T79g/?spm_id_from=333.337.search-card.all.click&vd_source=6c9d35b151f6826cf41b939376b81ead">Obsidian使用Components快速搭建可视化图书库_哔哩哔哩_bilibili</a>和 <a href="https://github.com/zhaohongxuan/obsidian-weread-plugin/discussions/130">和 Projects 插件结合的场景 · zhaohongxuan&#x2F;obsidian-weread-plugin · Discussion #130 · GitHub</a></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://obsidian.md/">Obsidian - Sharpen your thinking</a></li>
<li><a href="https://github.com/zhaohongxuan/obsidian-weread-plugin">GitHub - zhaohongxuan&#x2F;obsidian-weread-plugin: Obsidian Weread Plugin is a plugin to sync Weread(微信读书) hightlights and annotations into your Obsidian Vault.</a></li>
<li><a href="https://forum.obsidian.md/t/snippet-so-you-can-use-dataview-cards-from-minimal-theme-in-any-theme/56866/12">Snippet so you can use Dataview Cards from Minimal theme in any theme - Share &amp; showcase - Obsidian Forum</a></li>
</ul>
]]></content>
      <categories>
        <category>工具效率</category>
      </categories>
      <tags>
        <tag>obsidian</tag>
        <tag>微信读书</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala中 implicit 用法</title>
    <url>/2024/05/31/scala-implict/</url>
    <content><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>最近一段时间接手了几个Spark相关的大数据项目，主要使用Scala来编写代码，做了几个需求，感觉Scala这门语言还挺有意思，Scala以前也学习过，但是是很早了，很多语法点都忘了，在工作中经常编写的代码是Spark Job，使用stream的方式来编写代码，感觉非常的舒服。Spark中经常使用的一个操作是使用<code>$</code>来选择Column，比如下面使用<code>$</code>选择<code>dt</code>这一列，</p>
<span id="more"></span>


<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> omnitracking_ios = spark.read.parquet(file_path).filter($<span class="string">&quot;dt&quot;</span> &gt;= one_month_ago_fmt)</span><br></pre></td></tr></table></figure>
<p>起初我并没有在意，起初我还以为<code>$</code>的用法是字符串插值，但是后来发现不是的，这一下子激发了我的好奇心，于是花时间研究了一下，Spark 中的<code>$</code>是 <code>import spark.implicits._</code> 导入的：</p>
<p>SQLImplicits中的 StringToColumn类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToColumn</span>(<span class="params">val sc: <span class="type">StringContext</span></span>) </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">$</span></span>(args: <span class="type">Any</span>*): <span class="type">ColumnName</span> = &#123;  </span><br><span class="line">    <span class="keyword">new</span> <span class="type">ColumnName</span>(sc.s(args: _*))  </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下源码，虽然源码只有三行，但是知识点还是比较密集的：</p>
<p>首先，第一行，StringToColumn是一个隐式类，定义了一个隐式类<code>StringToColumn</code>，它接受一个<code>StringContext</code>类型的参数<code>sc</code>。<code>StringContext</code>是Scala中的一个类，用于处理字符串插值(interpolator)（例如，<code>s&quot;hello $name&quot;</code>）。</p>
<p>第二行在隐式类中定义了一个<code>$</code>方法， <code>$(args: Any*): ColumnName</code>，该方法返回一个<code>ColumnName</code>对象。</p>
<p>第三行：<code>new ColumnName(sc.s(args: _*))</code>：使用生成的字符串创建一个新的<code>ColumnName</code>对象。关键点在<code>sc.s(args: _*)</code>方法 ，使用<code>StringContext</code>类中的<code>s</code>方法将<code>args</code>参数插入到<code>StringContext</code>中的字符串模板中。<code>args: _*</code>表示将参数序列展开成单独的参数。</p>
<p>我们知道Scala中的字符串插值使用方法是：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> path = <span class="string">s&quot;<span class="subst">$&#123;base_path&#125;</span>/dt=<span class="subst">$&#123;last_date_fmt&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里，我们就可以以字符串插值的方式来使用<code>$</code>了</p>
<p>比如从Dataframe中选择一个Column</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> columnName = $<span class="string">&quot;columnName&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里隐式类的作用是在特定的作用域中自动将某种类型转换为隐式类的实例，从而可以调用隐式类中的方法。在这个例子中，当你在字符串上下文中使用<code>$</code>插值时，Scala会自动将<code>StringContext</code>转换为<code>StringToColumn</code>，从而可以调用<code>$</code>方法。</p>
<p>通过隐式类和字符串插值机制，Spark SQL允许用户方便地将字符串转换为<code>ColumnName</code>对象，从而进一步转换为<code>Column</code>对象。这使得代码在处理列名时更加直观和简洁。具体代码如下</p>
<h2 id="Scala中-implicit-用法"><a href="#Scala中-implicit-用法" class="headerlink" title="Scala中 implicit 用法"></a>Scala中 implicit 用法</h2><p>Scala中的<code>implicit</code>关键字用于定义隐式转换和隐式参数，可以简化代码和提高可读性。</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>隐式转换用于在需要某种类型但实际提供的类型不匹配时，自动将一种类型转换为另一种类型。可以通过定义隐式函数或隐式类来实现。</p>
<h4 id="隐式函数示例："><a href="#隐式函数示例：" class="headerlink" title="隐式函数示例："></a>隐式函数示例：</h4><p>自动调用 intToString，将 Int 转换为 String</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToString</span></span>(x: <span class="type">Int</span>): <span class="type">String</span> = x.toString</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s: <span class="type">String</span> = <span class="number">42</span>  </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>intToString</code>函数将<code>Int</code>类型转换为<code>String</code>类型。因为<code>implicit</code>关键字的存在，当需要<code>String</code>类型但提供的是<code>Int</code>类型时，编译器会自动应用这个隐式函数。</p>
<h4 id="隐式类示例："><a href="#隐式类示例：" class="headerlink" title="隐式类示例："></a>隐式类示例：</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">RichInt</span>(<span class="params">val x: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">square</span></span>: <span class="type">Int</span> = x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> num = <span class="number">4</span></span><br><span class="line">println(num.square)  <span class="comment">// 输出 16</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>RichInt</code>是一个隐式类，它为<code>Int</code>类型增加了<code>square</code>方法。这样，我们可以直接调用<code>num.square</code>，即使<code>Int</code>类型本身没有<code>square</code>方法。</p>
<h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><p>隐式参数是一种可以自动传递给函数或方法的参数。如果一个方法的最后一个参数列表被标记为<code>implicit</code>，那么在调用这个方法时，如果没有提供这些参数，Scala编译器会在作用域内寻找合适的隐式值来填充。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>(<span class="keyword">implicit</span> user: <span class="type">User</span>): <span class="type">String</span> = <span class="string">s&quot;Hello, <span class="subst">$&#123;user.name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> defaultUser: <span class="type">User</span> = <span class="type">User</span>(<span class="string">&quot;John Doe&quot;</span>)</span><br><span class="line"></span><br><span class="line">println(greet)  <span class="comment">// 输出 &quot;Hello, John Doe!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>greet</code>方法需要一个<code>User</code>类型的隐式参数。因为在作用域内定义了一个隐式值<code>defaultUser</code>，所以调用<code>greet</code>时不需要显式地传递参数。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><strong>增强现有类型</strong>：通过隐式类，可以为现有类型添加新的方法，而不需要修改类型本身。</li>
<li><strong>类型转换</strong>：隐式函数可以在需要某种类型但提供的类型不匹配时，自动进行类型转换。</li>
<li><strong>依赖注入</strong>：隐式参数可以用于依赖注入，使得代码更加简洁和易于测试。</li>
<li><strong>类型类模式</strong>：在Scala中，类型类通过隐式参数和隐式转换实现，提供了一种灵活的多态性。</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://wwwscala-lang.org/files/archive/spec/2.11/07-implicits.html">Implicits</a></li>
<li><a href="https://stackoverflow.com/questions/10375633/understanding-implicit-in-scala">syntax - Understanding implicit in Scala - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>记录人生第一次裁员</title>
    <url>/2024/10/10/layoff-first-time/</url>
    <content><![CDATA[<p>新公司入职有一段时间了，感觉是时候记录一下裁员的这段经历了，「裁员」在这个行业里应该是每个人都必须经历的事情，现在回想起来那一个多月真的是比较煎熬和恐惧。</p>
<p>2024年7月19日，体验了人生中的第一次裁员，现在所做的公司是一个跨境电商Farfetch，疫情结束后业绩加速衰落，3月份刚经历一波裁员，我的几个同事都被裁掉了，6月份又来了一波裁员，谁也没想到来的会这么快，只不过这一次这个天猫的业务都要关门了，当然我们team和隔壁team的全都被裁员了，其实这已经不是第一次裁员了，从2022年年中的时候就已经有第一波裁员了，首先裁员的是外包同学，然后是我们team的其中一位同学。2023年年中的时候又经历了一波裁员，到这一次已经是第4次裁员了。</p>
<p>我对裁员其实没有特别大的抵触，公司还算厚道，毕竟裁员补偿N+3还算厚道，还按照年工资进行折算，补偿非常丰厚，部门领导也很nice，忙着给我们推荐各种各样的工作机会。虽然是业务调整，虽然原因不在自己，但是依然是有很强的挫败感，受到了莫大的打击。</p>
<p>很多被裁同事都说要出去玩，放松一下，但是对我来说，我无法忽视失业这件事情，外出旅游在我看来是一个逃避，必须要直视问题，解决问题才能解开心中的疙瘩，于是基本上每天都是面试，复习，刷Leetcode算法题，总结面试经验等等，焦虑和紧张一直伴随着我，白天基本上就是上午下午两场，基本上每天都有面试。招聘市场确实不是很好，很多公司一个岗位可能有大量的竞争，经常面试到2、3轮之后挂掉的，还有面试过了不发Offer的，确实都让人很糟心</p>
<p>整个夏天最热的时候，基本上很少出门，都呆在家里，跑步也不多，可能是心情的原因，找工作的这段时间我的体重减少了至少 10 斤，食欲一直不怎么好。</p>
<p>一直在家里待着找工作实在是考验心态，面试的过程中，大部分的公司都是很 nice 的，但是也有一些很傻X的公司。心情就像过山车一样，随着每天的各种面试和反馈一起波动，一天面2到3场，一天就过去了，当然在我看来这一段时间也是很宝贵的人生体验，再过若干年以后这一段经历也是，不过，随着时间的增加和面试经验的增加，明显感觉情况开始逐渐变好了，之前一些公司1、2面就挂，慢慢的可以进到3、4轮以及最终轮了，于是offer变成顺理成章的事情了。</p>
<p>我的工作机会主要是朋友推荐，有前公司 Leader 帮忙介绍的工作机会，还有一些猎头推荐的外企机会，还有yihong大哥给推荐的几个外企，最后就是 Boss直聘了，领英上投递的公司普遍反应很慢，有的公司我都入职很久了才打电话过来说要面试。</p>
<p>现在的就业市场确实很残酷，不仅有大批量的毕业生涌入，还有很多被裁员的也在市场上竞争，工作没有前几年那么好找了，但是机会依然还有不少，但是对于个人的能力的要求也越来越高，不仅仅是算法，还有更多的场景设计题，公司大多都会更加全面的考察一个人的综合能力，额外的开源项目会让自己多收获一些面试机会，同事面试官也会加分不少，但是主要还是得自己的实力足够硬，在面试的过程中，最有效的方法，还是不停的面试，然后总结、改进，继续面试，螺旋上升，没有其他的捷径。</p>
<p>我也不知道过了这么久才想起写这么一篇关于裁员的blog，回过头来出那一段时间过得确实很焦虑，现在联系之前的同事，还有一些年龄大的同事还没找到合适的工作，这个行业可能比我想象的要更加残酷一些，未来不可避免的肯定还会遇到裁员，但是有了这一段经历感觉也没有那么害怕了，都是宝贵的人生经验。</p>
<p>从现在开始要逐步积累自己的势能，在公司做事情的时候，一定要多考虑对自身的提升，哪些可以作为杠杆为自己的未来加分，对公司来说可能我们只是一个「螺丝钉」，但是对于你自己来说，你就是第一负「责任人」，我们永远可以在「当下」做一些事情来改变「未来」的处境。</p>
]]></content>
      <categories>
        <category>散文随笔</category>
      </categories>
      <tags>
        <tag>裁员</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>2024：拥抱不确定</title>
    <url>/2025/02/19/2024-review/</url>
    <content><![CDATA[<p>不知不觉马上就过 2025农历蛇年了，这篇年终总结也从 2024 年 12 月份开始要写的年终总结也一直拖到了现在（1 月 13 号），又拖到了今天发布，一直都在以各种借口拖延，加班很多，工作很「忙」，但是对我来说，「忙」也要抽出时间来做一个简短的总结来回顾一下这一年，人生总要在一定的时间停下来，思考复盘一下，一直忙忙忙，其实是盲盲盲，被事情遮蔽了眼睛会离自己的目标越来越远。</p>
<h2 id="失业"><a href="#失业" class="headerlink" title="失业"></a>失业</h2><p>2024 最大的变化应该就是经历了失业，2024 年好像没经历过失业就不好意思似的。</p>
<p>前司是一个外企，主要做的是奢侈品电商的生意，2024 年业绩加速下滑，卖身 coupon 之后先后在 3 月份和 6 月份连续裁员了两波，我在6 月份的裁员名单上。<br>虽然不舍，但是没有办法，业务线关停不是个人能够阻拦的，裁员时 Manager 也在不断的给我们推荐其他的面试机会。</p>
<p>整个 7 月份和 8 月份基本上都是在面试中度过的，能感受到今年的就业形势确实不好，很多公司其实没有真的在招人，或者说是在，基本上每天一场到 2 场面试，心情也是起起伏伏，好几个面试都是到了最后谈薪资挂的，还有好几次是 3～4 面挂的，确实有些焦虑，经历了一个多月的GAP时间入职了携程商旅。</p>
<h2 id="新机"><a href="#新机" class="headerlink" title="新机"></a>新机</h2><p>商旅主要是做Saas  toB生意的，国内的 Saas 市场确实非常畸形，基本上都是在完成甲方爸爸的各种需求，哪个甲方爸爸更大更有钱就更听谁的。</p>
<p>从 9 月份入职以来，刚好跟上开始加班赶进度，开始每周六都上上班，每天基本上都要 9 点～10 点下班，周六也要加班，一直到元旦才结束，彻底体验了一把 996，我前司的 Leader 也跟我一起进入了携程，他干了不到 3 个月在转正前走了，一直呆在国企的人是没有办法适应互联网这种工作环境，而我选择继续坚守，因为之前落户到一半，被裁员了，首先要现稳住把上海落户这件事情先办好。</p>
<p>在前司，我是团队中年龄最小的，基本上有问题也还可以请教老同事什么的，在新公司，我们的团队中有不少外包员工，正式员工年龄都比较小好几个都是校招生，我是团队中正式员工中年龄最大的，基本上很多事情都会问我，承担了更多的责任。</p>
<p>适应新的公司确实需要时间，在目前的阶段，需求如雪花一般飘来，代码经过测试测过就上线了，代码中没有UT，也没有 review，有专门的 review 评审会，但是时间很短，基本上看不出来什么问题，特别是一个 MR 中有几十个文件变更这种。代码质量完全不能保障，线上经常出现这样那样的问题，不是在救火就是在救火的路上，确实压力比较大。</p>
<p>绩效在互联网公司是第一重要的事情，所以底层员工之间格外的卷，基本上每个人都是为了晋升和绩效拼了命的工作，特别是为了晋升，基本上晋升一次就像脱了一层皮一样，互联网公司就是这么神奇的地方，只要加入了就会自动开始卷起来。在本来就不太乐观的大环境下，外企加速撤离让互联网企业更加肆无忌惮，携程还算互联网公司里面比较好的，但是下面的各个 BU 又是另外一番景象了，比如居家办公，在大部分 BU 里已经名存实亡了。</p>
<h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><h3 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h3><p>8月份的时候跑步里程达到了10000公里了，以前觉得一万公里是一个很难达到的数字，跑步10年也达到了这个数字，算是一个里程碑吧，毕竟人生也不过才三万多天。</p>
<p>对我来说，健康是第一重要的事情，健康是 1，其他的都是 0，因此我还是在践行跑步来保持身体健康，我最少会安排一周两次的跑步，不管再忙，不同的是今年没有参加一场马拉松，对马拉松不再狂热了，跑步已经完全融入生活了，虽然今年每次跑步的距离不长，超过 10km 的都很少，但是频次很高，基本上每周都会跑 3～5 次，所以，总结下来，这一年还是跑了有一千多公里，对不追求成绩的我来说，已经很好了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/60e46da6af472b2a04b47b7ed4870818.PNG"></p>
<p>跑步了一千多公里，虽然今年每次跑的都不远，但是频次高，公司也有跑步机，所以冬天跑步的并不少，所以也有1000km，但是体重没有降下去，应该是因为力量训练少了。</p>
<h3 id="骑行"><a href="#骑行" class="headerlink" title="骑行"></a>骑行</h3><p>在发发奇的时候周末还有时间出去骑车，骑了好几次淀山湖，但是到新公司之后几乎不再骑行了，因为刚好遇到了周末加班，周末本来休息时间就一天主要用来陪娃玩了，没有时间出去骑车了。</p>
<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年读书也还不少，能看到八月份没有读完一本书，因为忙着准备面试，静不下来心来读书，我的读书时间基本上就是在地铁上进行的，地铁上的通勤时间就是我的阅读时间。</p>
<p>从读书的分类来看，我的确是一个 J 人，更多喜欢历史和哲学。今年我阅读了更多的历史和哲学，也渐渐接受了步入中年的事实，慢慢开始向内求索，去看内心最真实的想法，尝试和自己和解。</p>
<p>下面是我使用 Obsidian 微信读书插件同步了我所有在微信读书读过的书籍，然后配合 dataview 插件可以制作比较漂亮的读书卡片。</p>
<p>读完了两本英文原著，一本是 Steve Jobs 的《Make something wonderful》还有一个是 Morgan Hosel 的《The Psychology of Money》都收获满满。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhaohongxuan/picgo@master/202501210807040.png"></p>
<h2 id="生活-x2F-家庭"><a href="#生活-x2F-家庭" class="headerlink" title="生活&#x2F;家庭"></a>生活&#x2F;家庭</h2><p>提前还贷，把目前房子的商贷提前还完了</p>
<h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>3月份去了覆卮山，玩的很开心<br>4月份去了苏州太湖西山<br>5月份回了老家，去龙门山上采摘樱桃，玩的很开心<br>8月底，在暑假的尾巴收到了offer， 带老妈和女儿回老家呆了一周多，在家里玩的很开心，虽然一到家就被蚊子咬了几个包 &#x3D;.&#x3D;<br>9～12月基本上就是加班了，周末就在周边附近玩了，哪里也没有去，10月份第三次环太湖计划也被迫终止。</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
</search>
